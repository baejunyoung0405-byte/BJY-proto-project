<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>화이트 큐브 룸</title>
  <style>
    :root {
      --bg: #0e0e10;
      --ink: #f5f5f5;
      --muted: rgba(245, 245, 245, 0.6);
      --accent: #56b6f7;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      color: var(--ink);
      font-family: "Noto Sans KR", "Pretendard", "Apple SD Gothic Neo", sans-serif;
      overflow: hidden;
    }
    #ui {
      position: fixed;
      left: 16px;
      top: 16px;
      z-index: 5;
      background: rgba(10, 10, 12, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 12px;
      padding: 12px 14px;
      backdrop-filter: blur(6px);
      max-width: min(420px, 90vw);
    }
    #ui h1 {
      font-size: 16px;
      margin: 0 0 6px;
      letter-spacing: 0.02em;
    }
    #ui p {
      margin: 4px 0;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.4;
    }
    #ui .key {
      color: var(--ink);
      font-weight: 700;
    }
    #hint {
      position: fixed;
      right: 16px;
      top: 16px;
      z-index: 5;
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(86, 182, 247, 0.2);
      border: 1px solid rgba(86, 182, 247, 0.6);
      color: var(--accent);
      font-size: 12px;
    }
    #minimap {
      position: fixed;
      right: 16px;
      top: 16px;
      width: 320px;
      height: 320px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.35);
      background: rgba(8, 8, 12, 0.6);
      overflow: hidden;
      z-index: 9;
      pointer-events: none;
    }
    #minimap canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    #crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 14px;
      height: 14px;
      margin-left: -7px;
      margin-top: -7px;
      border: 1px solid rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      pointer-events: none;
      z-index: 4;
    }
    #lockCircleLarge, .lockCircleSmall {
      position: fixed;
      left: 50%;
      top: 50%;
      border-radius: 50%;
      pointer-events: none;
      z-index: 4;
      transform: translate(-50%, -50%);
    }
    #lockCircleLarge {
      width: 640px;
      height: 640px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
    }
    #hitGreen {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(380px, -50%);
      color: #7dff7d;
      font-size: 18px;
      letter-spacing: 0.04em;
      display: none;
      z-index: 6;
      -webkit-text-stroke: 1px rgba(125, 255, 125, 0.9);
      text-shadow: 0 0 6px rgba(125, 255, 125, 0.35);
    }
    #hitRed {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-430px, -50%);
      color: #ff7d7d;
      font-size: 18px;
      letter-spacing: 0.04em;
      display: none;
      z-index: 6;
      text-align: center;
      line-height: 1.3;
      -webkit-text-stroke: 1px rgba(255, 125, 125, 0.9);
      text-shadow: 0 0 6px rgba(255, 125, 125, 0.35);
    }
    .lockCircleSmall {
      width: 22px;
      height: 22px;
      border: 1px solid rgba(255, 90, 90, 0.9);
      box-shadow: 0 0 8px rgba(255, 90, 90, 0.6);
      display: none;
    }
    .ammoPanel {
      position: fixed;
      right: 16px;
      bottom: 18px;
      z-index: 7;
      background: rgba(10, 10, 12, 0.65);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 12px;
      color: #ffffff;
      min-width: 200px;
      line-height: 1.5;
    }
    #ammoPanel {
      transform: none;
    }
    .ammoPanel.left {
      right: 16px;
      left: auto;
      transform: translateX(-220px);
    }
    #apPanel {
      position: fixed;
      left: 16px;
      bottom: 18px;
      z-index: 7;
      min-width: 220px;
      color: #ffffff;
      font-size: 12px;
    }
    #paPanel {
      position: fixed;
      left: 16px;
      bottom: 48px;
      z-index: 7;
      min-width: 220px;
      color: #ffffff;
      font-size: 12px;
    }
    #expansionPanel {
      position: fixed;
      left: 16px;
      bottom: 84px;
      z-index: 7;
      display: grid;
      grid-template-columns: 56px 1fr;
      gap: 10px;
      align-items: center;
      color: #ffffff;
      font-size: 12px;
    }
    #expansionSlot {
      width: 56px;
      height: 56px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      border-radius: 10px;
      background: rgba(10, 10, 12, 0.6);
      display: grid;
      align-items: center;
      justify-items: center;
      font-size: 14px;
      color: #ff5a5a;
      position: relative;
    }
    #expansionSlot .cooldown {
      position: absolute;
      inset: 0;
      background: rgba(255, 90, 90, 0.18);
      transform-origin: bottom;
      transform: scaleY(0);
      border-radius: 10px;
      pointer-events: none;
    }
    #expansionList {
      display: grid;
      gap: 6px;
    }
    #expansionList .title {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.8);
      letter-spacing: 0.02em;
    }
    #expansionList .name {
      font-size: 13px;
      color: #ffffff;
    }
    #expansionList .count {
      font-size: 12px;
      color: #ff5a5a;
    }
    #apPanel .label {
      margin-bottom: 6px;
      color: rgba(255, 255, 255, 0.8);
    }
    #paPanel .label {
      margin-bottom: 6px;
      color: rgba(255, 255, 255, 0.8);
    }
    #apBar {
      height: 12px;
      background: #000000;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      overflow: hidden;
    }
    #paBar {
      height: 12px;
      background: #000000;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      overflow: hidden;
    }
    #apFill {
      height: 100%;
      width: 100%;
      background: #ffffff;
    }
    #paFill {
      height: 100%;
      width: 100%;
      background: #59ff7a;
    }
    #ammoPanel .row {
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }
    #ammoPanel .label {
      color: rgba(255, 255, 255, 0.75);
    }
    #stamina {
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      z-index: 6;
      width: min(520px, 88vw);
    }
    #enBarWrap {
      position: fixed;
      left: 50%;
      bottom: 46px;
      transform: translateX(-50%);
      z-index: 6;
      width: min(520px, 88vw);
    }
    #stamina .label {
      font-size: 12px;
      color: #000000;
      margin-bottom: 6px;
      letter-spacing: 0.02em;
    }
    #enBarWrap .label {
      font-size: 12px;
      color: #000000;
      margin-bottom: 6px;
      letter-spacing: 0.02em;
    }
    #stamina .bar {
      height: 16px;
      border: 1px solid #000000;
      border-radius: 6px;
      overflow: hidden;
      position: relative;
    }
    #enBarWrap .bar {
      height: 16px;
      border: 1px solid #000000;
      border-radius: 6px;
      overflow: hidden;
      position: relative;
    }
    #stamina .fill {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 100%;
      background: #ffd93d;
      transition: width 0.08s linear;
    }
    #enBarWrap .fill {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 100%;
      background: #4aa3ff;
      transition: width 0.08s linear;
    }
    #stamina .ticks {
      position: absolute;
      inset: 0;
      background:
        repeating-linear-gradient(
          90deg,
          #000000 0px,
          #000000 1px,
          transparent 1px,
          transparent 10%
        );
      pointer-events: none;
    }
    #enBarWrap .ticks {
      position: absolute;
      inset: 0;
      background:
        repeating-linear-gradient(
          90deg,
          #000000 0px,
          #000000 1px,
          transparent 1px,
          transparent 10%
        );
      pointer-events: none;
    }
    #energyWarning {
      position: fixed;
      left: 50%;
      bottom: 96px;
      transform: translateX(-50%);
      z-index: 7;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(255, 80, 80, 0.2);
      border: 1px solid rgba(255, 80, 80, 0.7);
      color: #ff8080;
      font-size: 12px;
      letter-spacing: 0.02em;
      display: none;
    }
    #apWarning {
      position: fixed;
      left: 50%;
      top: 28%;
      transform: translateX(-50%);
      z-index: 60;
      padding: 10px 18px;
      border-radius: 12px;
      background: rgba(255, 70, 70, 0.2);
      border: 1px solid rgba(255, 70, 70, 0.7);
      color: #ff8080;
      font-size: 16px;
      letter-spacing: 0.02em;
      display: none;
    }
    #lockWarning {
      position: fixed;
      left: 50%;
      top: 6%;
      transform: translateX(-50%);
      z-index: 60;
      padding: 8px 16px;
      border-radius: 999px;
      background: rgba(255, 60, 60, 0.2);
      border: 1px solid rgba(255, 60, 60, 0.75);
      color: #ff9a9a;
      font-size: 13px;
      letter-spacing: 0.02em;
      display: none;
    }
    .threatArrow {
      position: fixed;
      width: 0;
      height: 0;
      border-left: 20px solid transparent;
      border-right: 20px solid transparent;
      border-bottom: 44px solid rgba(255, 120, 120, 0.85);
      pointer-events: none;
      z-index: 7;
      display: none;
      transform-origin: 50% 80%;
    }
    .enemyLabel {
      position: fixed;
      z-index: 6;
      font-size: 10px;
      color: #ffffff;
      background: rgba(0, 0, 0, 0.45);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      padding: 2px 6px;
      pointer-events: none;
      white-space: nowrap;
    }
    .enemyLabel.locked {
      border-color: rgba(255, 90, 90, 0.9);
      box-shadow: 0 0 10px rgba(255, 90, 90, 0.6);
      color: #ffd6d6;
    }
    .floatText {
      position: fixed;
      z-index: 6;
      font-size: 11px;
      font-weight: 600;
      pointer-events: none;
      transform: translate(-50%, -50%);
      text-shadow: 0 0 6px rgba(0, 0, 0, 0.6);
    }
    #quickBar {
      position: fixed;
      left: 50%;
      bottom: 70px;
      transform: translateX(-50%);
      z-index: 7;
      display: grid;
      grid-template-columns: repeat(10, 36px);
      gap: 6px;
      align-items: end;
    }
    .quickSlot {
      height: 36px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      border-radius: 6px;
      background: rgba(10, 10, 12, 0.6);
      color: #ffffff;
      display: grid;
      align-items: center;
      justify-items: center;
      font-size: 12px;
      position: relative;
    }
    .quickLabel {
      position: absolute;
      top: -16px;
      font-size: 10px;
      color: rgba(255, 255, 255, 0.8);
      white-space: nowrap;
    }
    .quickCount {
      position: absolute;
      bottom: 2px;
      right: 4px;
      font-size: 10px;
      color: #ffffff;
    }
    .quickCooldown {
      position: absolute;
      inset: 0;
      background: rgba(120, 255, 120, 0.18);
      transform-origin: bottom;
      transform: scaleY(0);
      border-radius: 6px;
      pointer-events: none;
    }
    #repairOverlay {
      position: fixed;
      inset: 0;
      background: rgba(140, 255, 140, 0.18);
      opacity: 0;
      pointer-events: none;
      z-index: 50;
      transition: opacity 0.1s linear;
    }
    #damageShield {
      position: fixed;
      inset: 0;
      border: 16px solid rgba(140, 255, 140, 0);
      pointer-events: none;
      z-index: 49;
      transition: border-color 0.1s linear;
    }
    #expansionOverlay {
      position: fixed;
      inset: 0;
      border: 8px solid rgba(255, 70, 70, 0.55);
      background: rgba(255, 60, 60, 0.08);
      opacity: 0;
      pointer-events: none;
      z-index: 51;
      transition: opacity 0.1s linear;
    }
    #menuOverlay {
      position: fixed;
      inset: 0;
      background: rgba(10, 10, 12, 0.78);
      color: #ffffff;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
      backdrop-filter: blur(4px);
    }
    #menuOverlay.active {
      display: flex;
    }
    #menuPanel {
      width: min(980px, 92vw);
      min-height: min(560px, 80vh);
      background: rgba(20, 20, 24, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      padding: 22px 24px 20px;
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    #menuPanel h2 {
      margin: 0 0 8px;
      font-size: 18px;
      letter-spacing: 0.02em;
    }
    #menuPanel p {
      margin: 0;
      font-size: 13px;
      color: rgba(255, 255, 255, 0.75);
      line-height: 1.5;
    }
    #menuTabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      padding-right: 34px;
    }
    .menuTab {
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: transparent;
      color: rgba(255, 255, 255, 0.7);
      padding: 8px 12px;
      border-radius: 999px;
      font-size: 13px;
      cursor: pointer;
      transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
    }
    .menuTab.active {
      background: rgba(255, 255, 255, 0.12);
      color: #ffffff;
      border-color: rgba(255, 255, 255, 0.7);
    }
    #menuContent {
      flex: 1;
      background: rgba(10, 10, 14, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 12px;
      padding: 16px;
      overflow: auto;
    }
    .menuSection {
      display: none;
    }
    .menuSection.active {
      display: block;
    }
    .dualPane {
      display: grid;
      grid-template-columns: minmax(220px, 280px) 1fr;
      gap: 16px;
      align-items: stretch;
    }
    .detailPane {
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      background: rgba(6, 6, 8, 0.8);
      padding: 14px;
      display: grid;
      grid-template-rows: auto auto 1fr;
      gap: 12px;
      min-height: 360px;
    }
    .detailIconLarge {
      width: 120px;
      height: 120px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.02));
      position: relative;
      margin-bottom: 8px;
    }
    .detailIconLarge::after {
      content: "";
      position: absolute;
      inset: 14px;
      border: 1px dashed rgba(255, 255, 255, 0.35);
      border-radius: 10px;
    }
    .detailName {
      font-size: 14px;
      color: #ffffff;
      margin: 0;
    }
    .detailDesc {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.7);
      line-height: 1.5;
      background: rgba(255, 255, 255, 0.03);
      border: 1px dashed rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      padding: 10px;
      min-height: 120px;
    }
    .iconGrid {
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 12px;
      background: rgba(10, 10, 14, 0.5);
      padding: 12px;
      height: 100%;
      overflow: auto;
      cursor: grab;
    }
    .iconGrid.dragging {
      cursor: grabbing;
    }
    .gridWrap {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 10px;
    }
    .gridItem {
      display: grid;
      gap: 6px;
      justify-items: center;
      text-align: center;
      cursor: pointer;
    }
    .gridIcon {
      width: 56px;
      height: 56px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
      position: relative;
    }
    .gridIcon::after {
      content: "";
      position: absolute;
      inset: 10px;
      border: 1px dashed rgba(255, 255, 255, 0.35);
      border-radius: 6px;
    }
    .gridLabel {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.75);
      line-height: 1.2;
    }
    .assemblyGrid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .assemblyLayout {
      display: grid;
      grid-template-columns: minmax(220px, 280px) 1fr;
      gap: 16px;
      align-items: start;
    }
    #assemblyPreview {
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      background: rgba(6, 6, 8, 0.8);
      padding: 12px;
      display: grid;
      gap: 8px;
    }
    #assemblyPreview h3 {
      margin: 0;
      font-size: 13px;
      color: rgba(255, 255, 255, 0.85);
    }
    #assemblyPreviewCanvas {
      width: 100%;
      aspect-ratio: 1 / 1;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 10px;
      border: 1px dashed rgba(255, 255, 255, 0.2);
      cursor: grab;
    }
    #assemblyPreviewCanvas.dragging {
      cursor: grabbing;
    }
    .assemblyGroup {
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 12px;
      padding: 12px;
      background: rgba(8, 8, 12, 0.5);
    }
    .assemblyTitle {
      font-size: 14px;
      margin: 0 0 10px;
      color: #ffffff;
      letter-spacing: 0.02em;
    }
    .assemblyItems {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }
    .assemblyItem {
      display: grid;
      gap: 6px;
      align-items: center;
      justify-items: center;
      text-align: center;
      cursor: pointer;
    }
    .assemblyIcon {
      width: 56px;
      height: 56px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
      position: relative;
    }
    .assemblyIcon.machinehandgun {
      background-color: rgba(255, 255, 255, 0.04);
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'><rect width='56' height='56' fill='none'/><g fill='none' stroke='%23d7d7d7' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M10 30 h26 l6 -4 h4'/><path d='M18 30 v10 h6 v-6'/><path d='M10 30 v6 h8'/><path d='M36 26 h6 v4'/></g></svg>");
      background-repeat: no-repeat;
      background-position: center;
    }
    .assemblyIcon::after {
      content: "";
      position: absolute;
      inset: 10px;
      border: 1px dashed rgba(255, 255, 255, 0.35);
      border-radius: 6px;
    }
    .assemblyLabel {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.8);
      line-height: 1.3;
    }
    #assemblyDetail {
      margin-top: 16px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      background: rgba(6, 6, 8, 0.8);
      padding: 16px;
      display: none;
    }
    #assemblyDetail.active {
      display: block;
    }
    #assemblyDetailHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 12px;
    }
    #assemblyDetailTitle {
      font-size: 14px;
      color: #ffffff;
      margin: 0;
    }
    #assemblyDetailClose {
      width: 18px;
      height: 18px;
      border: 1px solid rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      position: relative;
      cursor: pointer;
    }
    #assemblyDetailClose::before,
    #assemblyDetailClose::after {
      content: "";
      position: absolute;
      top: 3px;
      left: 8px;
      width: 2px;
      height: 12px;
      background: #ffffff;
    }
    #assemblyDetailClose::before { transform: rotate(45deg); }
    #assemblyDetailClose::after { transform: rotate(-45deg); }
    .detailSection {
      margin-bottom: 14px;
    }
    .detailSection h4 {
      margin: 0 0 8px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.8);
      letter-spacing: 0.02em;
    }
    .detailGrid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
      gap: 10px;
    }
    .detailIcon {
      height: 64px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.02));
      position: relative;
    }
    .detailIcon::after {
      content: "";
      position: absolute;
      inset: 12px;
      border: 1px dashed rgba(255, 255, 255, 0.35);
      border-radius: 6px;
    }
    .statusPlaceholder {
      min-height: 120px;
      border-radius: 12px;
      border: 1px dashed rgba(255, 255, 255, 0.35);
      background: rgba(255, 255, 255, 0.03);
      padding: 10px;
      color: rgba(255, 255, 255, 0.88);
      font-size: 12px;
    }
    .statusRows {
      display: grid;
      gap: 8px;
    }
    .statusRow {
      display: grid;
      grid-template-columns: 110px 1fr;
      gap: 8px;
      align-items: center;
    }
    .statusRow .key {
      color: rgba(255, 255, 255, 0.72);
      font-size: 11px;
      border: 0;
      background: none;
      padding: 0;
      box-shadow: none;
    }
    .statusRow .value {
      color: #ffffff;
      font-size: 12px;
    }
    #menuClose {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 20px;
      height: 20px;
      border: 1px solid rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      cursor: pointer;
    }
    #menuClose::before,
    #menuClose::after {
      content: "";
      position: absolute;
      top: 4px;
      left: 9px;
      width: 2px;
      height: 12px;
      background: #ffffff;
    }
    #menuClose::before {
      transform: rotate(45deg);
    }
    #menuClose::after {
      transform: rotate(-45deg);
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="ui">
    <h1>화이트 큐브 룸 (필드 11 x 11)</h1>
    <p><span class="key">W</span> 전면 이동 · <span class="key">A</span> 좌면 이동 · <span class="key">S</span> 후면 이동 · <span class="key">D</span> 우면 이동</p>
    <p><span class="key">Space</span> 점프 · <span class="key">마우스</span> 시점 변경</p>
    <p>화면을 클릭하면 마우스가 고정됩니다. ESC로 해제됩니다.</p>
  </div>
    <div id="minimap" aria-hidden="true"><canvas id="minimapCanvas"></canvas></div>
    <div id="crosshair" aria-hidden="true"></div>
    <div id="lockCircleLarge" aria-hidden="true"></div>
    <div id="hitGreen">HIT</div>
    <div id="hitRed"><div>HIT</div><div>DAMAGE</div></div>
  <div id="ammoPanel" class="ammoPanel" aria-live="polite">
    <div class="row">
      <div class="label">우측 등 무장</div>
    </div>
    <div class="row">
      <div id="ammoRightBack">장전 30 / 잔탄 ∞</div>
    </div>
    <div class="row" style="margin-top:8px;"></div>
    <div class="row">
      <div class="label">우측 어깨 무장</div>
    </div>
    <div class="row">
      <div id="ammoRightShoulder">장전 30 / 잔탄 ∞</div>
    </div>
    <div class="row" style="margin-top:2px;">
      <div class="label">우측 어깨 내장 무장</div>
    </div>
    <div class="row">
      <div id="ammoRightShoulderInner">장전 30 / 잔탄 ∞</div>
    </div>
    <div class="row" style="margin-top:8px;"></div>
    <div class="row">
      <div class="label">우측 손 무장</div>
    </div>
    <div class="row">
      <div id="ammoRight">장전 30 / 잔탄 ∞</div>
    </div>
    <div class="row" style="margin-top:2px;">
      <div class="label">우측 손 내장 무장</div>
    </div>
    <div class="row">
      <div id="ammoRightInner">장전 30 / 잔탄 ∞</div>
    </div>
  </div>
  <div id="ammoPanelLeft" class="ammoPanel left" aria-live="polite">
    <div class="row">
      <div class="label">좌측 등 무장</div>
    </div>
    <div class="row">
      <div id="ammoLeftBack">장전 30 / 잔탄 ∞</div>
    </div>
    <div class="row" style="margin-top:8px;"></div>
    <div class="row">
      <div class="label">좌측 어깨 무장</div>
    </div>
    <div class="row">
      <div id="ammoLeftShoulder">장전 30 / 잔탄 ∞</div>
    </div>
    <div class="row" style="margin-top:2px;">
      <div class="label">좌측 어깨 내장 무장</div>
    </div>
    <div class="row">
      <div id="ammoLeftShoulderInner">장전 30 / 잔탄 ∞</div>
    </div>
    <div class="row" style="margin-top:8px;"></div>
    <div class="row">
      <div class="label">좌측 손 무장</div>
      <div id="ammoLeft">장전 30 / 잔탄 ∞</div>
    </div>
    <div class="row">
      <div class="label">좌측 손 내장 무장</div>
      <div id="ammoLeftInner">장전 30 / 잔탄 ∞</div>
    </div>
  </div>
  <div id="quickBar" aria-live="polite">
    <div class="quickSlot" data-slot="1">
      <div class="quickLabel">리페어 키트</div>
      1
      <div class="quickCount" id="kitCount">∞</div>
      <div class="quickCooldown" id="kitCooldown"></div>
    </div>
      <div class="quickSlot" data-slot="2">
        <div class="quickLabel">코어 내장 무장</div>
        2
        <div class="quickCount" id="septiaCount">72</div>
        <div class="quickCooldown" id="septiaGauge"></div>
      </div>
    <div class="quickSlot" data-slot="3">3</div>
    <div class="quickSlot" data-slot="4">4</div>
    <div class="quickSlot" data-slot="5">5</div>
    <div class="quickSlot" data-slot="6">6</div>
    <div class="quickSlot" data-slot="7">7</div>
    <div class="quickSlot" data-slot="8">8</div>
    <div class="quickSlot" data-slot="9">9</div>
    <div class="quickSlot" data-slot="0">0</div>
  </div>
    <div id="repairOverlay"></div>
    <div id="damageShield"></div>
    <div id="expansionOverlay"></div>
    <div id="paPanel" aria-live="polite">
      <div class="label">PA 9999 / 9999</div>
      <div id="paBar">
        <div id="paFill"></div>
      </div>
    </div>
    <div id="expansionPanel" aria-live="polite">
      <div id="expansionSlot">
        ∞
        <div class="cooldown" id="expansionCooldown"></div>
      </div>
      <div id="expansionList">
        <div class="title">익스팬션</div>
        <div class="name">셀 윙</div>
        <div class="count">∞</div>
      </div>
    </div>
    <div id="apPanel" aria-live="polite">
      <div class="label">AP 99999 / 99999</div>
      <div id="apBar">
        <div id="apFill"></div>
      </div>
    </div>
    <div id="enBarWrap" aria-live="polite">
      <div class="label">EN 바</div>
      <div class="bar">
        <div id="enFill" class="fill"></div>
        <div class="ticks" aria-hidden="true"></div>
      </div>
    </div>
    <div id="energyWarning">에너지 고갈 상태</div>
    <div id="apWarning">치명적인 피해!</div>
    <div id="lockWarning">경고: 락온됨</div>
    <div id="stamina" aria-live="polite">
      <div class="label">스테미너 바</div>
      <div class="bar">
        <div id="staminaFill" class="fill"></div>
        <div class="ticks" aria-hidden="true"></div>
    </div>
  </div>
  <div id="menuOverlay" aria-hidden="true">
    <div id="menuPanel" role="dialog" aria-modal="true" aria-label="메뉴">
      <div id="menuClose" aria-label="닫기"></div>
      <h2>메뉴</h2>
      <div id="menuTabs" role="tablist" aria-label="메뉴 탭">
        <button class="menuTab active" data-tab="controls" role="tab" aria-selected="true">조작법</button>
        <button class="menuTab" data-tab="codex" role="tab" aria-selected="false">도감</button>
        <button class="menuTab" data-tab="assembly" role="tab" aria-selected="false">어셈블리</button>
        <button class="menuTab" data-tab="items" role="tab" aria-selected="false">아이템</button>
        <button class="menuTab" data-tab="shop" role="tab" aria-selected="false">상점</button>
      </div>
      <div id="menuContent">
        <div id="tab-controls" class="menuSection active">
          <p><strong>조작법</strong></p>
          <p>W/A/S/D: 이동 · 마우스: 시점 변경 · Space: 점프</p>
          <p>Shift(체공): 공중에서 유지, Shift+W는 시점 방향으로 비행 가속</p>
          <p>대쉬: 체공(Shift) + Space 상태에서 W/A/S/D 입력</p>
          <p>Q(셀 윙): 1초 홀드로 발동, 일정 시간 강화/무적</p>
          <p>1(리페어 키트): 1초 홀드로 AP 회복/피해 감소</p>
          <p>2(셉티아): 누르는 동안 다이아몬드 발사</p>
          <p>락온: 큰 원 안의 적/블럭에 자동 조준(유도 사격)</p>
        </div>
        <div id="tab-codex" class="menuSection">
          <p><strong>도감</strong></p>
          <div class="dualPane">
            <div class="detailPane" id="codexDetail">
              <div>
                <div class="detailIconLarge" id="codexDetailIcon"></div>
                <h3 class="detailName" id="codexDetailName">도감 항목</h3>
              </div>
              <div class="detailDesc" id="codexDetailDesc">선택한 도감 항목의 설명이 표시됩니다.</div>
            </div>
            <div class="iconGrid" id="codexGrid">
              <div class="gridWrap" id="codexGridWrap"></div>
            </div>
          </div>
        </div>
        <div id="tab-assembly" class="menuSection">
          <p><strong>어셈블리</strong></p>
          <div class="assemblyLayout">
            <div id="assemblyPreview">
              <h3>기체 미리보기</h3>
              <canvas id="assemblyPreviewCanvas"></canvas>
            </div>
            <div class="assemblyGrid">
              <div class="assemblyGroup">
                <h3 class="assemblyTitle">헤드</h3>
                <div class="assemblyItems">
                <div class="assemblyItem" data-assembly="FCS">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">FCS</div>
                </div>
                <div class="assemblyItem" data-assembly="헤드 내장 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">헤드 내장 무장</div>
                  </div>
                </div>
              </div>
              <div class="assemblyGroup">
                <h3 class="assemblyTitle">코어</h3>
                <div class="assemblyItems">
                  <div class="assemblyItem" data-assembly="제네레이터">
                    <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">제네레이터</div>
                </div>
                <div class="assemblyItem" data-assembly="부스터">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">부스터</div>
                </div>
                <div class="assemblyItem" data-assembly="우측 등 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">우측 등 무장</div>
                </div>
                <div class="assemblyItem" data-assembly="좌측 등 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">좌측 등 무장</div>
                </div>
                <div class="assemblyItem" data-assembly="코어 내장 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">코어 내장 무장</div>
                </div>
                <div class="assemblyItem" data-assembly="익스팬션">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">익스팬션</div>
                </div>
                </div>
              </div>
              <div class="assemblyGroup">
                <h3 class="assemblyTitle">우완부</h3>
                <div class="assemblyItems">
                <div class="assemblyItem" data-assembly="우측 손 무장: 테스트용 머신핸드건" data-slot="우측 손 무장">
                  <div class="assemblyIcon machinehandgun"></div>
                  <div class="assemblyLabel">테스트용 머신핸드건</div>
                </div>
                <div class="assemblyItem" data-assembly="우측 손 내장 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">우측 손 내장 무장</div>
                </div>
                <div class="assemblyItem" data-assembly="우측 어깨 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">우측 어깨 무장</div>
                </div>
                <div class="assemblyItem" data-assembly="우측 어깨 내장 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">우측 어깨 내장 무장</div>
                  </div>
                </div>
              </div>
              <div class="assemblyGroup">
                <h3 class="assemblyTitle">좌완부</h3>
                <div class="assemblyItems">
                <div class="assemblyItem" data-assembly="좌측 손 무장: 테스트용 머신핸드건" data-slot="좌측 손 무장">
                  <div class="assemblyIcon machinehandgun"></div>
                  <div class="assemblyLabel">테스트용 머신핸드건</div>
                </div>
                <div class="assemblyItem" data-assembly="좌측 손 내장 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">좌측 손 내장 무장</div>
                </div>
                <div class="assemblyItem" data-assembly="좌측 어깨 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">좌측 어깨 무장</div>
                </div>
                <div class="assemblyItem" data-assembly="좌측 어깨 내장 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">좌측 어깨 내장 무장</div>
                  </div>
                </div>
              </div>
              <div class="assemblyGroup">
                <h3 class="assemblyTitle">각부</h3>
                <div class="assemblyItems">
                <div class="assemblyItem" data-assembly="각부 우측 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">각부 우측 무장</div>
                </div>
                <div class="assemblyItem" data-assembly="각부 좌측 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">각부 좌측 무장</div>
                </div>
                <div class="assemblyItem" data-assembly="서브 부스터">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">서브 부스터</div>
                </div>
                </div>
              </div>
            </div>
          </div>
          <div id="assemblyDetail" aria-live="polite">
            <div id="assemblyDetailHeader">
              <h3 id="assemblyDetailTitle">선택된 파츠</h3>
              <div style="display:flex; gap:8px; align-items:center;">
                <button id="assemblyUnequip" class="menuTab" style="border-radius:10px;">무장 해제</button>
                <div id="assemblyDetailClose" aria-label="닫기"></div>
              </div>
            </div>
            <div class="detailSection">
              <h4>현재 착용 중인 파츠</h4>
              <div class="detailGrid" id="assemblyDetailCurrent">
                <div class="detailIcon"></div>
              </div>
            </div>
            <div class="detailSection">
              <h4>소지한 파츠</h4>
              <div class="detailGrid" id="assemblyDetailInventory">
                <div class="detailIcon"></div>
                <div class="detailIcon"></div>
                <div class="detailIcon"></div>
                <div class="detailIcon"></div>
              </div>
            </div>
            <div class="detailSection">
              <h4>스테이터스</h4>
              <div class="statusPlaceholder" id="assemblyDetailStatus">스테이터스 영역 (추후 추가)</div>
            </div>
          </div>
        </div>
        <div id="tab-items" class="menuSection">
          <p><strong>아이템</strong></p>
          <div class="dualPane">
            <div class="detailPane" id="itemDetail">
              <div>
                <div class="detailIconLarge" id="itemDetailIcon"></div>
                <h3 class="detailName" id="itemDetailName">아이템</h3>
              </div>
              <div class="detailDesc" id="itemDetailDesc">선택한 아이템의 설명이 표시됩니다.</div>
            </div>
            <div class="iconGrid" id="itemGrid">
              <div class="gridWrap" id="itemGridWrap"></div>
            </div>
          </div>
        </div>
        <div id="tab-shop" class="menuSection">
          <p><strong>상점</strong></p>
          <div class="dualPane">
            <div class="detailPane" id="shopDetail">
              <div>
                <div class="detailIconLarge" id="shopDetailIcon"></div>
                <h3 class="detailName" id="shopDetailName">상점 아이템</h3>
              </div>
              <div class="detailDesc" id="shopDetailDesc">선택한 상점 아이템의 설명이 표시됩니다.</div>
            </div>
            <div class="iconGrid" id="shopGrid">
              <div class="gridWrap" id="shopGridWrap"></div>
            </div>
          </div>
        </div>
      </div>
      <p>E 키를 다시 누르거나 우측 상단의 X를 클릭하면 게임이 재개됩니다.</p>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    const cellSize = 10;
    const roomCells = 11;
    const roomSize = roomCells * cellSize;
    const roomHeight = 3 * cellSize;
    const half = roomSize / 2;
    const worldHalf = roomSize + half;
    const playerSize = 1;
    const playerHalf = playerSize / 2;
    const floorY = playerHalf;
    const ceilingY = roomHeight - playerHalf;
    const moveSpeed = 10.5;
    const dashDistance = moveSpeed;
    const dashCooldown = 0.2;
    const flyAccel = 20;
    const gravity = 25;
    const jumpHeight = 0.5;
    const baseJumpSpeed = Math.sqrt(2 * gravity * jumpHeight);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0e0e10);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.05, 1000);
    camera.position.set(0, playerSize, 4);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const ambient = new THREE.AmbientLight(0xffffff, 0.7);
    const dir = new THREE.DirectionalLight(0xffffff, 0.7);
    dir.position.set(5, 10, 2);
    scene.add(ambient, dir);

    const gridMaterial = new THREE.LineBasicMaterial({
      color: 0x000000,
      transparent: true,
      opacity: 0.55
    });

    function createMaterial(color) {
      return new THREE.MeshStandardMaterial({
        color,
        roughness: 0.9,
        metalness: 0.0,
        side: THREE.DoubleSide
      });
    }

    function mulberry32(seed) {
      return function () {
        let t = seed += 0x6d2b79f5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function buildMaze(size, openings, seed) {
      const grid = Array.from({ length: size }, () => Array(size).fill(1));
      const rand = mulberry32(seed);
      const dirs = [
        { x: 0, z: -1 },
        { x: 1, z: 0 },
        { x: 0, z: 1 },
        { x: -1, z: 0 }
      ];

      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i -= 1) {
          const j = Math.floor(rand() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }

      function carve(x, z) {
        grid[z][x] = 0;
        const order = dirs.slice();
        shuffle(order);
        for (const dir of order) {
          const nx = x + dir.x * 2;
          const nz = z + dir.z * 2;
          if (nx > 0 && nx < size - 1 && nz > 0 && nz < size - 1 && grid[nz][nx] === 1) {
            grid[z + dir.z][x + dir.x] = 0;
            carve(nx, nz);
          }
        }
      }

      const center = Math.floor(size / 2);
      carve(center, center);

      function openCorridor(x, z, dx, dz) {
        while (x >= 0 && x < size && z >= 0 && z < size) {
          grid[z][x] = 0;
          if (x === center && z === center) break;
          x += dx;
          z += dz;
        }
      }

      if (openings.n) openCorridor(center, 0, 0, 1);
      if (openings.s) openCorridor(center, size - 1, 0, -1);
      if (openings.w) openCorridor(0, center, 1, 0);
      if (openings.e) openCorridor(size - 1, center, -1, 0);

      grid[center][center] = 0;
      return grid;
    }

    function createGridLines(width, height, divisionsW, divisionsH) {
      const vertices = [];
      const stepW = width / divisionsW;
      const stepH = height / divisionsH;
      const halfW = width / 2;
      const halfH = height / 2;

      for (let i = 0; i <= divisionsW; i += 1) {
        const x = -halfW + stepW * i;
        vertices.push(x, -halfH, 0, x, halfH, 0);
      }
      for (let j = 0; j <= divisionsH; j += 1) {
        const y = -halfH + stepH * j;
        vertices.push(-halfW, y, 0, halfW, y, 0);
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
      return new THREE.LineSegments(geometry, gridMaterial);
    }

    function createRoom(center, openings, color, blockBoxes) {
      const roomMat = createMaterial(color);
      const group = new THREE.Group();
      const yCenter = roomHeight / 2;

      const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), roomMat);
      floor.rotation.x = -Math.PI / 2;
      floor.position.set(center.x, 0, center.z);
      group.add(floor);

      const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), roomMat);
      ceiling.rotation.x = Math.PI / 2;
      ceiling.position.set(center.x, roomHeight, center.z);
      group.add(ceiling);

      const floorGrid = createGridLines(roomSize, roomSize, roomSize, roomSize);
      floorGrid.rotation.x = -Math.PI / 2;
      floorGrid.position.set(center.x, 0.1, center.z);
      group.add(floorGrid);

      const ceilingGrid = createGridLines(roomSize, roomSize, roomSize, roomSize);
      ceilingGrid.rotation.x = Math.PI / 2;
      ceilingGrid.position.set(center.x, roomHeight - 0.1, center.z);
      group.add(ceilingGrid);

      if (!openings.n) {
        const north = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), roomMat);
        north.position.set(center.x, yCenter, center.z - half);
        group.add(north);

        const northGrid = createGridLines(roomSize, roomHeight, roomSize, roomHeight);
        northGrid.position.set(center.x, yCenter, center.z - half + 0.1);
        group.add(northGrid);
      }

      if (!openings.s) {
        const south = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), roomMat);
        south.rotation.y = Math.PI;
        south.position.set(center.x, yCenter, center.z + half);
        group.add(south);

        const southGrid = createGridLines(roomSize, roomHeight, roomSize, roomHeight);
        southGrid.rotation.y = Math.PI;
        southGrid.position.set(center.x, yCenter, center.z + half - 0.1);
        group.add(southGrid);
      }

      if (!openings.w) {
        const west = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), roomMat);
        west.rotation.y = Math.PI / 2;
        west.position.set(center.x - half, yCenter, center.z);
        group.add(west);

        const westGrid = createGridLines(roomSize, roomHeight, roomSize, roomHeight);
        westGrid.rotation.y = Math.PI / 2;
        westGrid.position.set(center.x - half + 0.1, yCenter, center.z);
        group.add(westGrid);
      }

      if (!openings.e) {
        const east = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), roomMat);
        east.rotation.y = -Math.PI / 2;
        east.position.set(center.x + half, yCenter, center.z);
        group.add(east);

        const eastGrid = createGridLines(roomSize, roomHeight, roomSize, roomHeight);
        eastGrid.rotation.y = -Math.PI / 2;
        eastGrid.position.set(center.x + half - 0.1, yCenter, center.z);
        group.add(eastGrid);
      }

      const blockMat = createMaterial(color);
      for (const box of blockBoxes) {
        const width = box.maxX - box.minX;
        const height = box.maxY - box.minY;
        const depth = box.maxZ - box.minZ;
        const blockGeo = new THREE.BoxGeometry(width, height, depth);
        const block = new THREE.Mesh(blockGeo, blockMat);
        block.position.set(
          (box.minX + box.maxX) / 2,
          (box.minY + box.maxY) / 2,
          (box.minZ + box.maxZ) / 2
        );
        group.add(block);
      }

      scene.add(group);
    }

    const offset = roomSize;
    const rooms = [
      { x: 0, z: 0, openings: { n: true, s: true, w: true, e: true } },
      { x: 0, z: -offset, openings: { n: false, s: true, w: false, e: false } },
      { x: offset, z: 0, openings: { n: false, s: false, w: true, e: false } },
      { x: 0, z: offset, openings: { n: true, s: false, w: false, e: false } },
      { x: -offset, z: 0, openings: { n: false, s: false, w: false, e: true } }
    ];

    const roomColors = [0xffffff, 0xff4b4b, 0xffd93d, 0x43d66d, 0x3aa0ff];
      const roomSeeds = [101, 202, 303, 404, 505];
      let destructibleBlocks = [];

    // Maze blocks removed per request.

      rooms.forEach((room, index) => {
        const baseSeed = roomSeeds[index];
        room.mazeLayers = [];
        room.blockBoxes = [];
        room.destructibles = [];
        room.destructibleSlots = [];
        room.destructibleOccupied = new Set();
        createRoom(
          new THREE.Vector3(room.x, 0, room.z),
          room.openings,
          roomColors[index],
          room.blockBoxes
        );
      });

      const destructibleSpawnTimers = new Map();
      const destructibleBlockSize = 0.9;

      function buildDestructibleSlots(roomIndex) {
        const room = rooms[roomIndex];
        const margin = 0.6;
        const slots = [];
        const step = 6;
        const minX = room.x - half + margin;
        const maxX = room.x + half - margin;
        const minZ = room.z - half + margin;
        const maxZ = room.z + half - margin;
        const floorYSlot = floorY + destructibleBlockSize * 0.5;
        const ceilYSlot = ceilingY - destructibleBlockSize * 0.5;

        for (let x = minX; x <= maxX; x += step) {
          for (let z = minZ; z <= maxZ; z += step) {
            slots.push(new THREE.Vector3(x, floorYSlot, z));
            slots.push(new THREE.Vector3(x, ceilYSlot, z));
          }
        }
        for (let y = floorYSlot + step; y <= ceilYSlot - step; y += step) {
          for (let z = minZ; z <= maxZ; z += step) {
            slots.push(new THREE.Vector3(minX, y, z));
            slots.push(new THREE.Vector3(maxX, y, z));
          }
          for (let x = minX; x <= maxX; x += step) {
            slots.push(new THREE.Vector3(x, y, minZ));
            slots.push(new THREE.Vector3(x, y, maxZ));
          }
        }
        if (slots.length > 600) {
          slots.length = 600;
        }
        return slots;
      }

      function spawnDestructibleInRoom(roomIndex) {
        if (destructibleBlocks.length >= 200) return;
        const room = rooms[roomIndex];
        if (!room.destructibleSlots || room.destructibleSlots.length === 0) return;
        if (room.destructibleOccupied.size >= room.destructibleSlots.length) return;
        let slotIndex = Math.floor(Math.random() * room.destructibleSlots.length);
        let safety = 0;
        while (room.destructibleOccupied.has(slotIndex) && safety < room.destructibleSlots.length) {
          slotIndex = (slotIndex + 1) % room.destructibleSlots.length;
          safety += 1;
        }
        if (room.destructibleOccupied.has(slotIndex)) return;
        const pos = room.destructibleSlots[slotIndex];
        const mesh = new THREE.Mesh(
          new THREE.BoxGeometry(destructibleBlockSize, destructibleBlockSize, destructibleBlockSize),
          new THREE.MeshStandardMaterial({ color: roomColors[roomIndex], roughness: 0.7, metalness: 0.1 })
        );
        mesh.position.copy(pos);
        scene.add(mesh);
        const block = { mesh, ap: 5000, pa: 1000, roomIndex, slotIndex };
        const box = {
          minX: pos.x - destructibleBlockSize * 0.5,
          maxX: pos.x + destructibleBlockSize * 0.5,
          minY: pos.y - destructibleBlockSize * 0.5,
          maxY: pos.y + destructibleBlockSize * 0.5,
          minZ: pos.z - destructibleBlockSize * 0.5,
          maxZ: pos.z + destructibleBlockSize * 0.5,
          destructible: block
        };
        block.box = box;
        room.blockBoxes.push(box);
        room.destructibles.push(block);
        room.destructibleOccupied.add(slotIndex);
        destructibleBlocks.push(block);
      }

      function initDestructibles() {
        for (let i = 1; i <= 4; i += 1) {
          rooms[i].destructibleSlots = buildDestructibleSlots(i);
          const initialCount = 12 + Math.floor(Math.random() * 13);
          for (let j = 0; j < initialCount; j += 1) {
            spawnDestructibleInRoom(i);
          }
          destructibleSpawnTimers.set(i, performance.now() / 1000 + 10 + Math.random() * 50);
        }
      }
      initDestructibles();

      const enemyRadius = playerSize * 0.5;
      const enemyTypes = [
        { roomIndex: 1, color: 0xff4b4b },
        { roomIndex: 2, color: 0xffd93d },
        { roomIndex: 3, color: 0x43d66d },
        { roomIndex: 4, color: 0x3aa0ff }
      ];
      const enemies = [];
      const enemyProjectiles = [];
      const enemyBeams = [];
      const explosionFields = [];
      const floatingTexts = [];
      const enemySpawnTimers = new Map();
      const enemyMoveSpeed = 3;
      const enemyAvoidRadius = 2;

      function getRoomBounds(roomIndex) {
        const room = rooms[roomIndex];
        const margin = enemyRadius + 0.4;
        return {
          minX: room.x - half + margin,
          maxX: room.x + half - margin,
          minZ: room.z - half + margin,
          maxZ: room.z + half - margin
        };
      }

      function randomPointInRoom(roomIndex) {
        const bounds = getRoomBounds(roomIndex);
        return new THREE.Vector3(
          bounds.minX + Math.random() * (bounds.maxX - bounds.minX),
          floorY + enemyRadius,
          bounds.minZ + Math.random() * (bounds.maxZ - bounds.minZ)
        );
      }

      function getRoomIndexForPos(pos) {
        for (let i = 0; i < rooms.length; i += 1) {
          const room = rooms[i];
          const minX = room.x - half + (room.openings.w ? -playerHalf : playerHalf);
          const maxX = room.x + half + (room.openings.e ? playerHalf : -playerHalf);
          const minZ = room.z - half + (room.openings.n ? -playerHalf : playerHalf);
          const maxZ = room.z + half + (room.openings.s ? playerHalf : -playerHalf);
          if (pos.x >= minX && pos.x <= maxX && pos.z >= minZ && pos.z <= maxZ) {
            return i;
          }
        }
        return -1;
      }

      function spawnEnemy(type) {
        const group = new THREE.Group();
        const coreMat = new THREE.MeshStandardMaterial({
          color: type.color,
          roughness: 0.6,
          metalness: 0.1
        });
        const core = new THREE.Mesh(new THREE.SphereGeometry(enemyRadius, 16, 16), coreMat);
        const glowMat = new THREE.MeshBasicMaterial({
          color: 0xff2f2f,
          transparent: true,
          opacity: 0
        });
        const glow = new THREE.Mesh(
          new THREE.SphereGeometry(enemyRadius * 1.08, 16, 16),
          glowMat
        );
        group.add(core, glow);
        group.position.copy(randomPointInRoom(type.roomIndex));
        scene.add(group);
        const label = document.createElement("div");
        label.className = "enemyLabel";
        label.textContent = "AP 5000 / PA 1000";
        document.body.appendChild(label);
        const now = performance.now() / 1000;
        const nextBeam = now + 50 + Math.random() * 5;
        enemies.push({
          mesh: group,
          core,
          glow,
          label,
          roomIndex: type.roomIndex,
          baseColor: new THREE.Color(type.color),
          nextBall: now + 5 + Math.random() * 2,
          nextBeam,
          chargeStart: nextBeam - 10,
          ap: 5000,
          pa: 1000,
          moveTarget: randomPointInRoom(type.roomIndex),
          nextMoveUpdate: now + 0.3 + Math.random() * 0.4,
          spawnTime: now,
          velocity: new THREE.Vector3()
        });
      }

      enemyTypes.forEach((type) => {
        const initialCount = 10 + Math.floor(Math.random() * 21);
        for (let i = 0; i < initialCount; i += 1) {
          spawnEnemy(type);
        }
        enemySpawnTimers.set(type.roomIndex, performance.now() / 1000 + 10 + Math.random() * 10);
      });

    const player = {
      position: new THREE.Vector3(0, floorY, 0),
      velocity: new THREE.Vector3(),
      grounded: true
    };

    const dummy = new THREE.Group();
    const dummyMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.8, metalness: 0.0 });
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), dummyMat);
    head.position.set(0, 1.6, 0);
    const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.3), dummyMat);
    torso.position.set(0, 1.1, 0);
    const armL = new THREE.Group();
    const armR = new THREE.Group();
    const armUpperL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 0.2), dummyMat);
    const armUpperR = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 0.2), dummyMat);
    armUpperL.position.set(0, -0.2, 0);
    armUpperR.position.set(0, -0.2, 0);
    const forearmL = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.35, 0.18), dummyMat);
    const forearmR = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.35, 0.18), dummyMat);
    forearmL.position.set(0, -0.45, 0.05);
    forearmR.position.set(0, -0.45, 0.05);
    forearmL.rotation.x = Math.PI / 4;
    forearmR.rotation.x = Math.PI / 4;
    armL.add(armUpperL, forearmL);
    armR.add(armUpperR, forearmR);
    armL.position.set(-0.45, 1.3, 0);
    armR.position.set(0.45, 1.3, 0);
    armL.rotation.x = Math.PI / 4;
    armR.rotation.x = Math.PI / 4;
    const legL = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.7, 0.25), dummyMat);
    legL.position.set(-0.15, 0.45, 0);
    const legR = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.7, 0.25), dummyMat);
    legR.position.set(0.15, 0.45, 0);
    dummy.add(head, torso, armL, armR, legL, legR);
    dummy.scale.set(0.7, 0.7, 0.7);
    scene.add(dummy);

    function buildGun(color) {
      const gunGroup = new THREE.Group();
      const gunMat = new THREE.MeshStandardMaterial({ color, roughness: 0.6, metalness: 0.2 });
      const gunMain = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.22, 0.22), gunMat);
      gunMain.position.set(0.45, 0, 0);
      gunGroup.add(gunMain);
      return gunGroup;
    }

    const gunRight = buildGun(0x111111);
    gunRight.position.set(0, -0.14, -0.12);
    gunRight.rotation.set(0, Math.PI / 2, -Math.PI / 2);
    forearmR.add(gunRight);

    const gunLeft = buildGun(0xf2f2f2);
    gunLeft.position.set(0, -0.14, -0.12);
    gunLeft.rotation.set(0, Math.PI / 2, -Math.PI / 2);
    forearmL.add(gunLeft);

    let yaw = 0;
    let pitch = 0;
    const keys = { w: false, a: false, s: false, d: false, shift: false, space: false };
    const hint = document.getElementById("hint");
    const staminaFill = document.getElementById("staminaFill");
    const menuOverlay = document.getElementById("menuOverlay");
    const ammoLeft = document.getElementById("ammoLeft");
      const ammoRight = document.getElementById("ammoRight");
      const apPanel = document.getElementById("apPanel");
      const apFill = document.getElementById("apFill");
      const paPanel = document.getElementById("paPanel");
      const paFill = document.getElementById("paFill");
      const enFill = document.getElementById("enFill");
      const energyWarning = document.getElementById("energyWarning");
      const apWarning = document.getElementById("apWarning");
      const lockWarning = document.getElementById("lockWarning");
      const threatArrows = [];
      for (let i = 0; i < 12; i += 1) {
        const el = document.createElement("div");
        el.className = "threatArrow";
        document.body.appendChild(el);
        threatArrows.push(el);
      }
      const minimapCanvas = document.getElementById("minimapCanvas");
      let minimapCtx = minimapCanvas ? minimapCanvas.getContext("2d") : null;
      const septiaCountEl = document.getElementById("septiaCount");
      const septiaGaugeEl = document.getElementById("septiaGauge");
      const lockCircleLarge = document.getElementById("lockCircleLarge");
      const hitGreen = document.getElementById("hitGreen");
      const hitRed = document.getElementById("hitRed");
      const expansionCooldownEl = document.getElementById("expansionCooldown");
      const expansionOverlay = document.getElementById("expansionOverlay");
      const kitCountEl = document.getElementById("kitCount");
      const kitCooldownEl = document.getElementById("kitCooldown");
    const repairOverlay = document.getElementById("repairOverlay");
    const damageShield = document.getElementById("damageShield");
    const menuClose = document.getElementById("menuClose");
    const menuTabs = Array.from(document.querySelectorAll(".menuTab"));
    const menuSections = Array.from(document.querySelectorAll(".menuSection"));
    const assemblyItems = Array.from(document.querySelectorAll(".assemblyItem"));
    const assemblyDetail = document.getElementById("assemblyDetail");
    const assemblyDetailTitle = document.getElementById("assemblyDetailTitle");
    const assemblyDetailClose = document.getElementById("assemblyDetailClose");
    const assemblyDetailCurrent = document.getElementById("assemblyDetailCurrent");
    const assemblyDetailInventory = document.getElementById("assemblyDetailInventory");
    const assemblyDetailStatus = document.getElementById("assemblyDetailStatus");
    const assemblyUnequip = document.getElementById("assemblyUnequip");
    const codexGridWrap = document.getElementById("codexGridWrap");
    const itemGridWrap = document.getElementById("itemGridWrap");
    const shopGridWrap = document.getElementById("shopGridWrap");
    const codexDetailName = document.getElementById("codexDetailName");
    const itemDetailName = document.getElementById("itemDetailName");
    const shopDetailName = document.getElementById("shopDetailName");
    const codexDetailDesc = document.getElementById("codexDetailDesc");
    const itemDetailDesc = document.getElementById("itemDetailDesc");
    const shopDetailDesc = document.getElementById("shopDetailDesc");
    const codexGrid = document.getElementById("codexGrid");
    const itemGrid = document.getElementById("itemGrid");
    const shopGrid = document.getElementById("shopGrid");
    const previewCanvas = document.getElementById("assemblyPreviewCanvas");
      let stamina = 100;
      let en = 100;
      let enCooldown = false;
      let staminaCooldown = false;
      let staminaCooldownEnd = 0;
      let energyLock = false;
      let frameNow = 0;
    let cameraRoll = 0;
    let dashTiltPulse = 0;
    let paused = false;
    let previewRotX = 0;
    let previewRotY = 0;
    let armRaiseL = false;
    let armRaiseR = false;
    let firingLeft = false;
    let firingRight = false;
    let fireCooldown = 0;
      const magMax = 1000;
    let magLeft = magMax;
    let magRight = magMax;
    let reserveLeft = Infinity;
    let reserveRight = Infinity;
    let reloadingLeft = false;
    let reloadingRight = false;
      let reloadEndLeft = 0;
      let reloadEndRight = 0;
      const reloadTime = 0.1;
      const apMax = 99999;
      let ap = apMax;
      const paMax = 9999;
      let pa = paMax;
      let paCooldown = false;
      let paCooldownEnd = 0;
      let paInvulnUntil = 0;
      let expansionHolding = false;
      let expansionHoldStart = null;
      let expansionCooldownEnd = 0;
      let expansionActiveUntil = 0;
      let expansionNextHeal = 0;
      let expansionShockDone = false;
      let apCriticalUntil = 0;
      let septiaFiring = false;
      let septiaFireCooldown = 0;
      let lockTarget = null;
      let lockTargetUntil = 0;
      const lockTargets = [];
      let lockCircleOffset = 0;
      let hitGreenUntil = 0;
      let hitRedUntil = 0;
      let hitRedDamageUntil = 0;
      const lockCircles = [];
      for (let i = 0; i < 13; i += 1) {
        const el = document.createElement("div");
        el.className = "lockCircleSmall";
        el.style.display = "none";
        document.body.appendChild(el);
        lockCircles.push(el);
      }
    let kitCount = Infinity;
    let kitHoldStart = null;
    let kitHolding = false;
      let repairCooldownEnd = 0;
      let repairHealStart = 0;
      let repairHealEnd = 0;
      let repairHealAmount = 0;
      let repairHealApplied = 0;
      let repairOverlayUntil = 0;
      let repairActiveStart = 0;
      let repairActiveUntil = 0;
      let damageScale = 1;
    const bullets = [];
    const dashCooldownEnd = { w: 0, a: 0, s: 0, d: 0 };

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function clampCameraPosition(pos) {
      const roomsHere = getRoomsForPos(pos);
      const epsilon = 0.2;
      if (roomsHere.length === 0) return pos;

      let best = null;
      let bestDist = Infinity;
      for (const room of roomsHere) {
        const minX = room.x - half + (room.openings.w ? -playerHalf : playerHalf) + epsilon;
        const maxX = room.x + half + (room.openings.e ? playerHalf : -playerHalf) - epsilon;
        const minZ = room.z - half + (room.openings.n ? -playerHalf : playerHalf) + epsilon;
        const maxZ = room.z + half + (room.openings.s ? playerHalf : -playerHalf) - epsilon;
        const clamped = new THREE.Vector3(
          clamp(pos.x, minX, maxX),
          clamp(pos.y, floorY + epsilon, ceilingY - epsilon),
          clamp(pos.z, minZ, maxZ)
        );
        const dist = clamped.distanceToSquared(pos);
        if (dist < bestDist) {
          bestDist = dist;
          best = clamped;
        }
      }
      return best ?? pos;
    }

    function updateCamera() {
      if (paused) return;
      const eyeHeight = playerSize * 0.8;
      dummy.position.set(player.position.x, player.position.y - playerHalf, player.position.z);
      dummy.rotation.y = yaw;
      dummy.rotation.z = cameraRoll;
      dashTiltPulse += (0 - dashTiltPulse) * Math.min(1, 6 * (1 / 60));
      const tiltStrength = 0.12;
      const strafe = (keys.d ? 1 : 0) - (keys.a ? 1 : 0);
      const targetRoll = -tiltStrength * strafe;
      const rollSpeed = 3;
      cameraRoll += (targetRoll - cameraRoll) * Math.min(1, rollSpeed * (1 / 60));
      const roll = cameraRoll + dashTiltPulse;
      const armBase = 0;
      const armTargetL = armRaiseL ? (Math.PI / 4 + pitch) : armBase;
      const armTargetR = armRaiseR ? (Math.PI / 4 + pitch) : armBase;
      const armSpeed = 8;
      armL.rotation.x += (armTargetL - armL.rotation.x) * Math.min(1, armSpeed * (1 / 60));
      armR.rotation.x += (armTargetR - armR.rotation.x) * Math.min(1, armSpeed * (1 / 60));
      const forearmRest = Math.PI / 4;
      forearmL.rotation.x = reloadingLeft ? 0 : forearmRest;
      forearmR.rotation.x = reloadingRight ? 0 : forearmRest;

      if (keys.shift) {
        const distance = 0.3 * cellSize;
        const height = 0.12 * cellSize;
        camera.fov = 60;
        camera.updateProjectionMatrix();
        const back = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
        const desired = new THREE.Vector3(
          player.position.x,
          player.position.y + height,
          player.position.z
        ).addScaledVector(back, -distance);
        const clamped = clampCameraPosition(desired);
        camera.position.copy(clamped);
        camera.rotation.set(pitch, yaw, roll, "YXZ");
      } else {
        camera.fov = 75;
        camera.updateProjectionMatrix();
        const desired = new THREE.Vector3(
          player.position.x,
          player.position.y + (eyeHeight - playerHalf),
          player.position.z
        );
        const clamped = clampCameraPosition(desired);
        camera.position.copy(clamped);
        camera.rotation.set(pitch, yaw, roll, "YXZ");
      }
    }

    function isInsideAnyRoom(pos) {
      for (const room of rooms) {
        const minX = room.x - half + (room.openings.w ? -playerHalf : playerHalf);
        const maxX = room.x + half + (room.openings.e ? playerHalf : -playerHalf);
        const minZ = room.z - half + (room.openings.n ? -playerHalf : playerHalf);
        const maxZ = room.z + half + (room.openings.s ? playerHalf : -playerHalf);
        if (pos.x >= minX && pos.x <= maxX && pos.z >= minZ && pos.z <= maxZ) {
          return true;
        }
      }
      return false;
    }

    function getRoomsForPos(pos) {
      const result = [];
      for (const room of rooms) {
        const minX = room.x - half + (room.openings.w ? -playerHalf : playerHalf);
        const maxX = room.x + half + (room.openings.e ? playerHalf : -playerHalf);
        const minZ = room.z - half + (room.openings.n ? -playerHalf : playerHalf);
        const maxZ = room.z + half + (room.openings.s ? playerHalf : -playerHalf);
        if (pos.x >= minX && pos.x <= maxX && pos.z >= minZ && pos.z <= maxZ) {
          result.push(room);
        }
      }
      return result;
    }

    function collidesWithBlocks(pos) {
      const roomsHere = getRoomsForPos(pos);
      if (roomsHere.length === 0) return true;

      const epsilon = 0.0001;
      const minX = pos.x - playerHalf + epsilon;
      const maxX = pos.x + playerHalf - epsilon;
      const minZ = pos.z - playerHalf + epsilon;
      const maxZ = pos.z + playerHalf - epsilon;
      const minY = pos.y - playerHalf + epsilon;
      const maxY = pos.y + playerHalf - epsilon;

      for (const room of roomsHere) {
        for (const box of room.blockBoxes) {
          const overlapX = maxX >= box.minX && minX <= box.maxX;
          const overlapY = maxY >= box.minY && minY <= box.maxY;
          const overlapZ = maxZ >= box.minZ && minZ <= box.maxZ;
          if (overlapX && overlapY && overlapZ) {
            return true;
          }
        }
      }
      return false;
    }

    function resolveVertical(nextY) {
      if (nextY > ceilingY) {
        player.position.y = ceilingY;
        player.velocity.y = 0;
        return;
      }
      if (nextY < floorY) {
        player.position.y = floorY;
        player.velocity.y = 0;
        player.grounded = true;
        return;
      }

      const testPos = new THREE.Vector3(player.position.x, nextY, player.position.z);
      if (!collidesWithBlocks(testPos)) {
        player.position.y = nextY;
        return;
      }

      if (player.velocity.y <= 0) {
        const roomsHere = getRoomsForPos(player.position);
        let highestTop = floorY;
        for (const room of roomsHere) {
          for (const box of room.blockBoxes) {
            const overlapX = (player.position.x + playerHalf) >= box.minX &&
              (player.position.x - playerHalf) <= box.maxX;
            const overlapZ = (player.position.z + playerHalf) >= box.minZ &&
              (player.position.z - playerHalf) <= box.maxZ;
            if (!overlapX || !overlapZ) continue;
            const topY = box.maxY + playerHalf;
            if (topY > highestTop) highestTop = topY;
          }
        }
        player.position.y = highestTop;
        player.velocity.y = 0;
        player.grounded = true;
      } else {
        player.velocity.y = 0;
      }
    }

      function applyMovement(delta) {
        if (paused) return;
        const now = frameNow || performance.now() / 1000;
        const forward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
        const forwardFly = new THREE.Vector3(
          -Math.sin(yaw) * Math.cos(pitch),
          Math.sin(pitch),
          -Math.cos(yaw) * Math.cos(pitch)
        ).normalize();
      const right = new THREE.Vector3(Math.sin(yaw + Math.PI / 2), 0, Math.cos(yaw + Math.PI / 2));
      const direction = new THREE.Vector3();
        const dashingInput = keys.shift && keys.space;
        const expansionActive = now < expansionActiveUntil;
        const energyAvailable = expansionActive ? true : (staminaCooldown ? en > 0 : stamina > 0);
        const flyingInput = keys.shift && keys.w && !dashingInput && energyAvailable;

      if (keys.w) direction.add(forward);
      if (keys.s) direction.sub(forward);
      if (keys.d) direction.add(right);
      if (keys.a) direction.sub(right);

        if (direction.lengthSq() > 0) {
          const sprinting = keys.shift && energyAvailable && !energyLock;
          const expansionBoost = expansionActive ? 2 : 1;
          const criticalSlow = now < apCriticalUntil ? 0.5 : 1;
          const speed = moveSpeed * (sprinting ? 1.5 : 1) * expansionBoost * (energyLock ? 0.5 : 1) * criticalSlow;
          direction.normalize().multiplyScalar(speed);
          player.velocity.x = direction.x;
          player.velocity.z = direction.z;
        } else {
          player.velocity.x = 0;
          player.velocity.z = 0;
        }

        if (flyingInput) {
          const flySpeed = flyAccel;
          const strafe = (keys.d ? 1 : 0) - (keys.a ? 1 : 0);
          const strafeVec = right.clone().multiplyScalar(strafe * flySpeed * 0.6);
          const flyVec = forwardFly.clone().multiplyScalar(flySpeed).add(strafeVec);
          player.velocity.set(flyVec.x, flyVec.y, flyVec.z);
          player.grounded = false;
        }

      const jumpCost = 4;
      const jumpSpeed = baseJumpSpeed;

        if (!flyingInput && !energyLock && keys.space && !dashingInput && energyAvailable && player.position.y < ceilingY) {
          const cost = jumpCost * delta * 10;
          consumeEnergy(cost, now);
          if (!staminaCooldown || en > 0) {
            player.velocity.y = Math.max(player.velocity.y, jumpSpeed);
          }
        } else if (!flyingInput) {
          player.velocity.y -= gravity * delta;
        }

        if (keys.shift && !player.grounded && !keys.w) {
          if (energyAvailable) {
            player.velocity.y = Math.max(0, player.velocity.y);
          }
        }

      const next = player.position.clone().addScaledVector(player.velocity, delta);

      const tryX = new THREE.Vector3(next.x, player.position.y, player.position.z);
      if (isInsideAnyRoom(tryX) && !collidesWithBlocks(tryX)) {
        player.position.x = tryX.x;
      }

      const tryZ = new THREE.Vector3(player.position.x, player.position.y, next.z);
      if (isInsideAnyRoom(tryZ) && !collidesWithBlocks(tryZ)) {
        player.position.z = tryZ.z;
      }

      resolveVertical(next.y);

      player.position.x = clamp(player.position.x, -worldHalf + playerHalf, worldHalf - playerHalf);
      player.position.z = clamp(player.position.z, -worldHalf + playerHalf, worldHalf - playerHalf);

      if (player.position.y <= floorY) {
        player.position.y = floorY;
        player.velocity.y = 0;
        player.grounded = true;
      } else if (player.position.y >= ceilingY) {
        player.position.y = ceilingY;
        player.velocity.y = Math.min(0, player.velocity.y);
      }
    }

      function startJump() {
        if (!player.grounded) return;
        const energyAvailable = frameNow < expansionActiveUntil ? true : (staminaCooldown ? en > 0 : stamina > 0);
        if (!energyAvailable || energyLock) return;
        player.velocity.y = 0;
        player.grounded = false;
      }

      function consumeEnergy(amount, now) {
        if (amount <= 0) return;
        if (now < expansionActiveUntil) return;
        if (staminaCooldown) {
          en = Math.max(0, en - amount);
          if (en <= 0) {
            en = 0;
            enCooldown = true;
          }
          return;
        }
        stamina = Math.max(0, stamina - amount);
        if (stamina <= 0) {
          stamina = 0;
          staminaCooldown = true;
          staminaCooldownEnd = now + 10;
        }
      }

      function applyDamage(amount) {
        if (amount <= 0) return;
        const now = performance.now() / 1000;
        hitRedUntil = now + 0.3;
        let dmg = amount * damageScale;
        if (dmg <= 0) {
          hitRedDamageUntil = 0;
          return;
        }
        if (now < expansionActiveUntil) {
          hitRedDamageUntil = 0;
          return;
        }
        if (now < paInvulnUntil) {
          hitRedDamageUntil = 0;
          return;
        }
        let tookDamage = false;
        if (!paCooldown && pa > 0) {
          const used = Math.min(pa, dmg);
          pa -= used;
          dmg -= used;
          if (used > 0) tookDamage = true;
          if (pa <= 0) {
            pa = 0;
            paCooldown = true;
            paCooldownEnd = now + 50;
          }
        }
        if (dmg > 0) {
          ap = Math.max(1, ap - dmg);
          tookDamage = true;
          hitRedDamageUntil = now + 0.3;
        } else {
          hitRedDamageUntil = tookDamage ? now + 0.3 : 0;
        }
        if (ap <= 1) {
          ap = 1;
          player.position.set(0, floorY, 0);
          player.velocity.set(0, 0, 0);
          apCriticalUntil = now + 10;
        }
      }

      function applyEnemyDamage(enemy, amount) {
        let dmg = amount;
        if (enemy.pa > 0) {
          const usePa = Math.min(enemy.pa, dmg);
          enemy.pa -= usePa;
          dmg -= usePa;
          if (usePa > 0) spawnFloatingText(enemy.mesh.position, `-PA ${Math.ceil(usePa)}`, "#7ad7ff");
        }
        if (dmg > 0) {
          enemy.ap = Math.max(0, enemy.ap - dmg);
          spawnFloatingText(enemy.mesh.position, `-AP ${Math.ceil(dmg)}`, "#ff8a8a");
        }
        if (amount > 0) {
          hitGreenUntil = performance.now() / 1000 + 0.3;
        }
        if (enemy.ap <= 0) {
          scene.remove(enemy.mesh);
          if (enemy.label) enemy.label.remove();
          const idx = enemies.indexOf(enemy);
          if (idx >= 0) enemies.splice(idx, 1);
        }
      }

      function applyDestructibleDamage(block, amount) {
        let dmg = amount;
        if (block.pa > 0) {
          const usePa = Math.min(block.pa, dmg);
          block.pa -= usePa;
          dmg -= usePa;
        }
        if (dmg > 0) {
          block.ap = Math.max(0, block.ap - dmg);
        }
        if (amount > 0) {
          hitGreenUntil = performance.now() / 1000 + 0.3;
        }
        if (block.ap <= 0) {
          scene.remove(block.mesh);
          const room = rooms[block.roomIndex];
          if (room && room.destructibles) {
            const idx = room.destructibles.indexOf(block);
            if (idx >= 0) room.destructibles.splice(idx, 1);
            const boxIdx = room.blockBoxes.indexOf(block.box);
            if (boxIdx >= 0) room.blockBoxes.splice(boxIdx, 1);
            if (room.destructibleOccupied && block.slotIndex !== undefined) {
              room.destructibleOccupied.delete(block.slotIndex);
            }
          }
          const allIdx = destructibleBlocks.indexOf(block);
          if (allIdx >= 0) destructibleBlocks.splice(allIdx, 1);
        }
      }

      function createExplosionField(center, radius, dps, color) {
        const fxGeo = new THREE.SphereGeometry(0.6, 16, 16);
        const fxMat = new THREE.MeshStandardMaterial({ color, transparent: true, opacity: 0.9 });
        const fx = new THREE.Mesh(fxGeo, fxMat);
        fx.position.copy(center);
        fx.userData.life = 3;
        fx.userData.startLife = 3;
        fx.userData.radius = radius;
        fx.userData.dps = dps;
        explosionFields.push(fx);
        scene.add(fx);
      }

      function spawnFloatingText(pos, text, color) {
        const el = document.createElement("div");
        el.className = "floatText";
        el.style.color = color;
        el.textContent = text;
        document.body.appendChild(el);
        floatingTexts.push({
          el,
          pos: pos.clone(),
          life: 0.8,
          startLife: 0.8,
          velocity: new THREE.Vector3(0, 0.8, 0)
        });
      }


      function findSeptiaTarget(pos, range) {
        for (const target of lockTargets) {
          if (target.enemy && target.enemy.mesh.position.distanceTo(pos) <= range) {
            return target.enemy;
          }
        }
        let best = null;
        let bestDist = range * range;
        let bestAp = Infinity;
        let bestSpawn = Infinity;
        for (const enemy of enemies) {
          const d2 = enemy.mesh.position.distanceToSquared(pos);
          if (d2 > bestDist) continue;
          const ap = enemy.ap;
          const spawn = enemy.spawnTime || 0;
          if (!best || ap < bestAp || (ap === bestAp && spawn < bestSpawn)) {
            best = enemy;
            bestAp = ap;
            bestSpawn = spawn;
            bestDist = d2;
          }
        }
        return best;
      }

    function setActiveTab(name) {
      menuTabs.forEach((tab) => {
        const active = tab.dataset.tab === name;
        tab.classList.toggle("active", active);
        tab.setAttribute("aria-selected", active ? "true" : "false");
      });
      menuSections.forEach((section) => {
        section.classList.toggle("active", section.id === `tab-${name}`);
      });
        if (name === "assembly") {
          previewRotX = 0;
          previewRotY = Math.PI;
        }
    }

    function toggleMenu() {
      paused = !paused;
      menuOverlay.classList.toggle("active", paused);
      menuOverlay.setAttribute("aria-hidden", paused ? "false" : "true");
      if (paused) {
        setActiveTab("controls");
      }
      if (paused) {
        if (document.pointerLockElement === document.body) {
          document.exitPointerLock();
        }
      }
    }

      document.addEventListener("keydown", (event) => {
        if (event.code === "KeyE") {
          toggleMenu();
          return;
        }
        if (event.code === "KeyQ") {
          if (!expansionHolding) {
            expansionHolding = true;
            expansionHoldStart = performance.now();
          }
        }
        if (event.code === "Digit2") {
          septiaFiring = true;
        }
        if (event.code === "Digit1") {
          if (!kitHolding) {
            kitHolding = true;
            kitHoldStart = performance.now();
          }
      }
      if (event.code === "KeyW") keys.w = true;
      if (event.code === "KeyA") keys.a = true;
      if (event.code === "KeyS") keys.s = true;
      if (event.code === "KeyD") keys.d = true;
      if (event.code === "ShiftLeft" || event.code === "ShiftRight") keys.shift = true;
        if (event.code === "Space") {
          keys.space = true;
          if (!energyLock) startJump();
          const dashKeyMap = { KeyW: "w", KeyA: "a", KeyS: "s", KeyD: "d" };
          if (keys.shift && keys.w) {
            const dashKey = "w";
            if (
              ((staminaCooldown && en >= 8) || (!staminaCooldown && stamina >= 8)) &&
              performance.now() / 1000 >= dashCooldownEnd[dashKey]
            ) {
              const dashForward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
              const dashDir = dashForward.clone().normalize();
              const step = dashDir.clone().multiplyScalar(dashDistance);
              const dashTryX = new THREE.Vector3(player.position.x + step.x, player.position.y, player.position.z);
              if (isInsideAnyRoom(dashTryX) && !collidesWithBlocks(dashTryX)) {
                player.position.x = dashTryX.x;
              }
              const dashTryZ = new THREE.Vector3(player.position.x, player.position.y, player.position.z + step.z);
              if (isInsideAnyRoom(dashTryZ) && !collidesWithBlocks(dashTryZ)) {
                player.position.z = dashTryZ.z;
              }
              stamina = Math.max(0, stamina - 8);
              if (stamina <= 0) {
                stamina = 0;
                staminaCooldown = true;
                staminaCooldownEnd = performance.now() / 1000 + 10;
              }
              dashCooldownEnd[dashKey] = performance.now() / 1000 + dashCooldown;
            }
          }
        }
        const dashKeyMap = { KeyW: "w", KeyA: "a", KeyS: "s", KeyD: "d" };
        const dashKey = dashKeyMap[event.code];
      if (
        dashKey &&
        keys.shift && keys.space &&
        ((staminaCooldown && en >= 8) || (!staminaCooldown && stamina >= 8)) &&
        !energyLock &&
        performance.now() / 1000 >= dashCooldownEnd[dashKey]
      ) {
        const dashForward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
        const dashRight = new THREE.Vector3(Math.sin(yaw + Math.PI / 2), 0, Math.cos(yaw + Math.PI / 2));
        let dashDir = new THREE.Vector3();
        if (dashKey === "w") dashDir = dashForward;
        if (dashKey === "s") dashDir = dashForward.clone().multiplyScalar(-1);
        if (dashKey === "d") dashDir = dashRight;
        if (dashKey === "a") dashDir = dashRight.clone().multiplyScalar(-1);
        if (dashDir.lengthSq() > 0) {
          dashDir.normalize();
          const expansionBoost = performance.now() / 1000 < expansionActiveUntil ? 3 : 1;
          const step = dashDir.clone().multiplyScalar(dashDistance * expansionBoost);
          const dashTryX = new THREE.Vector3(player.position.x + step.x, player.position.y, player.position.z);
          if (isInsideAnyRoom(dashTryX) && !collidesWithBlocks(dashTryX)) {
            player.position.x = dashTryX.x;
          }
          const dashTryZ = new THREE.Vector3(player.position.x, player.position.y, player.position.z + step.z);
          if (isInsideAnyRoom(dashTryZ) && !collidesWithBlocks(dashTryZ)) {
            player.position.z = dashTryZ.z;
          }
          if (dashKey === "a") dashTiltPulse = 0.2;
          if (dashKey === "d") dashTiltPulse = -0.2;
          consumeEnergy(8, performance.now() / 1000);
          dashCooldownEnd[dashKey] = performance.now() / 1000 + dashCooldown;
        }
      }
    });

      document.addEventListener("keyup", (event) => {
        if (event.code === "KeyE") return;
        if (event.code === "KeyQ") {
          expansionHolding = false;
          expansionHoldStart = null;
        }
        if (event.code === "Digit2") {
          septiaFiring = false;
        }
        if (event.code === "Digit1") {
          kitHolding = false;
          kitHoldStart = null;
        }
      if (event.code === "KeyW") keys.w = false;
      if (event.code === "KeyA") keys.a = false;
      if (event.code === "KeyS") keys.s = false;
      if (event.code === "KeyD") keys.d = false;
      if (event.code === "ShiftLeft" || event.code === "ShiftRight") keys.shift = false;
      if (event.code === "Space") keys.space = false;
    });

    document.addEventListener("mousedown", (event) => {
      if (event.button === 0) armRaiseL = true;
      if (event.button === 2) armRaiseR = true;
    });

    document.addEventListener("mouseup", (event) => {
      if (event.button === 0) armRaiseL = false;
      if (event.button === 2) armRaiseR = false;
    });

    document.addEventListener("contextmenu", (event) => {
      event.preventDefault();
    });

    document.addEventListener("mousedown", (event) => {
      if (event.button === 0) firingLeft = true;
      if (event.button === 2) firingRight = true;
    });
    document.addEventListener("mouseup", (event) => {
      if (event.button === 0) firingLeft = false;
      if (event.button === 2) firingRight = false;
    });

    function onMouseMove(event) {
      const sensitivity = 0.002;
      yaw -= event.movementX * sensitivity;
      pitch -= event.movementY * sensitivity;
      pitch = clamp(pitch, -Math.PI / 2 + 0.05, Math.PI / 2 - 0.05);
    }

      document.body.addEventListener("click", () => {
        if (paused) return;
        if (document.pointerLockElement !== document.body) {
          document.body.requestPointerLock();
        }
      });
      renderer.domElement.addEventListener("click", () => {
        if (paused) return;
        if (document.pointerLockElement !== document.body) {
          document.body.requestPointerLock();
        }
      });
      window.addEventListener("mousedown", () => {
        if (paused) return;
        if (document.pointerLockElement !== document.body) {
          document.body.requestPointerLock();
        }
      });

    menuClose.addEventListener("click", () => {
      if (paused) toggleMenu();
    });

    menuTabs.forEach((tab) => {
      tab.addEventListener("click", () => {
        setActiveTab(tab.dataset.tab);
      });
    });

    const equipped = {};
    const statusCatalog = {
      "테스트용 머신핸드건": [
        ["무기 타입", "머신핸드건"],
        ["장탄수", "1000"],
        ["재장전 시간", "0.1초"],
        ["발사 방식", "13발 펠릿"],
        ["피해량", "펠릿 1000 + 폭발 500"],
        ["운용 메모", "좌/우 손 슬롯 장착 가능"]
      ]
    };

    assemblyItems.forEach((item) => {
      const labelEl = item.querySelector(".assemblyLabel");
      const slotName = item.dataset.slot || labelEl.textContent.trim();
      item.dataset.slot = slotName;
      item.dataset.defaultName = slotName;
      const currentName = labelEl.textContent.trim();
      if (currentName !== slotName) {
        equipped[slotName] = currentName;
      }
    });

    function isHandSlot(slotName) {
      return slotName.includes("우측 손") || slotName.includes("좌측 손");
    }

    function getStatusRows(slotName, equippedName) {
      if (equippedName && statusCatalog[equippedName]) {
        return statusCatalog[equippedName];
      }
      if (isHandSlot(slotName)) {
        return [
          ["무기 타입", "비어 있음"],
          ["장비 상태", "무장 해제"],
          ["안내", "소지한 파츠에서 장착 가능"]
        ];
      }
      return [
        ["슬롯", slotName],
        ["장비 상태", equippedName || "장착 없음"],
        ["안내", "해당 슬롯 데이터는 추후 확장 예정"]
      ];
    }

    function renderAssemblyStatus(slotName, equippedName) {
      if (!assemblyDetailStatus) return;
      assemblyDetailStatus.innerHTML = "";
      const rows = getStatusRows(slotName, equippedName);
      const wrap = document.createElement("div");
      wrap.className = "statusRows";
      rows.forEach(([keyName, valueText]) => {
        const row = document.createElement("div");
        row.className = "statusRow";
        const keyEl = document.createElement("div");
        keyEl.className = "key";
        keyEl.textContent = keyName;
        const valueEl = document.createElement("div");
        valueEl.className = "value";
        valueEl.textContent = valueText;
        row.appendChild(keyEl);
        row.appendChild(valueEl);
        wrap.appendChild(row);
      });
      assemblyDetailStatus.appendChild(wrap);
    }

    function renderAssemblyDetail(slotName) {
      assemblyDetailTitle.textContent = slotName;
      assemblyDetail.classList.add("active");
      assemblyDetailCurrent.innerHTML = "";
      assemblyDetailInventory.innerHTML = "";

      const current = document.createElement("div");
      current.className = "detailIcon";
      current.title = "현재 착용";
      assemblyDetailCurrent.appendChild(current);

      const equippedName = equipped[slotName];
      current.innerHTML = `<div class="assemblyLabel">${equippedName || "장착 없음"}</div>`;
      if (!equippedName) {
        current.style.opacity = "0.2";
      }

      if (isHandSlot(slotName)) {
        const inventory = document.createElement("div");
        inventory.className = "detailIcon";
        inventory.title = "테스트용 머신핸드건";
        inventory.innerHTML = "<div class=\"assemblyLabel\">테스트용 머신핸드건</div>";
        assemblyDetailInventory.appendChild(inventory);
        inventory.addEventListener("click", () => {
          equipped[slotName] = "테스트용 머신핸드건";
          current.style.opacity = "1";
          current.innerHTML = "<div class=\"assemblyLabel\">테스트용 머신핸드건</div>";
          const slotItem = assemblyItems.find((i) => i.dataset.slot === slotName);
          if (slotItem) {
            const icon = slotItem.querySelector(".assemblyIcon");
            const label = slotItem.querySelector(".assemblyLabel");
            icon.classList.add("machinehandgun");
            label.textContent = "테스트용 머신핸드건";
          }
          renderAssemblyStatus(slotName, equipped[slotName]);
        });
      } else {
        const empty = document.createElement("div");
        empty.className = "detailIcon";
        empty.style.opacity = "0.5";
        empty.innerHTML = "<div class=\"assemblyLabel\">호환 파츠 없음</div>";
        assemblyDetailInventory.appendChild(empty);
      }
      renderAssemblyStatus(slotName, equippedName);
      assemblyUnequip.disabled = !equippedName;
    }

    assemblyItems.forEach((item) => {
      item.addEventListener("click", () => {
        const slotName = item.dataset.slot || item.dataset.assembly || "파츠";
        renderAssemblyDetail(slotName);
      });
    });

    assemblyDetailClose.addEventListener("click", () => {
      assemblyDetail.classList.remove("active");
    });

    assemblyUnequip.addEventListener("click", () => {
      const name = assemblyDetailTitle.textContent || "";
      equipped[name] = null;
      const slotItem = assemblyItems.find((i) => i.dataset.slot === name);
      if (slotItem) {
        const icon = slotItem.querySelector(".assemblyIcon");
        const label = slotItem.querySelector(".assemblyLabel");
        icon.classList.remove("machinehandgun");
        label.textContent = slotItem.dataset.defaultName || name;
      }
      renderAssemblyDetail(name);
    });

    const previewScene = new THREE.Scene();
    previewScene.background = new THREE.Color(0x0f0f12);
    const previewCamera = new THREE.PerspectiveCamera(40, 1, 0.1, 100);
    previewCamera.position.set(0, 0.6, 5.6);
    const previewRenderer = new THREE.WebGLRenderer({ canvas: previewCanvas, antialias: true, alpha: true });
    previewRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const previewLight = new THREE.DirectionalLight(0xffffff, 0.9);
    previewLight.position.set(2, 4, 3);
    previewScene.add(new THREE.AmbientLight(0xffffff, 0.4), previewLight);

      const previewPivot = new THREE.Group();
      const previewDummy = dummy.clone(true);
      previewDummy.traverse((node) => {
        if (node.material) node.material = node.material.clone();
      });
      previewDummy.position.set(0, -1.1, 0);
      previewPivot.add(previewDummy);
      previewScene.add(previewPivot);
      const expansionSphere = new THREE.Mesh(
        new THREE.SphereGeometry(playerSize * 0.7, 24, 24),
        new THREE.MeshStandardMaterial({ color: 0xff3b3b, transparent: true, opacity: 0.2 })
      );
      expansionSphere.visible = false;
      scene.add(expansionSphere);
      const expansionParticles = [];
      let expansionParticleTimer = 0;
      const expansionParticleGeo = new THREE.BoxGeometry(0.04, 0.04, 0.04);
      const expansionParticleMat = new THREE.MeshStandardMaterial({
        color: 0xff4a4a,
        transparent: true,
        opacity: 0.8
      });

      const septiaGroup = new THREE.Group();
      scene.add(septiaGroup);
      const septiaDiamonds = [];
      const septiaBaseTotal = 72;
      const septiaTotal = 144;
      for (let i = 0; i < septiaTotal; i += 1) {
        const hue = (i % septiaBaseTotal) / septiaBaseTotal;
        const color = new THREE.Color().setHSL(hue, 0.75, 0.6);
        const mat = new THREE.MeshStandardMaterial({
          color,
          emissive: color,
          emissiveIntensity: 0.6,
          roughness: 0.35,
          metalness: 0.2
        });
        const d = new THREE.Mesh(new THREE.OctahedronGeometry(0.06), mat);
        d.userData.state = "idle";
        d.userData.timer = 0;
        d.userData.hitCount = 0;
        d.userData.nextHit = 1;
        d.userData.target = null;
        d.userData.extra = i >= septiaBaseTotal;
        septiaGroup.add(d);
        septiaDiamonds.push(d);
      }
    function resizePreview() {
      const rect = previewCanvas.getBoundingClientRect();
      const size = Math.max(200, Math.floor(Math.min(rect.width, rect.height)));
      previewRenderer.setSize(size, size, false);
      previewCamera.aspect = 1;
      previewCamera.updateProjectionMatrix();
    }
    resizePreview();

    let previewDragging = false;
    let previewLastX = 0;
    let previewLastY = 0;
    previewCanvas.addEventListener("mousedown", (e) => {
      previewDragging = true;
      previewCanvas.classList.add("dragging");
      previewLastX = e.clientX;
      previewLastY = e.clientY;
    });
    window.addEventListener("mouseup", () => {
      previewDragging = false;
      previewCanvas.classList.remove("dragging");
    });
    previewCanvas.addEventListener("mousemove", (e) => {
      if (!previewDragging) return;
      const dx = e.clientX - previewLastX;
      const dy = e.clientY - previewLastY;
      previewLastX = e.clientX;
      previewLastY = e.clientY;
      previewRotY += dx * 0.01;
      previewRotX += dy * 0.01;
      previewRotX = clamp(previewRotX, -0.8, 0.8);
    });

    function populateGrid(container, prefix) {
      const total = 50;
      for (let i = 1; i <= total; i += 1) {
        const item = document.createElement("div");
        item.className = "gridItem";
        item.dataset.name = `${prefix} ${i}`;
        item.innerHTML = `
          <div class="gridIcon"></div>
          <div class="gridLabel">${prefix} ${i}</div>
        `;
        container.appendChild(item);
      }
    }

    populateGrid(codexGridWrap, "도감");
    populateGrid(itemGridWrap, "아이템");
    populateGrid(shopGridWrap, "상점");

    function bindGrid(gridEl, nameEl, descEl) {
      gridEl.addEventListener("click", (event) => {
        const target = event.target.closest(".gridItem");
        if (!target) return;
        const name = target.dataset.name || "항목";
        nameEl.textContent = name;
        descEl.textContent = `${name}의 설명이 이 영역에 표시됩니다.`;
      });
    }

    bindGrid(codexGrid, codexDetailName, codexDetailDesc);
    bindGrid(itemGrid, itemDetailName, itemDetailDesc);
    bindGrid(shopGrid, shopDetailName, shopDetailDesc);

    function enableDragScroll(container) {
      let isDown = false;
      let startY = 0;
      let scrollTop = 0;

      container.addEventListener("mousedown", (e) => {
        isDown = true;
        container.classList.add("dragging");
        startY = e.pageY - container.offsetTop;
        scrollTop = container.scrollTop;
      });
      window.addEventListener("mouseup", () => {
        isDown = false;
        container.classList.remove("dragging");
      });
      container.addEventListener("mouseleave", () => {
        isDown = false;
        container.classList.remove("dragging");
      });
      container.addEventListener("mousemove", (e) => {
        if (!isDown) return;
        e.preventDefault();
        const y = e.pageY - container.offsetTop;
        const walk = (y - startY) * 1.2;
        container.scrollTop = scrollTop - walk;
      });
    }

    enableDragScroll(codexGrid);
    enableDragScroll(itemGrid);
    enableDragScroll(shopGrid);

    document.addEventListener("pointerlockchange", () => {
      if (document.pointerLockElement === document.body) {
        if (hint) hint.style.display = "none";
        document.addEventListener("mousemove", onMouseMove);
      } else {
        if (hint) hint.style.display = "none";
        document.removeEventListener("mousemove", onMouseMove);
      }
    });

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      resizePreview();
    });

      function updateStamina(delta) {
        if (paused) return;
        let enConsuming = false;
        const movingInput = keys.w || keys.a || keys.s || keys.d;
        const sprintingInput = keys.shift && movingInput;
        const dashingInput = keys.shift && keys.space;
        const flyingInput = keys.shift && keys.w && !dashingInput;
        const now = performance.now() / 1000;

        const hoverInput = keys.shift && !player.grounded && !flyingInput;
        if (staminaCooldown) {
          // Stamina keeps recharging; actions consume EN instead.
          let cost = 0;
          if (sprintingInput) cost += 8 * delta;
          if (hoverInput) cost += 0.4 * delta;
          if (flyingInput) cost += 10 * delta;
          if (cost > 0 && en > 0) {
            enConsuming = true;
            consumeEnergy(cost, now);
          }
          stamina = Math.min(100, stamina + 40 * delta);
          if (stamina >= 100) {
            staminaCooldown = false;
          }
        } else {
          if (flyingInput) {
            consumeEnergy(10 * delta, now);
          } else if (hoverInput) {
            consumeEnergy(0.4 * delta, now);
          } else if (sprintingInput && stamina > 0) {
            consumeEnergy(8 * delta, now);
          } else {
            stamina = Math.min(100, stamina + 25.6 * delta);
          }
        }

        staminaFill.style.width = `${stamina.toFixed(1)}%`;
        staminaFill.style.background = staminaCooldown ? "#ff4b4b" : "#ffd93d";
        if (enFill) {
          if (!enConsuming) {
            en = Math.min(100, en + 25.6 * delta);
            if (en >= 100) {
              enCooldown = false;
            }
          }
          enFill.style.width = `${en.toFixed(1)}%`;
          enFill.style.background = enCooldown ? "#ff4b4b" : "#4aa3ff";
        }
        if (!energyLock && staminaCooldown && enCooldown) {
          energyLock = true;
        }
        if (energyLock && (stamina >= 100 || en >= 100)) {
          energyLock = false;
        }
        if (frameNow < expansionActiveUntil) {
          energyLock = false;
        }
        if (energyWarning) {
          energyWarning.style.display = energyLock ? "block" : "none";
        }
        if (apWarning) {
          apWarning.style.display = frameNow < apCriticalUntil ? "block" : "none";
        }
      }

      const clock = new THREE.Clock();
      function animate() {
        const delta = Math.min(clock.getDelta(), 0.033);
        const now = performance.now() / 1000;
        frameNow = now;
        const playerRoomIndex = getRoomIndexForPos(player.position);
        applyMovement(delta);
        updateStamina(delta);
        updateCamera();

      if (minimapCtx) {
          const size = Math.min(minimapCanvas.clientWidth || 320, minimapCanvas.clientHeight || 320);
          if (minimapCanvas.width !== size) minimapCanvas.width = size;
          if (minimapCanvas.height !== size) minimapCanvas.height = size;
          const ctx = minimapCtx;
          ctx.clearRect(0, 0, size, size);
          ctx.save();
          ctx.beginPath();
          ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
          ctx.clip();
          ctx.fillStyle = "rgba(6,6,10,0.8)";
          ctx.fillRect(0, 0, size, size);
          const radiusUnits = 5 * cellSize;
          const scale = size / (radiusUnits * 2);
          const centerX = size / 2;
          const centerY = size / 2;
          ctx.save();
          ctx.translate(centerX, centerY);
          ctx.rotate(yaw);
          ctx.translate(-centerX, -centerY);
          // room tiles
          for (let i = 0; i < rooms.length; i += 1) {
            const room = rooms[i];
            const dx = room.x - player.position.x;
            const dz = room.z - player.position.z;
            const rx = centerX + dx * scale - (roomSize * scale) / 2;
            const rz = centerY + dz * scale - (roomSize * scale) / 2;
            ctx.fillStyle = `#${roomColors[i].toString(16).padStart(6, "0")}`;
            ctx.globalAlpha = 0.25;
            ctx.fillRect(rx, rz, roomSize * scale, roomSize * scale);
            ctx.globalAlpha = 0.6;
            ctx.strokeStyle = "rgba(255,255,255,0.25)";
            ctx.strokeRect(rx, rz, roomSize * scale, roomSize * scale);
          }
          // enemies on minimap
          const mmRange = radiusUnits;
          const visibleDots = [];
          ctx.globalAlpha = 1;
          for (const enemy of enemies) {
            const dx = enemy.mesh.position.x - player.position.x;
            const dz = enemy.mesh.position.z - player.position.z;
            const dist = Math.hypot(dx, dz);
            const angle = Math.atan2(dx, dz);
            const rotX = Math.sin(angle) * dist;
            const rotZ = Math.cos(angle) * dist;
            if (dist <= mmRange) {
              const ex = centerX + rotX * scale;
              const ez = centerY + rotZ * scale;
              ctx.fillStyle = "rgba(255,60,60,0.9)";
              ctx.beginPath();
              ctx.arc(ex, ez, 2.5, 0, Math.PI * 2);
              ctx.fill();
              visibleDots.push({ enemy, x: ex, y: ez });
            } else {
              const ex = centerX + (rotX / dist) * mmRange * scale;
              const ez = centerY + (rotZ / dist) * mmRange * scale;
              ctx.fillStyle = "rgba(255,60,60,0.7)";
              ctx.beginPath();
              ctx.arc(ex, ez, 3, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          // lock-on attackers direction on minimap edge
          for (const enemy of enemies) {
            const dx = enemy.mesh.position.x - player.position.x;
            const dz = enemy.mesh.position.z - player.position.z;
            const dist = Math.hypot(dx, dz);
            const targeting = playerRoomIndex === enemy.roomIndex && dist <= 7.5;
            if (!targeting) continue;
            const angle = Math.atan2(dx, dz);
            const ex = centerX + Math.sin(angle) * mmRange * scale;
            const ez = centerY + Math.cos(angle) * mmRange * scale;
            ctx.fillStyle = "rgba(255,120,120,0.9)";
            ctx.beginPath();
            ctx.moveTo(ex, ez);
            ctx.lineTo(ex + Math.sin(angle + Math.PI / 2) * 4, ez + Math.cos(angle + Math.PI / 2) * 4);
            ctx.lineTo(ex + Math.sin(angle - Math.PI / 2) * 4, ez + Math.cos(angle - Math.PI / 2) * 4);
            ctx.closePath();
            ctx.fill();
          }
          // lock-on ring on minimap
          for (const dot of visibleDots) {
            if (lockTargets.length > 0 && lockTargets.some((t) => t.target === dot.enemy)) {
              ctx.strokeStyle = "rgba(255,60,60,0.9)";
              ctx.lineWidth = 1.5;
              ctx.beginPath();
              ctx.arc(dot.x, dot.y, 5.5, 0, Math.PI * 2);
              ctx.stroke();
            }
          }
          // grid lines
          ctx.globalAlpha = 0.25;
          ctx.strokeStyle = "rgba(255,255,255,0.2)";
          ctx.lineWidth = 1;
          for (let gx = -radiusUnits; gx <= radiusUnits; gx += cellSize) {
            const x = centerX + gx * scale;
            ctx.beginPath();
            ctx.moveTo(x, centerY - radiusUnits * scale);
            ctx.lineTo(x, centerY + radiusUnits * scale);
            ctx.stroke();
          }
          for (let gz = -radiusUnits; gz <= radiusUnits; gz += cellSize) {
            const y = centerY + gz * scale;
            ctx.beginPath();
            ctx.moveTo(centerX - radiusUnits * scale, y);
            ctx.lineTo(centerX + radiusUnits * scale, y);
            ctx.stroke();
          }
          // radius ring
          ctx.globalAlpha = 1;
          ctx.strokeStyle = "rgba(255,255,255,0.2)";
          ctx.beginPath();
          ctx.arc(centerX, centerY, radiusUnits * scale, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
          // view cone (funnel) fixed upward
          ctx.globalAlpha = 0.25;
          ctx.fillStyle = "rgba(255,255,255,0.2)";
          const coneLen = radiusUnits * 1.0 * scale;
          const coneHalf = Math.PI / 4;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(centerX + Math.cos(-Math.PI / 2 - coneHalf) * coneLen, centerY + Math.sin(-Math.PI / 2 - coneHalf) * coneLen);
          ctx.arc(centerX, centerY, coneLen, -Math.PI / 2 - coneHalf, -Math.PI / 2 + coneHalf);
          ctx.closePath();
          ctx.fill();
          // player
          ctx.fillStyle = "#ffffff";
          ctx.beginPath();
          ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        const forward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
        const right = new THREE.Vector3(Math.sin(yaw + Math.PI / 2), 0, Math.cos(yaw + Math.PI / 2));
        const up = new THREE.Vector3(0, 1, 0);
        const localForward = new THREE.Vector3(0, 0, -1);
        const localBack = new THREE.Vector3(0, 0, 1);
        const localRight = new THREE.Vector3(1, 0, 0);
        const localUp = new THREE.Vector3(0, 1, 0);
        const septiaAnchors = [
          localBack.clone().multiplyScalar(0.55).addScaledVector(localRight, -0.35).addScaledVector(localUp, 0.95),
          localBack.clone().multiplyScalar(0.55).addScaledVector(localRight, -0.45).addScaledVector(localUp, 0.65),
          localBack.clone().multiplyScalar(0.55).addScaledVector(localRight, -0.35).addScaledVector(localUp, 0.35),
          localBack.clone().multiplyScalar(0.55).addScaledVector(localRight, 0.35).addScaledVector(localUp, 0.95),
          localBack.clone().multiplyScalar(0.55).addScaledVector(localRight, 0.45).addScaledVector(localUp, 0.65),
          localBack.clone().multiplyScalar(0.55).addScaledVector(localRight, 0.35).addScaledVector(localUp, 0.35)
        ];
        septiaGroup.position.copy(player.position);
        septiaGroup.rotation.set(0, yaw, cameraRoll, "YXZ");
        septiaFireCooldown -= delta;
        const septiaExpanded = now < expansionActiveUntil;
        if (septiaFiring && septiaFireCooldown <= 0 && (en > 0 || septiaExpanded) && !energyLock) {
          const available = septiaDiamonds.find((d) => d.userData.state === "idle" && (!d.userData.extra || septiaExpanded));
          if (available) {
            const septiaTarget = findSeptiaTarget(player.position, 150);
            if (!septiaTarget) {
              septiaFireCooldown = 0;
            } else {
            if (now >= expansionActiveUntil) {
              en = Math.max(0, en - 0.5);
            }
            septiaFireCooldown = septiaExpanded ? 0.0125 : 0.025;
            available.userData.state = "attack";
            available.userData.timer = 0;
            available.userData.hitCount = 0;
            available.userData.nextHit = 1;
            available.userData.hitLimit = septiaExpanded ? 12 : 6;
            available.userData.nextHitAt = now + 1;
            available.userData.attackStartAt = now;
            available.userData.engageUntil = now + available.userData.hitLimit;
            available.userData.target = septiaTarget;
            available.userData.dir = new THREE.Vector3(
              -Math.sin(yaw) * Math.cos(pitch),
              Math.sin(pitch),
              -Math.cos(yaw) * Math.cos(pitch)
            ).normalize();
            available.userData.worldPos = null;
            }
          }
        }
        let idleCount = 0;
        let totalActive = septiaExpanded ? septiaTotal : septiaBaseTotal;
        for (let i = 0; i < septiaDiamonds.length; i += 1) {
          const d = septiaDiamonds[i];
          const active = !d.userData.extra || septiaExpanded;
          d.visible = active;
          if (!active) continue;
          const localIndex = d.userData.extra ? i - septiaBaseTotal : i;
          const wing = Math.floor(localIndex / 12);
          const idx = localIndex % 12;
          const wingSide = wing < 3 ? -1 : 1;
          const base = septiaAnchors[wing].clone();
          const spread = d.userData.extra ? 1.2 : 1;
          const colHeights = [1, 2, 3, 3, 2, 1];
          let col = 0;
          let rowInCol = idx;
          for (let c = 0; c < colHeights.length; c += 1) {
            if (rowInCol < colHeights[c]) {
              col = c;
              break;
            }
            rowInCol -= colHeights[c];
          }
          const colCount = colHeights[col];
          const colCenter = (colCount - 1) / 2;
          const sizeScale = (wing === 0 || wing === 3 || wing === 2 || wing === 5) ? 0.7 : 1;
          let x = (col - 2.5) * 0.14 * spread * sizeScale;
          if (wing === 0 || wing === 2) {
            x = -x;
          }
          const y = (rowInCol - colCenter) * 0.09 * spread;
          let tilt = 0;
          if (wing === 0 || wing === 3 || wing === 2 || wing === 5) {
            const endSign = (col - 2.5) / 2.5;
            const tiltAmount = 0.25;
            if (wing === 3 || wing === 5) {
              tilt = endSign * tiltAmount;
            } else {
              tilt = -endSign * tiltAmount;
            }
            if (wing === 2 || wing === 5) {
              tilt = -tilt;
            }
          }
          const offset = base
            .addScaledVector(localRight, wingSide * x)
            .addScaledVector(localUp, y + tilt);
          const basePos = offset;
          if (d.userData.state === "idle") {
            d.position.copy(basePos);
            d.userData.worldPos = null;
            idleCount += 1;
          } else {
            d.userData.timer += delta;
            const t = d.userData.timer;
            const baseWorld = septiaGroup.localToWorld(basePos.clone());
            const target = d.userData.target;
            const limit = d.userData.hitLimit || 6;
            const targetAlive = !!(target && target.mesh && enemies.includes(target));
            const engageUntil = d.userData.engageUntil || (now + limit);
            const attackWindow = now < engageUntil && d.userData.hitCount < limit;
            if (!d.userData.worldPos) {
              d.userData.worldPos = baseWorld.clone();
            }
            if (attackWindow) {
              if (targetAlive) {
                d.userData.worldPos.lerp(target.mesh.position, Math.min(1, 14 * delta));
              }
            } else {
              d.userData.worldPos.lerp(baseWorld, Math.min(1, 3.2 * delta));
            }
            const localPos = septiaGroup.worldToLocal(d.userData.worldPos.clone());
            d.position.copy(localPos);
            if (targetAlive && now >= (d.userData.nextHitAt || (now + 1)) && d.userData.hitCount < limit) {
              if (target) {
                applyEnemyDamage(target, septiaExpanded ? 650 : 500);
              }
              d.userData.hitCount += 1;
              d.userData.nextHit += 1;
              d.userData.nextHitAt = (d.userData.nextHitAt || now) + 1;
            }
            const returned = d.userData.worldPos.distanceTo(baseWorld) <= 0.08;
            if ((!attackWindow && returned) || now >= (engageUntil + 3)) {
              d.userData.state = "idle";
              d.userData.target = null;
              d.userData.worldPos = null;
              d.userData.nextHitAt = 0;
              d.userData.attackStartAt = 0;
              d.userData.engageUntil = 0;
            }
          }
        }
        if (septiaCountEl) septiaCountEl.textContent = `${idleCount}`;
        if (septiaGaugeEl) {
          septiaGaugeEl.style.transform = `scaleY(${idleCount / totalActive})`;
        }

        for (let i = 1; i <= 4; i += 1) {
          const nextSpawn = destructibleSpawnTimers.get(i) || 0;
          if (now >= nextSpawn) {
            spawnDestructibleInRoom(i);
            destructibleSpawnTimers.set(i, now + 10 + Math.random() * 50);
          }
        }
        enemyTypes.forEach((type) => {
          const roomEnemies = enemies.filter((e) => e.roomIndex === type.roomIndex);
          if (roomEnemies.length >= 30) return;
          const nextSpawn = enemySpawnTimers.get(type.roomIndex) || 0;
          if (now >= nextSpawn) {
            spawnEnemy(type);
            enemySpawnTimers.set(type.roomIndex, now + 10 + Math.random() * 10);
          }
        });

        let anyThreat = false;
        const threatDirs = [];
        for (const enemy of enemies) {
          const enemyPos = enemy.mesh.position;
          const prevEnemyPos = enemyPos.clone();
          const dist = enemyPos.distanceTo(player.position);
          const targeting = playerRoomIndex === enemy.roomIndex && dist <= 7.5;
          if (targeting) anyThreat = true;
          if (now >= enemy.nextMoveUpdate) {
            if (targeting) {
              enemy.moveTarget = player.position.clone();
            } else {
              enemy.moveTarget = randomPointInRoom(enemy.roomIndex);
            }
            enemy.nextMoveUpdate = now + 0.3 + Math.random() * 0.4;
          }
          const desired = enemy.moveTarget.clone();
          const toTarget = desired.sub(enemyPos);
          if (toTarget.lengthSq() > 0.0001) {
            const moveStep = Math.min(enemyMoveSpeed * delta, toTarget.length());
            toTarget.normalize().multiplyScalar(moveStep);
            enemyPos.add(toTarget);
          }
          if (targeting && dist < enemyAvoidRadius) {
            const pushDir = enemyPos.clone().sub(player.position).normalize();
            enemyPos.copy(player.position.clone().addScaledVector(pushDir, enemyAvoidRadius));
          }
          const bounds = getRoomBounds(enemy.roomIndex);
          enemyPos.x = clamp(enemyPos.x, bounds.minX, bounds.maxX);
          enemyPos.z = clamp(enemyPos.z, bounds.minZ, bounds.maxZ);
          enemyPos.y = floorY + enemyRadius;
          enemy.velocity.copy(enemyPos.clone().sub(prevEnemyPos).divideScalar(Math.max(delta, 0.0001)));

          if (enemy.label) {
            enemy.label.textContent = `AP ${Math.ceil(enemy.ap)} / PA ${Math.ceil(enemy.pa)}`;
            const labelPos = enemyPos.clone().add(new THREE.Vector3(0, enemyRadius + 0.4, 0));
            labelPos.project(camera);
            const x = (labelPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-labelPos.y * 0.5 + 0.5) * window.innerHeight;
            enemy.label.style.left = `${x}px`;
            enemy.label.style.top = `${y}px`;
            enemy.label.style.transform = "translate(-50%, -100%)";
            enemy.label.style.display = labelPos.z < 1 ? "block" : "none";
            enemy.label.classList.toggle("locked", enemy === lockTarget);
          }


          if (enemy.glow) {
            enemy.glow.material.opacity = 0;
          }

          if (now >= enemy.chargeStart && now < enemy.nextBeam) {
            const t = (now - enemy.chargeStart) / 10;
            const whiteT = Math.min(1, t / 0.8);
            const color = enemy.baseColor.clone().lerp(new THREE.Color(0xffffff), whiteT);
            if (enemy.core) enemy.core.material.color.copy(color);
          } else {
            if (enemy.core) enemy.core.material.color.copy(enemy.baseColor);
          }

          if (targeting && now >= enemy.nextBall && dist <= 10) {
            const dir = player.position.clone().sub(enemyPos).normalize();
            const ball = new THREE.Mesh(
              new THREE.SphereGeometry(0.12, 12, 12),
              new THREE.MeshStandardMaterial({ color: enemy.baseColor, emissive: enemy.baseColor, emissiveIntensity: 0.5 })
            );
            ball.position.copy(enemyPos).addScaledVector(dir, enemyRadius + 0.2);
            ball.userData.velocity = dir.clone().multiplyScalar(6);
            ball.userData.life = 5;
            const dmg = Math.max(500, 1000 - (dist / 10) * 500);
            ball.userData.damage = dmg;
            scene.add(ball);
            enemyProjectiles.push(ball);
            enemy.nextBall = now + 5;
          }

          if (targeting && now >= enemy.nextBeam) {
            applyDamage(7500);
            const beamMat = new THREE.LineBasicMaterial({ color: 0xffffff });
            const beamGeo = new THREE.BufferGeometry().setFromPoints([enemyPos.clone(), player.position.clone()]);
            const beam = new THREE.Line(beamGeo, beamMat);
            beam.userData.life = 0.3;
            scene.add(beam);
            enemyBeams.push(beam);
            enemy.nextBeam = now + 50;
            enemy.chargeStart = enemy.nextBeam - 10;
          }
          if (targeting) {
            const dx = enemyPos.x - player.position.x;
            const dz = enemyPos.z - player.position.z;
            const localX = dx * Math.cos(yaw) - dz * Math.sin(yaw);
            const localZ = dx * Math.sin(yaw) + dz * Math.cos(yaw);
            threatDirs.push({ x: localX, z: localZ });
          }
        }
        if (lockWarning) {
          lockWarning.style.display = anyThreat ? "block" : "none";
        }
        if (hitGreen) {
          hitGreen.style.display = now < hitGreenUntil ? "block" : "none";
        }
        if (hitRed) {
          hitRed.style.display = now < hitRedUntil ? "block" : "none";
          const damageLine = hitRed.querySelector("div:nth-child(2)");
          if (damageLine) {
            damageLine.style.display = now < hitRedDamageUntil ? "block" : "none";
          }
        }
        if (threatArrows.length > 0) {
          const centerX = window.innerWidth / 2;
          const centerY = window.innerHeight / 2;
          const radius = 40;
          for (let i = 0; i < threatArrows.length; i += 1) {
            const el = threatArrows[i];
            if (!anyThreat || i >= threatDirs.length) {
              el.style.display = "none";
              continue;
            }
            const s = threatDirs[i];
            let dx = s.x;
            let dy = s.z;
            const len = Math.max(1, Math.hypot(dx, dy));
            const nx = dx / len;
            const ny = dy / len;
            const px = centerX + nx * radius;
            const py = centerY + ny * radius;
            const angle = Math.atan2(ny, nx) + Math.PI / 2;
            el.style.display = "block";
            el.style.left = `${px}px`;
            el.style.top = `${py}px`;
            el.style.transform = `translate(-50%, -50%) rotate(${angle}rad)`;
          }
        }

        // Lock-on: pick up to 13 enemies inside large circle
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        const radiusPx = 320;
        const circleDrift = -cameraRoll * 420;
        lockCircleOffset += (circleDrift - lockCircleOffset) * Math.min(1, 7 * delta);
        if (lockCircleLarge) {
          lockCircleLarge.style.transform = `translate(-50%, -50%) translate(${lockCircleOffset}px, 0px)`;
        }
        const candidates = [];
        const lockCandidates = [];
        for (const candidate of enemies) {
          lockCandidates.push({ obj: candidate, pos: candidate.mesh.position });
        }
        for (const block of destructibleBlocks) {
          lockCandidates.push({ obj: block, pos: block.mesh.position });
        }
        for (const candidate of lockCandidates) {
          const pos = candidate.pos.clone().project(camera);
          if (pos.z > 1) continue;
          const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
          const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;
          const dx = x - (centerX + lockCircleOffset);
          const dy = y - centerY;
          const d2 = dx * dx + dy * dy;
          if (d2 <= radiusPx * radiusPx) {
            candidates.push({ target: candidate.obj, x, y, d2 });
          }
        }
        candidates.sort((a, b) => a.d2 - b.d2);
        lockTargets.length = 0;
        const count = Math.min(13, candidates.length);
        for (let i = 0; i < count; i += 1) {
          lockTargets.push(candidates[i]);
        }
        if (count > 0) {
          lockTarget = lockTargets[0].target;
          lockTargetUntil = now + 1.5;
        } else if (now > lockTargetUntil) {
          lockTarget = null;
        }
        for (let i = 0; i < lockCircles.length; i += 1) {
          const el = lockCircles[i];
          if (i < count) {
            const t = lockTargets[i];
            el.style.display = "block";
            el.style.left = `${t.x}px`;
            el.style.top = `${t.y}px`;
            el.style.transform = "translate(-50%, -50%)";
            const targetPos = t.target.mesh.position.clone();
            const inRange = targetPos.distanceTo(player.position) <= 150;
            const color = inRange ? "rgba(255, 90, 90, 0.9)" : "rgba(255, 255, 255, 0.9)";
            const glow = inRange ? "0 0 8px rgba(255, 90, 90, 0.6)" : "0 0 8px rgba(255, 255, 255, 0.6)";
            el.style.borderColor = color;
            el.style.boxShadow = glow;
          } else {
            el.style.display = "none";
          }
        }

        if (!paused) {
          fireCooldown -= delta;
          if ((firingLeft || firingRight) && fireCooldown <= 0) {
            fireCooldown = 0.1;
            const dirBase = new THREE.Vector3(
              -Math.sin(yaw) * Math.cos(pitch),
              Math.sin(pitch),
              -Math.cos(yaw) * Math.cos(pitch)
            ).normalize();
            const right = new THREE.Vector3(Math.sin(yaw + Math.PI / 2), 0, Math.cos(yaw + Math.PI / 2));
            const sides = [];
            if (firingLeft && !reloadingLeft && magLeft > 0) sides.push(-0.34);
            if (firingRight && !reloadingRight && magRight > 0) sides.push(0.34);
            const rainbow = [0xff3b3b, 0xff9f1c, 0xffe66d, 0x8cff6b, 0x4ecdc4, 0x5f9bff, 0x8a6bff, 0xff6bd4, 0xff5d5d, 0xffb45d, 0xfff05d, 0x7aff9e, 0x4dd6ff];
            for (const side of sides) {
              const pelletCount = 13;
              const isLeft = side < 0;
              const origin = new THREE.Vector3();
              if (isLeft) {
                gunLeft.getWorldPosition(origin);
                magLeft = Math.max(0, magLeft - 1);
              } else {
                gunRight.getWorldPosition(origin);
                magRight = Math.max(0, magRight - 1);
              }
              const pelletSpeed = 160;
              const pelletLife = 125;
              const pelletSize = isLeft ? 0.02 : 0.64;
              for (let i = 0; i < pelletCount; i += 1) {
                const spreadYaw = (Math.random() - 0.5) * 0.08;
                const spreadPitch = (Math.random() - 0.5) * 0.08;
                const dir = new THREE.Vector3(
                  -Math.sin(yaw + spreadYaw) * Math.cos(pitch + spreadPitch),
                  Math.sin(pitch + spreadPitch),
                  -Math.cos(yaw + spreadYaw) * Math.cos(pitch + spreadPitch)
                ).normalize();
                const bulletGeo = isLeft
                  ? new THREE.CylinderGeometry(0.02, 0.02, 2.4, 8)
                  : new THREE.BoxGeometry(pelletSize, pelletSize, pelletSize);
                const color = isLeft ? rainbow[i % rainbow.length] : 0x111111;
                const bulletMat = isLeft
                  ? new THREE.MeshStandardMaterial({
                    color,
                    emissive: color,
                    emissiveIntensity: 1.2,
                    transparent: true,
                    opacity: 0.75
                  })
                  : new THREE.MeshStandardMaterial({ color });
                const bullet = new THREE.Mesh(bulletGeo, bulletMat);
                if (isLeft) {
                  const up = new THREE.Vector3(0, 1, 0);
                  bullet.quaternion.setFromUnitVectors(up, dir);
                }
                const spawn = origin.clone().addScaledVector(dir, -0.05);
                bullet.position.copy(spawn);
                bullet.userData.velocity = dir.clone().multiplyScalar(pelletSpeed);
                bullet.userData.life = pelletLife;
                bullet.userData.range = 150;
                bullet.userData.travel = 0;
                bullet.userData.damage = 1000;
                bullet.userData.explosionDamage = 500;
                bullet.userData.explosionRadius = 2;
                bullet.userData.color = color;
                bullet.userData.isBeam = isLeft;
                bullet.userData.hitRadius = isLeft ? 0.2 : pelletSize * 0.6;
                bullet.userData.lockIndex = i;
                scene.add(bullet);
                bullets.push(bullet);
              }
            }
            if (magLeft === 0 && !reloadingLeft && firingLeft) {
              reloadingLeft = true;
              reloadEndLeft = performance.now() / 1000 + reloadTime;
            }
            if (magRight === 0 && !reloadingRight && firingRight) {
              reloadingRight = true;
              reloadEndRight = performance.now() / 1000 + reloadTime;
            }
          }
        }

        for (let i = bullets.length - 1; i >= 0; i -= 1) {
          const b = bullets[i];
          if (lockTargets.length > 0) {
            const target = lockTargets[b.userData.lockIndex % lockTargets.length];
            if (target && target.target) {
              const targetEnemy = target.target;
              const targetPos = targetEnemy.mesh.position.clone();
              const targetVel = targetEnemy.velocity ? targetEnemy.velocity.clone() : new THREE.Vector3();
              const speed = Math.max(1, b.userData.velocity.length());
              const leadTime = Math.min(0.55, b.position.distanceTo(targetPos) / speed);
              const predicted = targetPos.addScaledVector(targetVel, leadTime);
              const desired = predicted.sub(b.position).normalize();
              const current = b.userData.velocity.clone().normalize();
              const steerPower = b.userData.isBeam ? 0.5 : 0.38;
              const steer = current.lerp(desired, steerPower).normalize();
              b.userData.velocity.copy(steer.multiplyScalar(b.userData.velocity.length()));
            }
          }
          const stepDist = b.userData.velocity.length() * delta;
          b.position.addScaledVector(b.userData.velocity, delta);
          b.userData.life -= delta;
          b.userData.travel = (b.userData.travel || 0) + stepDist;
          let hit = false;
          const roomsHere = getRoomsForPos(b.position);
          if (roomsHere.length === 0) {
            hit = true;
          } else {
            for (const room of roomsHere) {
              for (const box of room.blockBoxes) {
                if (
                  b.position.x >= box.minX && b.position.x <= box.maxX &&
                  b.position.y >= box.minY && b.position.y <= box.maxY &&
                  b.position.z >= box.minZ && b.position.z <= box.maxZ
                ) {
                  if (box.destructible) {
                    applyDestructibleDamage(box.destructible, b.userData.damage || 0);
                  }
                  hit = true;
                  break;
                }
              }
              if (hit) break;
            }
          }
          if (!hit) {
            const hitRadius = b.userData.hitRadius || 0.2;
            for (const enemy of enemies) {
              if (enemy.mesh.position.distanceTo(b.position) <= enemyRadius + hitRadius) {
                applyEnemyDamage(enemy, b.userData.damage || 0);
                hit = true;
                break;
              }
            }
          }
          if (hit) {
            const fxColor = b.userData.color || 0xffffff;
            createExplosionField(b.position.clone(), b.userData.explosionRadius || 2, b.userData.explosionDamage || 0, fxColor);
            scene.remove(b);
            bullets.splice(i, 1);
            continue;
          }
          if (b.userData.life <= 0 || (b.userData.range && b.userData.travel >= b.userData.range) || roomsHere.length === 0) {
            scene.remove(b);
            bullets.splice(i, 1);
          }
        }
        if (bullets.length > 2000) {
          const excess = bullets.length - 2000;
          for (let i = 0; i < excess; i += 1) {
            const b = bullets.shift();
            if (b) scene.remove(b);
          }
        }

        for (let i = enemyProjectiles.length - 1; i >= 0; i -= 1) {
          const p = enemyProjectiles[i];
          if (p.userData.velocity) {
            p.position.addScaledVector(p.userData.velocity, delta);
            p.userData.life -= delta;
            if (p.position.distanceTo(player.position) <= playerHalf + 0.12) {
              applyDamage(p.userData.damage || 500);
              scene.remove(p);
              enemyProjectiles.splice(i, 1);
              continue;
            }
            if (p.userData.life <= 0 || p.position.distanceTo(player.position) > 12) {
              scene.remove(p);
              enemyProjectiles.splice(i, 1);
            }
          } else {
            p.userData.life -= delta;
            p.userData.startLife = p.userData.startLife || 0.25;
            const ratio = Math.max(0, p.userData.life / p.userData.startLife);
            p.material.opacity = 0.6 * ratio;
            p.scale.setScalar(1 + (1 - ratio) * 1.8);
            if (p.userData.life <= 0) {
              scene.remove(p);
              enemyProjectiles.splice(i, 1);
            }
          }
        }

        for (let i = enemyBeams.length - 1; i >= 0; i -= 1) {
          const beam = enemyBeams[i];
          beam.userData.life -= delta;
          if (beam.userData.life <= 0) {
            scene.remove(beam);
            enemyBeams.splice(i, 1);
          }
        }

        for (let i = explosionFields.length - 1; i >= 0; i -= 1) {
          const fx = explosionFields[i];
          fx.userData.life -= delta;
          const ratio = Math.max(0, fx.userData.life / fx.userData.startLife);
          fx.material.opacity = 0.9 * ratio;
          fx.scale.setScalar(1 + (1 - ratio) * 2.5);
          const radius = fx.userData.radius || 2;
          const dps = fx.userData.dps || 0;
          if (dps > 0) {
            for (const enemy of enemies) {
              if (enemy.mesh.position.distanceTo(fx.position) <= radius) {
                applyEnemyDamage(enemy, dps * delta);
              }
            }
            for (const block of destructibleBlocks) {
              if (block.mesh.position.distanceTo(fx.position) <= radius) {
                applyDestructibleDamage(block, dps * delta);
              }
            }
          }
          if (fx.userData.life <= 0) {
            scene.remove(fx);
            explosionFields.splice(i, 1);
          }
        }

        for (let i = floatingTexts.length - 1; i >= 0; i -= 1) {
          const f = floatingTexts[i];
          f.life -= delta;
          f.pos.addScaledVector(f.velocity, delta);
          const screen = f.pos.clone().project(camera);
          const x = (screen.x * 0.5 + 0.5) * window.innerWidth;
          const y = (-screen.y * 0.5 + 0.5) * window.innerHeight;
          f.el.style.left = `${x}px`;
          f.el.style.top = `${y}px`;
          f.el.style.opacity = `${Math.max(0, f.life / f.startLife)}`;
          if (f.life <= 0) {
            f.el.remove();
            floatingTexts.splice(i, 1);
          }
        }


        if (reloadingLeft && now >= reloadEndLeft) {
          reloadingLeft = false;
          magLeft = magMax;
        }
        if (reloadingRight && now >= reloadEndRight) {
          reloadingRight = false;
          magRight = magMax;
        }
      const reserveLeftText = reserveLeft === Infinity ? "∞" : reserveLeft;
      const reserveRightText = reserveRight === Infinity ? "∞" : reserveRight;
      if (ammoLeft) {
        ammoLeft.textContent = reloadingLeft
          ? "0 장전중"
          : `장전 ${magLeft} / 잔탄 ${reserveLeftText}`;
        ammoLeft.style.color = reloadingLeft ? "#ff4b4b" : "#ffffff";
      }
      if (ammoRight) {
        ammoRight.textContent = reloadingRight
          ? "0 장전중"
          : `장전 ${magRight} / 잔탄 ${reserveRightText}`;
        ammoRight.style.color = reloadingRight ? "#ff4b4b" : "#ffffff";
      }

        if (apPanel && apFill) {
          apPanel.querySelector(".label").textContent = `AP ${ap} / ${apMax}`;
          apFill.style.width = `${(ap / apMax) * 100}%`;
          apFill.style.background = now < repairHealEnd ? "#6bff6b" : "#ffffff";
        }
        if (paPanel && paFill) {
          paPanel.querySelector(".label").textContent = `PA ${pa} / ${paMax}`;
          paFill.style.width = `${(pa / paMax) * 100}%`;
          paFill.style.background = paCooldown ? "#ff4b4b" : "#59ff7a";
        }

        if (expansionHolding && expansionHoldStart && performance.now() - expansionHoldStart >= 1000) {
          expansionHoldStart = performance.now();
          if (now >= expansionCooldownEnd) {
            expansionCooldownEnd = now + 50;
            expansionActiveUntil = now + 50;
            expansionNextHeal = now + 0.2;
            expansionShockDone = false;
          }
        }
        if (now < expansionActiveUntil && now >= expansionNextHeal) {
          const roll = 50 + Math.floor(Math.random() * 951);
          ap = Math.min(apMax, ap + roll);
          expansionNextHeal = now + 0.2;
        }
        if (now < expansionActiveUntil) {
          if (!expansionShockDone) {
            for (const enemy of enemies) {
              if (enemy.mesh.position.distanceTo(player.position) <= 10) {
                enemy.pa = Math.max(0, enemy.pa - 10000);
                if (enemy.pa === 0) {
                  enemy.ap = Math.max(0, enemy.ap - 10000);
                }
              }
            }
            expansionShockDone = true;
          }
          const dps = (dist) => {
            if (dist < 2) return 1000;
            if (dist < 4) return 500;
            if (dist < 6) return 250;
            if (dist < 8) return 125;
            return 0;
          };
          for (const enemy of enemies) {
            const dist = enemy.mesh.position.distanceTo(player.position);
            const damagePerSecond = dps(dist);
            if (damagePerSecond > 0) {
              let dmg = damagePerSecond * delta;
              const usePa = Math.min(enemy.pa, dmg);
              enemy.pa -= usePa;
              dmg -= usePa;
              if (dmg > 0) {
                enemy.ap = Math.max(0, enemy.ap - dmg);
              }
            }
          }
        }

        if (kitHolding && kitHoldStart && performance.now() - kitHoldStart >= 1000) {
          kitHoldStart = performance.now();
          if (now >= repairCooldownEnd && (kitCount === Infinity || kitCount > 0)) {
            if (kitCount !== Infinity) kitCount -= 1;
            repairCooldownEnd = now + 10;
            repairHealStart = now;
            repairHealEnd = now + 1;
            repairHealAmount = Math.floor(apMax / 4 + ap / 3);
            repairHealApplied = 0;
            repairOverlayUntil = now + 0.2;
            repairActiveStart = now;
            repairActiveUntil = now + 6;
            pa = paMax;
            paCooldown = false;
            paCooldownEnd = 0;
            paInvulnUntil = now + 1.5;
          }
        }

        if (repairHealEnd > now) {
          const t = (now - repairHealStart) / (repairHealEnd - repairHealStart);
          const ratio = Math.max(0, Math.min(1, t));
          const target = Math.floor(repairHealAmount * ratio);
          const heal = Math.max(0, target - repairHealApplied);
          if (heal > 0) {
            ap = Math.min(apMax, ap + heal);
            repairHealApplied += heal;
          }
        }

        if (kitCooldownEl) {
          const cooldownLeft = Math.max(0, repairCooldownEnd - now);
          const ratio = Math.min(1, cooldownLeft / 10);
          kitCooldownEl.style.transform = `scaleY(${ratio})`;
        }

        if (repairOverlay) {
          const overlayActive = now < repairOverlayUntil;
          repairOverlay.style.opacity = overlayActive ? "1" : "0";
        }

        if (damageShield) {
          const remaining = Math.max(0, repairActiveUntil - now);
          const elapsed = Math.max(0, now - repairActiveStart);
          const stage = Math.floor(elapsed / 1.5);
          const alpha = remaining > 0 ? Math.max(0, 0.8 - stage * 0.2) : 0;
          damageShield.style.borderColor = `rgba(140, 255, 140, ${alpha})`;
        }
        if (expansionOverlay) {
          expansionOverlay.style.opacity = now < expansionActiveUntil ? "1" : "0";
        }
        if (expansionCooldownEl) {
          const cooldownLeft = Math.max(0, expansionCooldownEnd - now);
          const ratio = Math.min(1, cooldownLeft / 50);
          expansionCooldownEl.style.transform = `scaleY(${ratio})`;
        }
        if (now < repairActiveUntil) {
          const elapsed = now - repairActiveStart;
          if (elapsed < 1.5) damageScale = 0;
          else if (elapsed < 3) damageScale = 0.25;
          else if (elapsed < 4.5) damageScale = 0.5;
          else damageScale = 0.75;
        } else {
          damageScale = 1;
        }

        if (!paCooldown && pa <= 0) {
          pa = 0;
          paCooldown = true;
          paCooldownEnd = now + 50;
        }
        if (paCooldown) {
          pa = Math.min(paMax, pa + 528 * delta);
          if (pa >= paMax) {
            pa = paMax;
            paCooldown = false;
          }
        } else {
          pa = Math.min(paMax, pa + 132 * delta);
        }

        if (now < expansionActiveUntil) {
          const base = new THREE.Vector3(player.position.x, player.position.y + playerHalf, player.position.z);
          expansionSphere.visible = true;
          expansionSphere.position.copy(base);
        } else {
          expansionSphere.visible = false;
        }

        if (now < expansionCooldownEnd) {
          expansionParticleTimer += delta;
          const spawnInterval = 0.05;
          const right = new THREE.Vector3(Math.sin(yaw + Math.PI / 2), 0, Math.cos(yaw + Math.PI / 2));
          const back = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
          while (expansionParticleTimer >= spawnInterval) {
            expansionParticleTimer -= spawnInterval;
            for (const side of [-1, 1]) {
              const p = new THREE.Mesh(expansionParticleGeo, expansionParticleMat.clone());
              const base = new THREE.Vector3(player.position.x, player.position.y + playerHalf, player.position.z);
              const lateral = right.clone().multiplyScalar(0.35 * side);
              const origin = base.add(lateral).addScaledVector(back, 0.1);
              p.position.copy(origin);
              p.userData.velocity = right.clone().multiplyScalar(0.6 * side)
                .add(new THREE.Vector3((Math.random() - 0.5) * 0.2, 0.4 + Math.random() * 0.4, (Math.random() - 0.5) * 0.2));
              p.userData.life = 0.9 + Math.random() * 0.6;
              p.userData.startLife = p.userData.life;
              scene.add(p);
              expansionParticles.push(p);
            }
          }
        }

        for (let i = expansionParticles.length - 1; i >= 0; i -= 1) {
          const p = expansionParticles[i];
          p.position.addScaledVector(p.userData.velocity, delta);
          p.userData.life -= delta;
          p.material.opacity = Math.max(0, 0.8 * (p.userData.life / p.userData.startLife));
          if (p.userData.life <= 0) {
            scene.remove(p);
            expansionParticles.splice(i, 1);
          }
        }

      renderer.render(scene, camera);
      previewPivot.rotation.y = previewRotY;
      previewPivot.rotation.x = previewRotX;
      previewCamera.lookAt(0, 0, 0);
      previewRenderer.render(previewScene, previewCamera);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>




