<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>화이트 큐브 룸</title>
  <style>
    :root {
      --bg: #0e0e10;
      --ink: #f5f5f5;
      --muted: rgba(245, 245, 245, 0.6);
      --accent: #56b6f7;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      color: var(--ink);
      font-family: "Noto Sans KR", "Pretendard", "Apple SD Gothic Neo", sans-serif;
      overflow: hidden;
    }
    #ui {
      position: fixed;
      left: 16px;
      top: 16px;
      z-index: 5;
      background: rgba(10, 10, 12, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 12px;
      padding: 12px 14px;
      backdrop-filter: blur(6px);
      max-width: min(420px, 90vw);
    }
    #ui h1 {
      font-size: 16px;
      margin: 0 0 6px;
      letter-spacing: 0.02em;
    }
    #ui p {
      margin: 4px 0;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.4;
    }
    #ui .key {
      color: var(--ink);
      font-weight: 700;
    }
    #hint {
      position: fixed;
      right: 16px;
      top: 16px;
      z-index: 5;
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(86, 182, 247, 0.2);
      border: 1px solid rgba(86, 182, 247, 0.6);
      color: var(--accent);
      font-size: 12px;
    }
    #minimap {
      position: fixed;
      right: 16px;
      top: 16px;
      width: 320px;
      height: 320px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.35);
      background: rgba(8, 8, 12, 0.6);
      overflow: hidden;
      z-index: 9;
      pointer-events: none;
    }
    #minimap canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    #crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 14px;
      height: 14px;
      margin-left: -7px;
      margin-top: -7px;
      border: 1px solid rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      pointer-events: none;
      z-index: 4;
    }
    #aimModePanel {
      position: fixed;
      left: 16px;
      bottom: 150px;
      z-index: 8;
      background: rgba(10, 10, 12, 0.65);
      border: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: 10px;
      padding: 8px 12px;
      color: #ffffff;
      font-size: 12px;
      letter-spacing: 0.02em;
      min-width: 140px;
    }
    #lockCircleLarge, .lockCircleSmall {
      position: fixed;
      left: 50%;
      top: 50%;
      border-radius: 50%;
      pointer-events: none;
      z-index: 4;
      transform: translate(-50%, -50%);
    }
    #lockCircleLarge {
      width: 640px;
      height: 640px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
    }
    #hitGreen {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(380px, -50%);
      color: #7dff7d;
      font-size: 18px;
      letter-spacing: 0.04em;
      display: none;
      z-index: 6;
      -webkit-text-stroke: 1px rgba(125, 255, 125, 0.9);
      text-shadow: 0 0 6px rgba(125, 255, 125, 0.35);
    }
    #hitRed {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-430px, -50%);
      color: #ff7d7d;
      font-size: 18px;
      letter-spacing: 0.04em;
      display: none;
      z-index: 6;
      text-align: center;
      line-height: 1.3;
      -webkit-text-stroke: 1px rgba(255, 125, 125, 0.9);
      text-shadow: 0 0 6px rgba(255, 125, 125, 0.35);
    }
    .lockCircleSmall {
      width: 22px;
      height: 22px;
      border: 1px solid rgba(255, 90, 90, 0.9);
      box-shadow: 0 0 8px rgba(255, 90, 90, 0.6);
      display: none;
    }
    .ammoPanel {
      position: fixed;
      right: 16px;
      bottom: 18px;
      z-index: 7;
      background: rgba(10, 10, 12, 0.65);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 12px;
      color: #ffffff;
      min-width: 200px;
      line-height: 1.5;
    }
    #ammoPanel {
      transform: none;
    }
    .ammoPanel.left {
      right: 16px;
      left: auto;
      transform: translateX(-220px);
    }
    #apPanel {
      position: fixed;
      left: 16px;
      bottom: 18px;
      z-index: 7;
      min-width: 220px;
      color: #ffffff;
      font-size: 12px;
    }
    #paPanel {
      position: fixed;
      left: 16px;
      bottom: 48px;
      z-index: 7;
      min-width: 220px;
      color: #ffffff;
      font-size: 12px;
    }
    #expansionPanel {
      position: fixed;
      left: 16px;
      bottom: 84px;
      z-index: 7;
      display: grid;
      grid-template-columns: 56px 1fr;
      gap: 10px;
      align-items: center;
      color: #ffffff;
      font-size: 12px;
    }
    #expansionSlot {
      width: 56px;
      height: 56px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      border-radius: 10px;
      background: rgba(10, 10, 12, 0.6);
      display: grid;
      align-items: center;
      justify-items: center;
      font-size: 14px;
      color: #ff5a5a;
      position: relative;
    }
    #expansionSlot .cooldown {
      position: absolute;
      inset: 0;
      background: rgba(255, 90, 90, 0.18);
      transform-origin: bottom;
      transform: scaleY(0);
      border-radius: 10px;
      pointer-events: none;
    }
    #expansionList {
      display: grid;
      gap: 6px;
    }
    #expansionList .title {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.8);
      letter-spacing: 0.02em;
    }
    #expansionList .name {
      font-size: 13px;
      color: #ffffff;
    }
    #expansionList .count {
      font-size: 12px;
      color: #ff5a5a;
    }
    #apPanel .label {
      margin-bottom: 6px;
      color: rgba(255, 255, 255, 0.8);
    }
    #paPanel .label {
      margin-bottom: 6px;
      color: rgba(255, 255, 255, 0.8);
    }
    #apBar {
      height: 12px;
      background: #000000;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      overflow: hidden;
    }
    #paBar {
      height: 12px;
      background: #000000;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      overflow: hidden;
    }
    #apFill {
      height: 100%;
      width: 100%;
      background: #ffffff;
    }
    #paFill {
      height: 100%;
      width: 100%;
      background: #59ff7a;
    }
    #ammoPanel .row {
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }
    #ammoPanel .label {
      color: rgba(255, 255, 255, 0.75);
    }
    #stamina {
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      z-index: 6;
      width: min(520px, 88vw);
    }
    #enBarWrap {
      position: fixed;
      left: 50%;
      bottom: 46px;
      transform: translateX(-50%);
      z-index: 6;
      width: min(520px, 88vw);
    }
    #stamina .label {
      font-size: 12px;
      color: #000000;
      margin-bottom: 6px;
      letter-spacing: 0.02em;
    }
    #enBarWrap .label {
      font-size: 12px;
      color: #000000;
      margin-bottom: 6px;
      letter-spacing: 0.02em;
    }
    #stamina .bar {
      height: 16px;
      border: 1px solid #000000;
      border-radius: 6px;
      overflow: hidden;
      position: relative;
    }
    #enBarWrap .bar {
      height: 16px;
      border: 1px solid #000000;
      border-radius: 6px;
      overflow: hidden;
      position: relative;
    }
    #stamina .fill {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 100%;
      background: #ffd93d;
      transition: width 0.08s linear;
    }
    #enBarWrap .fill {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 100%;
      background: #4aa3ff;
      transition: width 0.08s linear;
    }
    #stamina .ticks {
      position: absolute;
      inset: 0;
      background:
        repeating-linear-gradient(
          90deg,
          #000000 0px,
          #000000 1px,
          transparent 1px,
          transparent 10%
        );
      pointer-events: none;
    }
    #enBarWrap .ticks {
      position: absolute;
      inset: 0;
      background:
        repeating-linear-gradient(
          90deg,
          #000000 0px,
          #000000 1px,
          transparent 1px,
          transparent 10%
        );
      pointer-events: none;
    }
    #energyWarning {
      position: fixed;
      left: 50%;
      bottom: 96px;
      transform: translateX(-50%);
      z-index: 7;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(255, 80, 80, 0.2);
      border: 1px solid rgba(255, 80, 80, 0.7);
      color: #ff8080;
      font-size: 12px;
      letter-spacing: 0.02em;
      display: none;
    }
    #apWarning {
      position: fixed;
      left: 50%;
      top: 28%;
      transform: translateX(-50%);
      z-index: 60;
      padding: 10px 18px;
      border-radius: 12px;
      background: rgba(255, 70, 70, 0.2);
      border: 1px solid rgba(255, 70, 70, 0.7);
      color: #ff8080;
      font-size: 16px;
      letter-spacing: 0.02em;
      display: none;
    }
    #lockWarning {
      position: fixed;
      left: 50%;
      top: 6%;
      transform: translateX(-50%);
      z-index: 60;
      padding: 8px 16px;
      border-radius: 999px;
      background: rgba(255, 60, 60, 0.2);
      border: 1px solid rgba(255, 60, 60, 0.75);
      color: #ff9a9a;
      font-size: 13px;
      letter-spacing: 0.02em;
      display: none;
    }
    #bossEggHint {
      position: fixed;
      left: 50%;
      bottom: 92px;
      transform: translateX(-50%);
      z-index: 9;
      padding: 8px 14px;
      border-radius: 999px;
      background: rgba(18, 18, 22, 0.78);
      border: 1px solid rgba(255, 255, 255, 0.38);
      color: #ffffff;
      font-size: 12px;
      letter-spacing: 0.03em;
      text-shadow: 0 0 6px rgba(0, 0, 0, 0.45);
      display: none;
      pointer-events: none;
    }
    .threatArrow {
      position: fixed;
      width: 0;
      height: 0;
      border-left: 20px solid transparent;
      border-right: 20px solid transparent;
      border-bottom: 44px solid rgba(255, 120, 120, 0.85);
      pointer-events: none;
      z-index: 7;
      display: none;
      transform-origin: 50% 80%;
    }
    .enemyLabel {
      position: fixed;
      z-index: 6;
      font-size: 10px;
      color: #ffffff;
      background: rgba(0, 0, 0, 0.45);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      padding: 2px 6px;
      pointer-events: none;
      white-space: nowrap;
    }
    .enemyLabel.locked {
      border-color: rgba(255, 90, 90, 0.9);
      box-shadow: 0 0 10px rgba(255, 90, 90, 0.6);
      color: #ffd6d6;
    }
    .floatText {
      position: fixed;
      z-index: 6;
      font-size: 11px;
      font-weight: 600;
      pointer-events: none;
      transform: translate(-50%, -50%);
      text-shadow: 0 0 6px rgba(0, 0, 0, 0.6);
    }
    #quickBar {
      position: fixed;
      left: 50%;
      bottom: 70px;
      transform: translateX(-50%);
      z-index: 7;
      display: grid;
      grid-template-columns: repeat(10, 36px);
      gap: 6px;
      align-items: end;
    }
    .quickSlot {
      height: 36px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      border-radius: 6px;
      background: rgba(10, 10, 12, 0.6);
      color: #ffffff;
      display: grid;
      align-items: center;
      justify-items: center;
      font-size: 12px;
      position: relative;
    }
    .quickLabel {
      position: absolute;
      top: -16px;
      font-size: 10px;
      color: rgba(255, 255, 255, 0.8);
      white-space: nowrap;
    }
    .quickCount {
      position: absolute;
      bottom: 2px;
      right: 4px;
      font-size: 10px;
      color: #ffffff;
    }
    .quickCooldown {
      position: absolute;
      inset: 0;
      background: rgba(120, 255, 120, 0.18);
      transform-origin: bottom;
      transform: scaleY(0);
      border-radius: 6px;
      pointer-events: none;
    }
    #repairOverlay {
      position: fixed;
      inset: 0;
      background: rgba(140, 255, 140, 0.18);
      opacity: 0;
      pointer-events: none;
      z-index: 50;
      transition: opacity 0.1s linear;
    }
    #damageShield {
      position: fixed;
      inset: 0;
      border: 16px solid rgba(140, 255, 140, 0);
      pointer-events: none;
      z-index: 49;
      transition: border-color 0.1s linear;
    }
    #expansionOverlay {
      position: fixed;
      inset: 0;
      border: 8px solid rgba(255, 70, 70, 0.55);
      background: rgba(255, 60, 60, 0.08);
      opacity: 0;
      pointer-events: none;
      z-index: 51;
      transition: opacity 0.1s linear;
    }
    #statusBlackOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 1);
      opacity: 0;
      pointer-events: none;
      z-index: 3;
      transition: opacity 0.08s linear;
    }
    #statusWhiteOverlay {
      position: fixed;
      inset: 0;
      background: rgba(255, 255, 255, 1);
      opacity: 0;
      pointer-events: none;
      z-index: 3;
      transition: opacity 0.08s linear;
    }
    #menuOverlay {
      position: fixed;
      inset: 0;
      background: rgba(10, 10, 12, 0.78);
      color: #ffffff;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
      backdrop-filter: blur(4px);
    }
    #menuOverlay.active {
      display: flex;
    }
    #menuPanel {
      width: min(980px, 92vw);
      min-height: min(560px, 80vh);
      background: rgba(20, 20, 24, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      padding: 22px 24px 20px;
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    #menuPanel h2 {
      margin: 0 0 8px;
      font-size: 18px;
      letter-spacing: 0.02em;
    }
    #menuPanel p {
      margin: 0;
      font-size: 13px;
      color: rgba(255, 255, 255, 0.75);
      line-height: 1.5;
    }
    #menuTabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      padding-right: 34px;
    }
    .menuTab {
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: transparent;
      color: rgba(255, 255, 255, 0.7);
      padding: 8px 12px;
      border-radius: 999px;
      font-size: 13px;
      cursor: pointer;
      transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
    }
    .menuTab.active {
      background: rgba(255, 255, 255, 0.12);
      color: #ffffff;
      border-color: rgba(255, 255, 255, 0.7);
    }
    #menuContent {
      flex: 1;
      background: rgba(10, 10, 14, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 12px;
      padding: 16px;
      overflow: auto;
    }
    .menuSection {
      display: none;
    }
    .menuSection.active {
      display: block;
    }
    .dualPane {
      display: grid;
      grid-template-columns: minmax(220px, 280px) 1fr;
      gap: 16px;
      align-items: stretch;
    }
    .detailPane {
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      background: rgba(6, 6, 8, 0.8);
      padding: 14px;
      display: grid;
      grid-template-rows: auto auto 1fr;
      gap: 12px;
      min-height: 360px;
    }
    .detailIconLarge {
      width: 120px;
      height: 120px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.02));
      position: relative;
      margin-bottom: 8px;
    }
    .detailIconLarge::after {
      content: "";
      position: absolute;
      inset: 14px;
      border: 1px dashed rgba(255, 255, 255, 0.35);
      border-radius: 10px;
    }
    .detailIconLarge.coreModel {
      border-color: rgba(255, 255, 255, 0.34);
      background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.28), rgba(255, 255, 255, 0.05));
      overflow: hidden;
    }
    .detailIconLarge.coreModel::after {
      display: none;
    }
    .detailIconLarge .coreGem {
      width: 62px;
      height: 62px;
      border-radius: 8px;
      box-shadow: 0 0 14px rgba(255, 255, 255, 0.2);
    }
    .detailIconLarge .coreGem::before,
    .detailIconLarge .coreGem::after {
      border-left-width: 16px;
      border-right-width: 16px;
    }
    .detailIconLarge .coreGem::before {
      top: -18px;
      border-bottom-width: 18px;
    }
    .detailIconLarge .coreGem::after {
      bottom: -18px;
      border-top-width: 18px;
    }
    .detailName {
      font-size: 14px;
      color: #ffffff;
      margin: 0;
    }
    .detailDesc {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.7);
      line-height: 1.5;
      background: rgba(255, 255, 255, 0.03);
      border: 1px dashed rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      padding: 10px;
      min-height: 120px;
    }
    .iconGrid {
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 12px;
      background: rgba(10, 10, 14, 0.5);
      padding: 12px;
      height: 100%;
      overflow: auto;
      cursor: grab;
    }
    .iconGrid.dragging {
      cursor: grabbing;
    }
    .gridWrap {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 10px;
    }
    .gridItem {
      display: grid;
      gap: 6px;
      justify-items: center;
      text-align: center;
      cursor: pointer;
    }
    .gridIcon {
      width: 56px;
      height: 56px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
      position: relative;
    }
    .gridIcon::after {
      content: "";
      position: absolute;
      inset: 10px;
      border: 1px dashed rgba(255, 255, 255, 0.35);
      border-radius: 6px;
    }
    .gridIcon.coreModel {
      border-color: rgba(255, 255, 255, 0.28);
      background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.26), rgba(255, 255, 255, 0.04));
      overflow: hidden;
    }
    .gridIcon.coreModel::after {
      display: none;
    }
    .coreGem {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 30px;
      height: 30px;
      transform: translate(-50%, -50%) rotate(45deg);
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.18);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0.08));
    }
    .coreGem::before,
    .coreGem::after {
      content: "";
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
    }
    .coreGem::before {
      top: -10px;
      border-bottom: 10px solid rgba(255, 255, 255, 0.45);
    }
    .coreGem::after {
      bottom: -10px;
      border-top: 10px solid rgba(0, 0, 0, 0.25);
    }
    .gridIcon.core-phoenix .coreGem {
      background: linear-gradient(140deg, #ffd19c, #ff5b2e 65%, #8c1f10);
      box-shadow: 0 0 10px rgba(255, 92, 46, 0.42);
    }
    .gridIcon.core-liger .coreGem {
      background: linear-gradient(140deg, #fff6b5, #ffd63a 62%, #8f6d12);
      box-shadow: 0 0 10px rgba(255, 214, 58, 0.42);
    }
    .gridIcon.core-hyunmu .coreGem {
      background: linear-gradient(140deg, #c5ffd1, #48d771 62%, #196b36);
      box-shadow: 0 0 10px rgba(72, 215, 113, 0.42);
    }
    .gridIcon.core-dragoon .coreGem {
      background: linear-gradient(140deg, #c6e8ff, #4aa8ff 62%, #1d4f8d);
      box-shadow: 0 0 10px rgba(74, 168, 255, 0.42);
    }
    .gridIcon.coreLocked .coreGem,
    .detailIconLarge.coreLocked .coreGem {
      filter: grayscale(1) brightness(0.5);
      box-shadow: 0 0 8px rgba(170, 170, 170, 0.2);
    }
    .gridIcon.locked,
    .detailIconLarge.locked {
      filter: grayscale(1) brightness(0.55);
    }
    .gridIcon.bossModel {
      border-color: rgba(255, 255, 255, 0.28);
      background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.24), rgba(255, 255, 255, 0.04));
      overflow: hidden;
    }
    .gridIcon.bossModel::after {
      display: none;
    }
    .bossSig {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 36px;
      height: 36px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.38);
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .bossSig svg {
      width: 78%;
      height: 78%;
      fill: rgba(255, 255, 255, 0.92);
      filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.35));
    }
    .gridIcon.boss-phoenix .bossSig { background: linear-gradient(135deg, #ffcc9c, #ff5f38 68%, #7f2017); }
    .gridIcon.boss-liger .bossSig { background: linear-gradient(135deg, #fff3ad, #ffd83f 68%, #7f6718); }
    .gridIcon.boss-hyunmu .bossSig { background: linear-gradient(135deg, #cbffcf, #4fd676 68%, #1f6c38); }
    .gridIcon.boss-dragoon .bossSig { background: linear-gradient(135deg, #cde9ff, #53abff 68%, #1f4f84); }
    .detailIconLarge.boss-phoenix .bossSig { background: linear-gradient(135deg, #ffcc9c, #ff5f38 68%, #7f2017); }
    .detailIconLarge.boss-liger .bossSig { background: linear-gradient(135deg, #fff3ad, #ffd83f 68%, #7f6718); }
    .detailIconLarge.boss-hyunmu .bossSig { background: linear-gradient(135deg, #cbffcf, #4fd676 68%, #1f6c38); }
    .detailIconLarge.boss-dragoon .bossSig { background: linear-gradient(135deg, #cde9ff, #53abff 68%, #1f4f84); }
    .detailIconLarge.bossModel .bossSig {
      width: 68px;
      height: 68px;
      border-radius: 50%;
      box-shadow: 0 0 16px rgba(255, 255, 255, 0.22);
      font-size: 38px;
    }
    .gridLabel {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.75);
      line-height: 1.2;
    }
    .assemblyGrid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .assemblyLayout {
      display: grid;
      grid-template-columns: minmax(220px, 280px) 1fr;
      gap: 16px;
      align-items: start;
    }
    #assemblyPreview {
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      background: rgba(6, 6, 8, 0.8);
      padding: 12px;
      display: grid;
      gap: 8px;
    }
    #assemblyPreview h3 {
      margin: 0;
      font-size: 13px;
      color: rgba(255, 255, 255, 0.85);
    }
    #assemblyPreviewCanvas {
      width: 100%;
      aspect-ratio: 1 / 1;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 10px;
      border: 1px dashed rgba(255, 255, 255, 0.2);
      cursor: grab;
    }
    #assemblyPreviewCanvas.dragging {
      cursor: grabbing;
    }
    .assemblyGroup {
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 12px;
      padding: 12px;
      background: rgba(8, 8, 12, 0.5);
    }
    .assemblyTitle {
      font-size: 14px;
      margin: 0 0 10px;
      color: #ffffff;
      letter-spacing: 0.02em;
    }
    .assemblyItems {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }
    .assemblyItem {
      display: grid;
      gap: 6px;
      align-items: center;
      justify-items: center;
      text-align: center;
      cursor: pointer;
    }
    .assemblyIcon {
      width: 56px;
      height: 56px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
      position: relative;
    }
    .assemblyIcon.machinehandgun {
      background-color: rgba(255, 255, 255, 0.04);
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'><rect width='56' height='56' fill='none'/><g fill='none' stroke='%23d7d7d7' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M10 30 h26 l6 -4 h4'/><path d='M18 30 v10 h6 v-6'/><path d='M10 30 v6 h8'/><path d='M36 26 h6 v4'/></g></svg>");
      background-repeat: no-repeat;
      background-position: center;
    }
    .assemblyIcon::after {
      content: "";
      position: absolute;
      inset: 10px;
      border: 1px dashed rgba(255, 255, 255, 0.35);
      border-radius: 6px;
    }
    .assemblyLabel {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.8);
      line-height: 1.3;
    }
    #assemblyDetail {
      margin-top: 16px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      background: rgba(6, 6, 8, 0.8);
      padding: 16px;
      display: none;
    }
    #assemblyDetail.active {
      display: block;
    }
    #assemblyDetailHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 12px;
    }
    #assemblyDetailTitle {
      font-size: 14px;
      color: #ffffff;
      margin: 0;
    }
    #assemblyDetailClose {
      width: 18px;
      height: 18px;
      border: 1px solid rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      position: relative;
      cursor: pointer;
    }
    #assemblyDetailClose::before,
    #assemblyDetailClose::after {
      content: "";
      position: absolute;
      top: 3px;
      left: 8px;
      width: 2px;
      height: 12px;
      background: #ffffff;
    }
    #assemblyDetailClose::before { transform: rotate(45deg); }
    #assemblyDetailClose::after { transform: rotate(-45deg); }
    .detailSection {
      margin-bottom: 14px;
    }
    .detailSection h4 {
      margin: 0 0 8px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.8);
      letter-spacing: 0.02em;
    }
    .detailGrid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
      gap: 10px;
    }
    .detailIcon {
      height: 64px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.02));
      position: relative;
    }
    .detailIcon::after {
      content: "";
      position: absolute;
      inset: 12px;
      border: 1px dashed rgba(255, 255, 255, 0.35);
      border-radius: 6px;
    }
    .statusPlaceholder {
      min-height: 120px;
      border-radius: 12px;
      border: 1px dashed rgba(255, 255, 255, 0.35);
      background: rgba(255, 255, 255, 0.03);
      padding: 10px;
      color: rgba(255, 255, 255, 0.88);
      font-size: 12px;
    }
    .statusRows {
      display: grid;
      gap: 8px;
    }
    .statusRow {
      display: grid;
      grid-template-columns: 110px 1fr;
      gap: 8px;
      align-items: center;
    }
    .statusRow .key {
      color: rgba(255, 255, 255, 0.72);
      font-size: 11px;
      border: 0;
      background: none;
      padding: 0;
      box-shadow: none;
    }
    .statusRow .value {
      color: #ffffff;
      font-size: 12px;
    }
    #menuClose {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 20px;
      height: 20px;
      border: 1px solid rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      cursor: pointer;
    }
    #menuClose::before,
    #menuClose::after {
      content: "";
      position: absolute;
      top: 4px;
      left: 9px;
      width: 2px;
      height: 12px;
      background: #ffffff;
    }
    #menuClose::before {
      transform: rotate(45deg);
    }
    #menuClose::after {
      transform: rotate(-45deg);
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
    }
    #mobileControls {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 30;
      pointer-events: none;
    }
    body.mobile-mode #mobileControls {
      display: block;
    }
    body.mobile-mode.menu-open #mobileControls {
      display: none;
    }
    .mobileZone {
      position: fixed;
      bottom: 18px;
      width: min(36vw, 220px);
      aspect-ratio: 1 / 1;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.28);
      background: rgba(8, 8, 12, 0.42);
      box-shadow: inset 0 0 16px rgba(0, 0, 0, 0.35);
      pointer-events: auto;
      touch-action: none;
    }
    #mobileMoveZone {
      left: 16px;
    }
    #mobileLookZone {
      right: 16px;
    }
    .mobileStick {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 34%;
      height: 34%;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      border: 1px solid rgba(255, 255, 255, 0.65);
      background: rgba(255, 255, 255, 0.12);
      pointer-events: none;
    }
    #mobileButtons {
      position: fixed;
      right: 16px;
      bottom: calc(min(36vw, 220px) + 34px);
      display: grid;
      grid-template-columns: repeat(2, minmax(54px, 72px));
      gap: 8px;
      pointer-events: auto;
    }
    .mobileBtn {
      border: 1px solid rgba(255, 255, 255, 0.45);
      border-radius: 10px;
      background: rgba(10, 10, 12, 0.72);
      color: #ffffff;
      font-size: 11px;
      letter-spacing: 0.04em;
      padding: 8px 0;
      touch-action: manipulation;
    }
    .mobileBtn:active,
    .mobileBtn.active {
      background: rgba(86, 182, 247, 0.35);
      border-color: rgba(86, 182, 247, 0.9);
    }
    body.mobile-mode #ui {
      max-width: min(72vw, 360px);
      padding: 10px 12px;
    }
    body.mobile-mode #ui p {
      font-size: 12px;
    }
    body.mobile-mode #minimap {
      width: min(42vw, 180px);
      height: min(42vw, 180px);
      top: 12px;
      right: 12px;
    }
    body.mobile-mode #ammoPanel,
    body.mobile-mode #ammoPanelLeft {
      display: none;
    }
  </style>
</head>
<body>
  <div id="ui">
    <h1>화이트 큐브 룸 (필드 11 x 11)</h1>
    <p><span class="key">W</span> 전면 이동 · <span class="key">A</span> 좌면 이동 · <span class="key">S</span> 후면 이동 · <span class="key">D</span> 우면 이동</p>
    <p><span class="key">Space</span> 점프 · <span class="key">마우스</span> 시점 변경</p>
    <p><span class="key">F</span> 상호작용(보스 알 근처 1초 홀드로 부활)</p>
    <p>화면을 클릭하면 마우스가 고정됩니다. ESC로 해제됩니다.</p>
  </div>
    <div id="minimap" aria-hidden="true"><canvas id="minimapCanvas"></canvas></div>
    <div id="crosshair" aria-hidden="true"></div>
    <div id="lockCircleLarge" aria-hidden="true"></div>
    <div id="aimModePanel" aria-live="polite">조준 모드: 자동</div>
    <div id="hitGreen">HIT</div>
    <div id="hitRed"><div>HIT</div><div>DAMAGE</div></div>
  <div id="ammoPanel" class="ammoPanel" aria-live="polite">
    <div class="row">
      <div class="label">우측 등 무장</div>
    </div>
    <div class="row">
      <div id="ammoRightBack">장전 30 / 잔탄 ∞</div>
    </div>
    <div class="row" style="margin-top:8px;"></div>
    <div class="row">
      <div class="label">우측 어깨 무장</div>
    </div>
    <div class="row">
      <div id="ammoRightShoulder">장전 30 / 잔탄 ∞</div>
    </div>
    <div class="row" style="margin-top:2px;">
      <div class="label">우측 어깨 내장 무장</div>
    </div>
    <div class="row">
      <div id="ammoRightShoulderInner">장전 30 / 잔탄 ∞</div>
    </div>
    <div class="row" style="margin-top:8px;"></div>
    <div class="row">
      <div class="label">우측 손 무장</div>
    </div>
    <div class="row">
      <div id="ammoRight">장전 30 / 잔탄 ∞</div>
    </div>
    <div class="row" style="margin-top:2px;">
      <div class="label">우측 손 내장 무장</div>
    </div>
    <div class="row">
      <div id="ammoRightInner">장전 30 / 잔탄 ∞</div>
    </div>
  </div>
  <div id="ammoPanelLeft" class="ammoPanel left" aria-live="polite">
    <div class="row">
      <div class="label">좌측 등 무장</div>
    </div>
    <div class="row">
      <div id="ammoLeftBack">장전 30 / 잔탄 ∞</div>
    </div>
    <div class="row" style="margin-top:8px;"></div>
    <div class="row">
      <div class="label">좌측 어깨 무장</div>
    </div>
    <div class="row">
      <div id="ammoLeftShoulder">장전 30 / 잔탄 ∞</div>
    </div>
    <div class="row" style="margin-top:2px;">
      <div class="label">좌측 어깨 내장 무장</div>
    </div>
    <div class="row">
      <div id="ammoLeftShoulderInner">장전 30 / 잔탄 ∞</div>
    </div>
    <div class="row" style="margin-top:8px;"></div>
    <div class="row">
      <div class="label">좌측 손 무장</div>
      <div id="ammoLeft">장전 30 / 잔탄 ∞</div>
    </div>
    <div class="row">
      <div class="label">좌측 손 내장 무장</div>
      <div id="ammoLeftInner">장전 30 / 잔탄 ∞</div>
    </div>
  </div>
  <div id="quickBar" aria-live="polite">
    <div class="quickSlot" data-slot="1">
      <div class="quickLabel">리페어 키트</div>
      1
      <div class="quickCount" id="kitCount">∞</div>
      <div class="quickCooldown" id="kitCooldown"></div>
    </div>
      <div class="quickSlot" data-slot="2">
        <div class="quickLabel">코어 내장 무장</div>
        2
        <div class="quickCount" id="septiaCount">72</div>
        <div class="quickCooldown" id="septiaGauge"></div>
      </div>
    <div class="quickSlot" data-slot="3">3</div>
    <div class="quickSlot" data-slot="4">4</div>
    <div class="quickSlot" data-slot="5">5</div>
    <div class="quickSlot" data-slot="6">6</div>
    <div class="quickSlot" data-slot="7">7</div>
    <div class="quickSlot" data-slot="8">8</div>
    <div class="quickSlot" data-slot="9">9</div>
    <div class="quickSlot" data-slot="0">0</div>
  </div>
    <div id="repairOverlay"></div>
    <div id="damageShield"></div>
    <div id="expansionOverlay"></div>
    <div id="statusBlackOverlay"></div>
    <div id="statusWhiteOverlay"></div>
    <div id="mobileControls" aria-hidden="true">
      <div id="mobileMoveZone" class="mobileZone">
        <div id="mobileMoveStick" class="mobileStick"></div>
      </div>
      <div id="mobileLookZone" class="mobileZone">
        <div id="mobileLookStick" class="mobileStick"></div>
      </div>
      <div id="mobileButtons">
        <button id="mobileJumpBtn" class="mobileBtn" type="button">JUMP</button>
        <button id="mobileBoostBtn" class="mobileBtn" type="button">BOOST</button>
        <button id="mobileFireLBtn" class="mobileBtn" type="button">L-FIRE</button>
        <button id="mobileFireRBtn" class="mobileBtn" type="button">R-FIRE</button>
        <button id="mobileMenuBtn" class="mobileBtn" type="button">MENU</button>
      </div>
    </div>
    <div id="paPanel" aria-live="polite">
      <div class="label">PA 9999 / 9999</div>
      <div id="paBar">
        <div id="paFill"></div>
      </div>
    </div>
    <div id="expansionPanel" aria-live="polite">
      <div id="expansionSlot">
        ∞
        <div class="cooldown" id="expansionCooldown"></div>
      </div>
      <div id="expansionList">
        <div class="title">익스팬션</div>
        <div class="name">셀 윙</div>
        <div class="count">∞</div>
      </div>
    </div>
    <div id="apPanel" aria-live="polite">
      <div class="label">AP 99999 / 99999</div>
      <div id="apBar">
        <div id="apFill"></div>
      </div>
    </div>
    <div id="enBarWrap" aria-live="polite">
      <div class="label">EN 바</div>
      <div class="bar">
        <div id="enFill" class="fill"></div>
        <div class="ticks" aria-hidden="true"></div>
      </div>
    </div>
    <div id="energyWarning">에너지 고갈 상태</div>
    <div id="apWarning">치명적인 피해!</div>
    <div id="lockWarning">경고: 락온됨</div>
    <div id="bossEggHint">(F를 1초 눌러 보스 부활)</div>
    <div id="stamina" aria-live="polite">
      <div class="label">스테미너 바</div>
      <div class="bar">
        <div id="staminaFill" class="fill"></div>
        <div class="ticks" aria-hidden="true"></div>
    </div>
  </div>
  <div id="menuOverlay" aria-hidden="true">
    <div id="menuPanel" role="dialog" aria-modal="true" aria-label="메뉴">
      <div id="menuClose" aria-label="닫기"></div>
      <h2>메뉴</h2>
      <div id="menuTabs" role="tablist" aria-label="메뉴 탭">
        <button class="menuTab active" data-tab="controls" role="tab" aria-selected="true">조작법</button>
        <button class="menuTab" data-tab="codex" role="tab" aria-selected="false">도감</button>
        <button class="menuTab" data-tab="assembly" role="tab" aria-selected="false">어셈블리</button>
        <button class="menuTab" data-tab="items" role="tab" aria-selected="false">아이템</button>
        <button class="menuTab" data-tab="shop" role="tab" aria-selected="false">상점</button>
      </div>
      <div id="menuContent">
        <div id="tab-controls" class="menuSection active">
          <p><strong>조작법</strong></p>
          <p>이동: W/A/S/D · 시점: 마우스 · 점프: Space</p>
          <p>상호작용: F(홀드) · 보스 알 근처에서 1초 홀드 시 부활</p>
          <p>체공/비행: Shift 유지 · Shift+W로 전방 비행 가속</p>
          <p>대쉬: Shift+Space 상태에서 W/A/S/D, 셀 윙 중에는 자원 소모 없음</p>
          <p>조준 모드 전환: 마우스4(사이드 버튼) · 에임 보정: 마우스5 누르는 동안만 보정</p>
          <p>락온: 큰 원 안의 적/블럭 자동 표적화 + 유도 사격</p>
          <p><strong>게임 요소 요약</strong></p>
          <p>전장: 중앙 흰 방 + 4색 방 + 4개 레어 방으로 연결된 구조</p>
          <p>레어 방 이름: 피닉스 레어 / 라이거 레어 / 현무 레어 / 드라군 레어</p>
          <p>Q(셀 윙): 1초 홀드 발동, 일정 시간 강화/무적 + AP 회복/광역 충격</p>
          <p>1(리페어 키트): 1초 홀드, AP 회복 + 피해 완화 단계 적용</p>
          <p>2(셉티아): 홀드 중 자동 표적 다이아몬드 발사</p>
          <p>전투: 색 방/레어 방에서 적 구체와 파괴 블럭이 주기적으로 생성</p>
        </div>
        <div id="tab-codex" class="menuSection">
          <p><strong>도감</strong></p>
          <div class="dualPane">
            <div class="detailPane" id="codexDetail">
              <div>
                <div class="detailIconLarge" id="codexDetailIcon"></div>
                <h3 class="detailName" id="codexDetailName">도감 항목</h3>
              </div>
              <div class="detailDesc" id="codexDetailDesc">선택한 도감 항목의 설명이 표시됩니다.</div>
            </div>
            <div class="iconGrid" id="codexGrid">
              <div class="gridWrap" id="codexGridWrap"></div>
            </div>
          </div>
        </div>
        <div id="tab-assembly" class="menuSection">
          <p><strong>어셈블리</strong></p>
          <div class="assemblyLayout">
            <div id="assemblyPreview">
              <h3>기체 미리보기</h3>
              <canvas id="assemblyPreviewCanvas"></canvas>
            </div>
            <div class="assemblyGrid">
              <div class="assemblyGroup">
                <h3 class="assemblyTitle">헤드</h3>
                <div class="assemblyItems">
                <div class="assemblyItem" data-assembly="FCS">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">FCS</div>
                </div>
                <div class="assemblyItem" data-assembly="헤드 내장 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">헤드 내장 무장</div>
                  </div>
                </div>
              </div>
              <div class="assemblyGroup">
                <h3 class="assemblyTitle">코어</h3>
                <div class="assemblyItems">
                  <div class="assemblyItem" data-assembly="제네레이터">
                    <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">제네레이터</div>
                </div>
                <div class="assemblyItem" data-assembly="부스터">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">부스터</div>
                </div>
                <div class="assemblyItem" data-assembly="우측 등 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">우측 등 무장</div>
                </div>
                <div class="assemblyItem" data-assembly="좌측 등 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">좌측 등 무장</div>
                </div>
                <div class="assemblyItem" data-assembly="코어 내장 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">코어 내장 무장</div>
                </div>
                <div class="assemblyItem" data-assembly="익스팬션">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">익스팬션</div>
                </div>
                </div>
              </div>
              <div class="assemblyGroup">
                <h3 class="assemblyTitle">우완부</h3>
                <div class="assemblyItems">
                <div class="assemblyItem" data-assembly="우측 손 무장: 테스트용 머신핸드건" data-slot="우측 손 무장">
                  <div class="assemblyIcon machinehandgun"></div>
                  <div class="assemblyLabel">테스트용 머신핸드건</div>
                </div>
                <div class="assemblyItem" data-assembly="우측 손 내장 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">우측 손 내장 무장</div>
                </div>
                <div class="assemblyItem" data-assembly="우측 어깨 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">우측 어깨 무장</div>
                </div>
                <div class="assemblyItem" data-assembly="우측 어깨 내장 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">우측 어깨 내장 무장</div>
                  </div>
                </div>
              </div>
              <div class="assemblyGroup">
                <h3 class="assemblyTitle">좌완부</h3>
                <div class="assemblyItems">
                <div class="assemblyItem" data-assembly="좌측 손 무장: 테스트용 머신핸드건" data-slot="좌측 손 무장">
                  <div class="assemblyIcon machinehandgun"></div>
                  <div class="assemblyLabel">테스트용 머신핸드건</div>
                </div>
                <div class="assemblyItem" data-assembly="좌측 손 내장 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">좌측 손 내장 무장</div>
                </div>
                <div class="assemblyItem" data-assembly="좌측 어깨 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">좌측 어깨 무장</div>
                </div>
                <div class="assemblyItem" data-assembly="좌측 어깨 내장 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">좌측 어깨 내장 무장</div>
                  </div>
                </div>
              </div>
              <div class="assemblyGroup">
                <h3 class="assemblyTitle">각부</h3>
                <div class="assemblyItems">
                <div class="assemblyItem" data-assembly="각부 우측 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">각부 우측 무장</div>
                </div>
                <div class="assemblyItem" data-assembly="각부 좌측 무장">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">각부 좌측 무장</div>
                </div>
                <div class="assemblyItem" data-assembly="서브 부스터">
                  <div class="assemblyIcon"></div>
                  <div class="assemblyLabel">서브 부스터</div>
                </div>
                </div>
              </div>
            </div>
          </div>
          <div id="assemblyDetail" aria-live="polite">
            <div id="assemblyDetailHeader">
              <h3 id="assemblyDetailTitle">선택된 파츠</h3>
              <div style="display:flex; gap:8px; align-items:center;">
                <button id="assemblyUnequip" class="menuTab" style="border-radius:10px;">무장 해제</button>
                <div id="assemblyDetailClose" aria-label="닫기"></div>
              </div>
            </div>
            <div class="detailSection">
              <h4>현재 착용 중인 파츠</h4>
              <div class="detailGrid" id="assemblyDetailCurrent">
                <div class="detailIcon"></div>
              </div>
            </div>
            <div class="detailSection">
              <h4>소지한 파츠</h4>
              <div class="detailGrid" id="assemblyDetailInventory">
                <div class="detailIcon"></div>
                <div class="detailIcon"></div>
                <div class="detailIcon"></div>
                <div class="detailIcon"></div>
              </div>
            </div>
            <div class="detailSection">
              <h4>스테이터스</h4>
              <div class="statusPlaceholder" id="assemblyDetailStatus">스테이터스 영역 (추후 추가)</div>
            </div>
          </div>
        </div>
        <div id="tab-items" class="menuSection">
          <p><strong>아이템</strong></p>
          <div class="dualPane">
            <div class="detailPane" id="itemDetail">
              <div>
                <div class="detailIconLarge" id="itemDetailIcon"></div>
                <h3 class="detailName" id="itemDetailName">아이템</h3>
              </div>
              <div class="detailDesc" id="itemDetailDesc">선택한 아이템의 설명이 표시됩니다.</div>
            </div>
            <div class="iconGrid" id="itemGrid">
              <div class="gridWrap" id="itemGridWrap"></div>
            </div>
          </div>
        </div>
        <div id="tab-shop" class="menuSection">
          <p><strong>상점</strong></p>
          <div class="dualPane">
            <div class="detailPane" id="shopDetail">
              <div>
                <div class="detailIconLarge" id="shopDetailIcon"></div>
                <h3 class="detailName" id="shopDetailName">상점 아이템</h3>
              </div>
              <div class="detailDesc" id="shopDetailDesc">선택한 상점 아이템의 설명이 표시됩니다.</div>
            </div>
            <div class="iconGrid" id="shopGrid">
              <div class="gridWrap" id="shopGridWrap"></div>
            </div>
          </div>
        </div>
      </div>
      <p>E 키를 다시 누르거나 우측 상단의 X를 클릭하면 게임이 재개됩니다.</p>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    const cellSize = 10;
    const roomCells = 11;
    const roomSize = roomCells * cellSize;
    const roomHeight = 3 * cellSize;
    const half = roomSize / 2;
    const playerSize = 1;
    const playerHalf = playerSize / 2;
    const floorY = playerHalf;
    const ceilingY = roomHeight - playerHalf;
    const moveSpeed = 10.5;
    const dashDistance = moveSpeed;
    const dashCooldown = 0.2;
    const flyAccel = 20;
    const gravity = 25;
    const jumpHeight = 0.5;
    const baseJumpSpeed = Math.sqrt(2 * gravity * jumpHeight);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0e0e10);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.05, 1000);
    camera.position.set(0, playerSize, 4);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const ambient = new THREE.AmbientLight(0xffffff, 0.7);
    const dir = new THREE.DirectionalLight(0xffffff, 0.7);
    dir.position.set(5, 10, 2);
    scene.add(ambient, dir);

    function createMaterial(color) {
      return new THREE.MeshStandardMaterial({
        color,
        roughness: 0.9,
        metalness: 0.0,
        side: THREE.DoubleSide
      });
    }

    function mulberry32(seed) {
      return function () {
        let t = seed += 0x6d2b79f5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function buildMaze(size, openings, seed) {
      const grid = Array.from({ length: size }, () => Array(size).fill(1));
      const rand = mulberry32(seed);
      const dirs = [
        { x: 0, z: -1 },
        { x: 1, z: 0 },
        { x: 0, z: 1 },
        { x: -1, z: 0 }
      ];

      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i -= 1) {
          const j = Math.floor(rand() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }

      function carve(x, z) {
        grid[z][x] = 0;
        const order = dirs.slice();
        shuffle(order);
        for (const dir of order) {
          const nx = x + dir.x * 2;
          const nz = z + dir.z * 2;
          if (nx > 0 && nx < size - 1 && nz > 0 && nz < size - 1 && grid[nz][nx] === 1) {
            grid[z + dir.z][x + dir.x] = 0;
            carve(nx, nz);
          }
        }
      }

      const center = Math.floor(size / 2);
      carve(center, center);

      function openCorridor(x, z, dx, dz) {
        while (x >= 0 && x < size && z >= 0 && z < size) {
          grid[z][x] = 0;
          if (x === center && z === center) break;
          x += dx;
          z += dz;
        }
      }

      if (openings.n) openCorridor(center, 0, 0, 1);
      if (openings.s) openCorridor(center, size - 1, 0, -1);
      if (openings.w) openCorridor(0, center, 1, 0);
      if (openings.e) openCorridor(size - 1, center, -1, 0);

      grid[center][center] = 0;
      return grid;
    }

    function createGridLines(width, height, divisionsW, divisionsH, color = 0x000000) {
      const vertices = [];
      const stepW = width / divisionsW;
      const stepH = height / divisionsH;
      const halfW = width / 2;
      const halfH = height / 2;

      for (let i = 0; i <= divisionsW; i += 1) {
        const x = -halfW + stepW * i;
        vertices.push(x, -halfH, 0, x, halfH, 0);
      }
      for (let j = 0; j <= divisionsH; j += 1) {
        const y = -halfH + stepH * j;
        vertices.push(-halfW, y, 0, halfW, y, 0);
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
      const material = new THREE.LineBasicMaterial({
        color,
        transparent: true,
        opacity: 0.55
      });
      return new THREE.LineSegments(geometry, material);
    }

    function createRoom(center, openings, color, blockBoxes, gridColor = 0x000000) {
      const roomMat = createMaterial(color);
      const group = new THREE.Group();
      const yCenter = roomHeight / 2;

      const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), roomMat);
      floor.rotation.x = -Math.PI / 2;
      floor.position.set(center.x, 0, center.z);
      group.add(floor);

      const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), roomMat);
      ceiling.rotation.x = Math.PI / 2;
      ceiling.position.set(center.x, roomHeight, center.z);
      group.add(ceiling);

      const floorGrid = createGridLines(roomSize, roomSize, roomSize, roomSize, gridColor);
      floorGrid.rotation.x = -Math.PI / 2;
      floorGrid.position.set(center.x, 0.1, center.z);
      group.add(floorGrid);

      const ceilingGrid = createGridLines(roomSize, roomSize, roomSize, roomSize, gridColor);
      ceilingGrid.rotation.x = Math.PI / 2;
      ceilingGrid.position.set(center.x, roomHeight - 0.1, center.z);
      group.add(ceilingGrid);

      if (!openings.n) {
        const north = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), roomMat);
        north.position.set(center.x, yCenter, center.z - half);
        group.add(north);

        const northGrid = createGridLines(roomSize, roomHeight, roomSize, roomHeight, gridColor);
        northGrid.position.set(center.x, yCenter, center.z - half + 0.1);
        group.add(northGrid);
      }

      if (!openings.s) {
        const south = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), roomMat);
        south.rotation.y = Math.PI;
        south.position.set(center.x, yCenter, center.z + half);
        group.add(south);

        const southGrid = createGridLines(roomSize, roomHeight, roomSize, roomHeight, gridColor);
        southGrid.rotation.y = Math.PI;
        southGrid.position.set(center.x, yCenter, center.z + half - 0.1);
        group.add(southGrid);
      }

      if (!openings.w) {
        const west = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), roomMat);
        west.rotation.y = Math.PI / 2;
        west.position.set(center.x - half, yCenter, center.z);
        group.add(west);

        const westGrid = createGridLines(roomSize, roomHeight, roomSize, roomHeight, gridColor);
        westGrid.rotation.y = Math.PI / 2;
        westGrid.position.set(center.x - half + 0.1, yCenter, center.z);
        group.add(westGrid);
      }

      if (!openings.e) {
        const east = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), roomMat);
        east.rotation.y = -Math.PI / 2;
        east.position.set(center.x + half, yCenter, center.z);
        group.add(east);

        const eastGrid = createGridLines(roomSize, roomHeight, roomSize, roomHeight, gridColor);
        eastGrid.rotation.y = -Math.PI / 2;
        eastGrid.position.set(center.x + half - 0.1, yCenter, center.z);
        group.add(eastGrid);
      }

      const blockMat = createMaterial(color);
      for (const box of blockBoxes) {
        const width = box.maxX - box.minX;
        const height = box.maxY - box.minY;
        const depth = box.maxZ - box.minZ;
        const blockGeo = new THREE.BoxGeometry(width, height, depth);
        const block = new THREE.Mesh(blockGeo, blockMat);
        block.position.set(
          (box.minX + box.maxX) / 2,
          (box.minY + box.maxY) / 2,
          (box.minZ + box.maxZ) / 2
        );
        group.add(block);
      }

      scene.add(group);
    }

    const offset = roomSize;
    const rooms = [
      { x: 0, z: 0, openings: { n: true, s: true, w: true, e: true } },
      { x: 0, z: -offset, openings: { n: true, s: true, w: false, e: false } },
      { x: offset, z: 0, openings: { n: false, s: false, w: true, e: true } },
      { x: 0, z: offset, openings: { n: true, s: true, w: false, e: false } },
      { x: -offset, z: 0, openings: { n: false, s: false, w: true, e: true } },
      { x: 0, z: -offset * 2, openings: { n: false, s: true, w: false, e: false } },
      { x: offset * 2, z: 0, openings: { n: false, s: false, w: true, e: false } },
      { x: 0, z: offset * 2, openings: { n: true, s: false, w: false, e: false } },
      { x: -offset * 2, z: 0, openings: { n: false, s: false, w: false, e: true } }
    ];

    const roomColors = [0xffffff, 0xff4b4b, 0xffd93d, 0x43d66d, 0x3aa0ff, 0x7a7a7a, 0x7a7a7a, 0x7a7a7a, 0x7a7a7a];
    const roomGridColors = [0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0xff4b4b, 0xffd93d, 0x43d66d, 0x3aa0ff];
    const roomDisplayNames = {
      5: "피닉스 레어",
      6: "라이거 레어",
      7: "현무 레어",
      8: "드라군 레어"
    };
      const roomSeeds = [101, 202, 303, 404, 505, 606, 707, 808, 909];
      let destructibleBlocks = [];
    const worldHalfX = Math.max(...rooms.map((room) => Math.abs(room.x))) + half;
    const worldHalfZ = Math.max(...rooms.map((room) => Math.abs(room.z))) + half;

    // Maze blocks removed per request.

      rooms.forEach((room, index) => {
        const baseSeed = roomSeeds[index];
        room.mazeLayers = [];
        room.blockBoxes = [];
        room.destructibles = [];
        room.destructibleSlots = [];
        room.destructibleOccupied = new Set();
        createRoom(
          new THREE.Vector3(room.x, 0, room.z),
          room.openings,
          roomColors[index],
          room.blockBoxes,
          roomGridColors[index] || 0x000000
        );
      });

      const destructibleSpawnTimers = new Map();
      const destructibleBlockSize = 0.9;

      function buildDestructibleSlots(roomIndex) {
        const room = rooms[roomIndex];
        const margin = 0.6;
        const slots = [];
        const step = 6;
        const minX = room.x - half + margin;
        const maxX = room.x + half - margin;
        const minZ = room.z - half + margin;
        const maxZ = room.z + half - margin;
        const floorYSlot = floorY + destructibleBlockSize * 0.5;
        const ceilYSlot = ceilingY - destructibleBlockSize * 0.5;

        for (let x = minX; x <= maxX; x += step) {
          for (let z = minZ; z <= maxZ; z += step) {
            slots.push(new THREE.Vector3(x, floorYSlot, z));
            slots.push(new THREE.Vector3(x, ceilYSlot, z));
          }
        }
        for (let y = floorYSlot + step; y <= ceilYSlot - step; y += step) {
          for (let z = minZ; z <= maxZ; z += step) {
            slots.push(new THREE.Vector3(minX, y, z));
            slots.push(new THREE.Vector3(maxX, y, z));
          }
          for (let x = minX; x <= maxX; x += step) {
            slots.push(new THREE.Vector3(x, y, minZ));
            slots.push(new THREE.Vector3(x, y, maxZ));
          }
        }
        if (slots.length > 600) {
          slots.length = 600;
        }
        return slots;
      }

      function spawnDestructibleInRoom(roomIndex) {
        if (destructibleBlocks.length >= 200) return;
        const room = rooms[roomIndex];
        if (!room.destructibleSlots || room.destructibleSlots.length === 0) return;
        if (room.destructibleOccupied.size >= room.destructibleSlots.length) return;
        let slotIndex = Math.floor(Math.random() * room.destructibleSlots.length);
        let safety = 0;
        while (room.destructibleOccupied.has(slotIndex) && safety < room.destructibleSlots.length) {
          slotIndex = (slotIndex + 1) % room.destructibleSlots.length;
          safety += 1;
        }
        if (room.destructibleOccupied.has(slotIndex)) return;
        const pos = room.destructibleSlots[slotIndex];
        const mesh = new THREE.Mesh(
          new THREE.BoxGeometry(destructibleBlockSize, destructibleBlockSize, destructibleBlockSize),
          new THREE.MeshStandardMaterial({ color: roomColors[roomIndex], roughness: 0.7, metalness: 0.1 })
        );
        mesh.position.copy(pos);
        scene.add(mesh);
        const block = {
          mesh,
          ap: 5000,
          pa: 1000,
          roomIndex,
          slotIndex,
          defense: { en: 140, ballistic: 140, explosive: 140 }
        };
        const box = {
          minX: pos.x - destructibleBlockSize * 0.5,
          maxX: pos.x + destructibleBlockSize * 0.5,
          minY: pos.y - destructibleBlockSize * 0.5,
          maxY: pos.y + destructibleBlockSize * 0.5,
          minZ: pos.z - destructibleBlockSize * 0.5,
          maxZ: pos.z + destructibleBlockSize * 0.5,
          destructible: block
        };
        block.box = box;
        room.blockBoxes.push(box);
        room.destructibles.push(block);
        room.destructibleOccupied.add(slotIndex);
        destructibleBlocks.push(block);
      }

      function initDestructibles() {
        for (let i = 1; i <= 4; i += 1) {
          rooms[i].destructibleSlots = buildDestructibleSlots(i);
          const initialCount = 12 + Math.floor(Math.random() * 13);
          for (let j = 0; j < initialCount; j += 1) {
            spawnDestructibleInRoom(i);
          }
          destructibleSpawnTimers.set(i, performance.now() / 1000 + 10 + Math.random() * 50);
        }
      }
      initDestructibles();

      const enemyRadius = playerSize * 0.5;
      const enemyTypes = [
        { roomIndex: 1, color: 0xff4b4b, ballSubtype: "shock", beamSubtype: "flash", defense: { en: 260, ballistic: 180, explosive: 180 } },
        { roomIndex: 2, color: 0xffd93d, ballSubtype: "freeze", beamSubtype: "laser", defense: { en: 180, ballistic: 260, explosive: 180 } },
        { roomIndex: 3, color: 0x43d66d, ballSubtype: "acid", beamSubtype: "kojima", defense: { en: 180, ballistic: 180, explosive: 260 } },
        { roomIndex: 4, color: 0x3aa0ff, ballSubtype: "smoke", beamSubtype: "flash", defense: { en: 220, ballistic: 220, explosive: 220 } }
      ];
      const enemies = [];
      const bosses = [];
      const bossCoreDrops = [];
      const bossCoreNames = ["피닉스 코어", "라이거 코어", "현무 코어", "드라군 코어"];
      const bossCoreInventory = Object.fromEntries(bossCoreNames.map((name) => [name, 0]));
      const bossCoreCodexUnlocked = Object.fromEntries(bossCoreNames.map((name) => [name, false]));
      const codexBossUnlockByCore = {
        피닉스: "피닉스 코어",
        라이거: "라이거 코어",
        현무: "현무 코어",
        드라군: "드라군 코어"
      };
      const bossEggs = [];
      const enemyProjectiles = [];
      const enemyBeams = [];
      const bossTelegraphs = [];
      const explosionFields = [];
      const floatingTexts = [];
      const enemySpawnTimers = new Map();
      const enemyMoveSpeed = 3;
      const enemyAvoidRadius = 2;
      const bossMoveSpeed = enemyMoveSpeed * 1.6;

      function createBossLabel() {
        const label = document.createElement("div");
        label.className = "enemyLabel";
        label.textContent = "BOSS AP 1000000 / PA 50000";
        document.body.appendChild(label);
        return label;
      }

      function buildPhoenixBossModel() {
        const g = new THREE.Group();
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff4938, emissive: 0x821811, roughness: 0.35, metalness: 0.28 });
        const featherMat = new THREE.MeshStandardMaterial({ color: 0xff8f2f, emissive: 0x8a3000, roughness: 0.24, metalness: 0.12 });
        const darkMat = new THREE.MeshStandardMaterial({ color: 0x5c1b1b, roughness: 0.62, metalness: 0.2 });
        const beakMat = new THREE.MeshStandardMaterial({ color: 0xffc16a, roughness: 0.45, metalness: 0.08 });
        const eyeMat = new THREE.MeshStandardMaterial({ color: 0xfff0a0, emissive: 0xffaa55, roughness: 0.2 });

        const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.34, 1.7, 8, 16), bodyMat);
        body.rotation.set(Math.PI / 2, 0, 0);
        body.position.set(0, 0.25, 0.1);
        body.scale.set(1, 1, 0.62);

        const chest = new THREE.Mesh(new THREE.SphereGeometry(0.46, 22, 18), featherMat);
        chest.position.set(0, 0.22, -0.62);
        chest.scale.set(0.84, 0.62, 1.05);

        const neck = new THREE.Mesh(new THREE.CapsuleGeometry(0.14, 0.72, 6, 12), bodyMat);
        neck.rotation.x = Math.PI / 2;
        neck.position.set(0, 0.38, -1.02);
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.34, 22, 16), bodyMat);
        head.position.set(0, 0.52, -1.52);
        const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.045, 10, 10), eyeMat);
        eyeL.position.set(-0.12, 0.58, -1.76);
        const eyeR = eyeL.clone();
        eyeR.position.x = 0.12;
        const beakTop = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.54, 10), beakMat);
        beakTop.rotation.x = Math.PI / 2;
        beakTop.position.set(0, 0.48, -1.96);
        const beakBottom = new THREE.Mesh(new THREE.ConeGeometry(0.07, 0.34, 10), new THREE.MeshStandardMaterial({ color: 0xde9d4d, roughness: 0.5 }));
        beakBottom.rotation.x = Math.PI / 2;
        beakBottom.position.set(0, 0.37, -1.81);

        const crestCenter = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.5, 10), featherMat);
        crestCenter.position.set(0, 0.98, -1.48);
        const crestL = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.42, 10), featherMat);
        crestL.position.set(-0.11, 0.88, -1.45);
        crestL.rotation.z = -0.34;
        const crestR = crestL.clone();
        crestR.position.x = 0.11;
        crestR.rotation.z = 0.34;

        const wingArmL = new THREE.Mesh(new THREE.CapsuleGeometry(0.12, 1.35, 6, 12), darkMat);
        wingArmL.rotation.z = -1.18;
        wingArmL.rotation.y = 0.26;
        wingArmL.position.set(-0.88, 0.16, -0.1);
        const wingArmR = wingArmL.clone();
        wingArmR.rotation.z = 1.18;
        wingArmR.position.x = 0.88;

        const wingTipL = new THREE.Mesh(new THREE.CapsuleGeometry(0.08, 1.1, 6, 10), darkMat);
        wingTipL.rotation.z = -1.34;
        wingTipL.rotation.y = 0.45;
        wingTipL.position.set(-1.72, -0.12, -0.02);
        const wingTipR = wingTipL.clone();
        wingTipR.rotation.z = 1.34;
        wingTipR.position.x = 1.72;

        const wingFeathers = [];
        for (let i = 0; i < 6; i += 1) {
          const feather = new THREE.Mesh(new THREE.ConeGeometry(0.12 + i * 0.02, 0.7 + i * 0.12, 10), featherMat);
          feather.rotation.z = -Math.PI / 2;
          feather.rotation.y = 0.45 + i * 0.07;
          feather.position.set(-1.1 - i * 0.18, -0.1 - i * 0.07, 0.14 + i * 0.05);
          wingFeathers.push(feather);
          const mirror = feather.clone();
          mirror.rotation.z = Math.PI / 2;
          mirror.position.x = -feather.position.x;
          wingFeathers.push(mirror);
        }
        const wingInnerFeathers = [];
        for (let i = 0; i < 4; i += 1) {
          const inner = new THREE.Mesh(new THREE.ConeGeometry(0.1 + i * 0.015, 0.56 + i * 0.09, 10), new THREE.MeshStandardMaterial({ color: 0xffb247, emissive: 0x8c3200, roughness: 0.22, metalness: 0.1 }));
          inner.rotation.z = -Math.PI / 2;
          inner.rotation.y = 0.55 + i * 0.06;
          inner.position.set(-0.86 - i * 0.16, 0.03 - i * 0.05, -0.12 + i * 0.06);
          wingInnerFeathers.push(inner);
          const mirror = inner.clone();
          mirror.rotation.z = Math.PI / 2;
          mirror.position.x = -inner.position.x;
          wingInnerFeathers.push(mirror);
        }

        const legL = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.06, 0.58, 8), darkMat);
        legL.position.set(-0.22, -0.28, 0.08);
        const legR = legL.clone();
        legR.position.x = 0.22;
        const clawL = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.24, 8), beakMat);
        clawL.rotation.x = Math.PI;
        clawL.position.set(-0.22, -0.62, -0.02);
        const clawR = clawL.clone();
        clawR.position.x = 0.22;

        const tailBase = new THREE.Mesh(new THREE.CapsuleGeometry(0.12, 0.85, 6, 10), darkMat);
        tailBase.rotation.x = -Math.PI / 2;
        tailBase.position.set(0, 0.04, 1.2);
        const tailFan = [];
        for (let i = -2; i <= 2; i += 1) {
          const tailFeather = new THREE.Mesh(new THREE.ConeGeometry(0.13 + Math.abs(i) * 0.02, 1.0 + Math.abs(i) * 0.15, 12), featherMat);
          tailFeather.rotation.x = -Math.PI / 2;
          tailFeather.position.set(i * 0.16, 0.1 + Math.abs(i) * 0.03, 1.82 + Math.abs(i) * 0.08);
          tailFan.push(tailFeather);
        }
        const tailTip = new THREE.Mesh(new THREE.ConeGeometry(0.14, 0.82, 12), new THREE.MeshStandardMaterial({ color: 0xff4a1f, emissive: 0xb81f00 }));
        tailTip.rotation.x = -Math.PI / 2;
        tailTip.position.set(0, 0.14, 2.42);
        const tailFlare = new THREE.Mesh(new THREE.TorusGeometry(0.2, 0.05, 10, 20), new THREE.MeshStandardMaterial({ color: 0xff9a39, emissive: 0xff5a22, roughness: 0.25, metalness: 0.08 }));
        tailFlare.rotation.x = Math.PI / 2;
        tailFlare.position.set(0, 0.17, 2.7);
        const chestRing = new THREE.Mesh(new THREE.TorusGeometry(0.34, 0.045, 10, 22), new THREE.MeshStandardMaterial({ color: 0xffb25a, emissive: 0x8a3608, roughness: 0.28, metalness: 0.12 }));
        chestRing.rotation.x = Math.PI / 2;
        chestRing.position.set(0, 0.27, -0.7);
        const wingAuraL = new THREE.Mesh(new THREE.ConeGeometry(0.09, 0.46, 10), new THREE.MeshStandardMaterial({ color: 0xffad4d, emissive: 0xa83f09, roughness: 0.22, metalness: 0.08 }));
        wingAuraL.rotation.z = -Math.PI / 2;
        wingAuraL.position.set(-1.35, 0.05, -0.16);
        const wingAuraR = wingAuraL.clone();
        wingAuraR.rotation.z = Math.PI / 2;
        wingAuraR.position.x = 1.35;

        g.add(body, chest, neck, head, eyeL, eyeR, beakTop, beakBottom, crestCenter, crestL, crestR, wingArmL, wingArmR, wingTipL, wingTipR, ...wingFeathers, ...wingInnerFeathers, legL, legR, clawL, clawR, tailBase, ...tailFan, tailTip, tailFlare, chestRing, wingAuraL, wingAuraR);
        g.userData.core = body;
        g.userData.anim = {
          type: "phoenix",
          wingL: wingArmL,
          wingR: wingArmR,
          wingTipL,
          wingTipR,
          head,
          tail: tailBase,
          tailTip,
          tailFlare,
          chestRing,
          wingAuraL,
          wingAuraR,
          legL,
          legR
        };
        g.scale.setScalar(3);
        return g;
      }

      function buildLigerBossModel() {
        const g = new THREE.Group();
        const furMat = new THREE.MeshStandardMaterial({ color: 0xffd93d, emissive: 0x4a3a00, roughness: 0.62, metalness: 0.15 });
        const stripeMat = new THREE.MeshStandardMaterial({ color: 0x6e4f00, roughness: 0.55, metalness: 0.18 });
        const fangMat = new THREE.MeshStandardMaterial({ color: 0xf9f9f9, roughness: 0.33, metalness: 0.04 });
        const eyeMat = new THREE.MeshStandardMaterial({ color: 0xfff58f, emissive: 0xffd84a, roughness: 0.25 });

        const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.34, 2.35, 8, 16), furMat);
        body.rotation.set(Math.PI / 2, 0, 0);
        body.position.set(0, 0.36, 0.08);
        body.scale.set(0.82, 0.95, 0.5);
        const chest = new THREE.Mesh(new THREE.SphereGeometry(0.34, 18, 14), furMat);
        chest.position.set(0, 0.44, -0.7);
        chest.scale.set(0.86, 0.82, 0.88);
        const hip = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 14), furMat);
        hip.position.set(0, 0.34, 1.02);
        hip.scale.set(0.84, 0.8, 0.84);

        const neck = new THREE.Mesh(new THREE.CapsuleGeometry(0.12, 0.55, 6, 10), furMat);
        neck.rotation.x = Math.PI / 2;
        neck.position.set(0, 0.47, -1.16);
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.64, 0.84), furMat);
        head.position.set(0, 0.55, -1.62);
        const snout = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.26, 0.48), furMat);
        snout.position.set(0, 0.39, -2.02);
        const jaw = new THREE.Mesh(new THREE.BoxGeometry(0.38, 0.12, 0.42), new THREE.MeshStandardMaterial({ color: 0xd9be3a, roughness: 0.55 }));
        jaw.position.set(0, 0.28, -1.95);
        const earL = new THREE.Mesh(new THREE.ConeGeometry(0.07, 0.16, 8), furMat);
        earL.position.set(-0.24, 0.88, -1.62);
        const earR = earL.clone();
        earR.position.x = 0.24;
        const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.05, 10, 10), eyeMat);
        eyeL.position.set(-0.16, 0.58, -2.0);
        const eyeR = eyeL.clone();
        eyeR.position.x = 0.16;
        const nose = new THREE.Mesh(new THREE.SphereGeometry(0.055, 10, 10), new THREE.MeshStandardMaterial({ color: 0x2b1b12, roughness: 0.45 }));
        nose.position.set(0, 0.46, -2.2);
        const fangL = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.42, 8), fangMat);
        fangL.rotation.x = Math.PI;
        fangL.position.set(-0.14, 0.18, -2.08);
        const fangR = fangL.clone();
        fangR.position.x = 0.14;
        const whiskers = [];
        for (let side of [-1, 1]) {
          for (let row = 0; row < 3; row += 1) {
            const w = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.35, 6), new THREE.MeshStandardMaterial({ color: 0xf0dfab, roughness: 0.4 }));
            w.rotation.z = side * (Math.PI / 2 + 0.2 - row * 0.14);
            w.position.set(side * 0.26, 0.42 - row * 0.06, -2.08 + row * 0.03);
            whiskers.push(w);
          }
        }

        const stripeParts = [];
        for (let i = 0; i < 6; i += 1) {
          const stripe = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.18, 0.5 - i * 0.04), stripeMat);
          stripe.position.set(0, 0.62, -0.55 + i * 0.36);
          stripeParts.push(stripe);
        }
        const shoulderSpikes = [];
        for (let side of [-1, 1]) {
          for (let i = 0; i < 3; i += 1) {
            const spike = new THREE.Mesh(new THREE.ConeGeometry(0.04 + i * 0.01, 0.16 + i * 0.03, 8), stripeMat);
            spike.rotation.z = side * (0.55 + i * 0.16);
            spike.position.set(side * (0.34 + i * 0.07), 0.78 - i * 0.05, -0.92 + i * 0.2);
            shoulderSpikes.push(spike);
          }
        }

        const legUpperGeo = new THREE.CapsuleGeometry(0.09, 0.42, 4, 8);
        const legLowerGeo = new THREE.CapsuleGeometry(0.08, 0.34, 4, 8);
        const pawsGeo = new THREE.SphereGeometry(0.11, 10, 10);
        const legs = [];
        const bases = [
          new THREE.Vector3(-0.44, 0.0, -0.72),
          new THREE.Vector3(0.44, 0.0, -0.72),
          new THREE.Vector3(-0.44, 0.0, 0.78),
          new THREE.Vector3(0.44, 0.0, 0.78)
        ];
        for (const base of bases) {
          const upper = new THREE.Mesh(legUpperGeo, furMat);
          upper.position.copy(base.clone().add(new THREE.Vector3(0, -0.12, 0)));
          const lower = new THREE.Mesh(legLowerGeo, furMat);
          lower.position.copy(base.clone().add(new THREE.Vector3(0, -0.46, 0.03)));
          const paw = new THREE.Mesh(pawsGeo, furMat);
          paw.position.copy(base.clone().add(new THREE.Vector3(0, -0.66, -0.02)));
          legs.push(upper, lower, paw);
        }

        const mane = new THREE.Mesh(new THREE.TorusGeometry(0.42, 0.08, 12, 28), new THREE.MeshStandardMaterial({ color: 0xffef93, emissive: 0x665500 }));
        mane.rotation.x = Math.PI / 2;
        mane.position.set(0, 0.56, -1.28);

        const tailBase = new THREE.Mesh(new THREE.CapsuleGeometry(0.09, 0.65, 6, 10), furMat);
        tailBase.rotation.x = Math.PI / 2;
        tailBase.position.set(0, 0.42, 1.48);
        const bolt1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.56), new THREE.MeshStandardMaterial({ color: 0xfff474, emissive: 0xaa9c22 }));
        bolt1.position.set(0.1, 0.64, 1.92);
        const bolt2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.48), new THREE.MeshStandardMaterial({ color: 0xfff474, emissive: 0xaa9c22 }));
        bolt2.position.set(-0.08, 0.84, 2.24);
        const bolt3 = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.09, 0.4), new THREE.MeshStandardMaterial({ color: 0xfff474, emissive: 0xaa9c22 }));
        bolt3.position.set(0.06, 1.0, 2.5);
        const tailArc = new THREE.Mesh(new THREE.TorusGeometry(0.16, 0.035, 8, 16), new THREE.MeshStandardMaterial({ color: 0xfff0a6, emissive: 0x9f8a2f, roughness: 0.35, metalness: 0.15 }));
        tailArc.rotation.x = Math.PI / 2;
        tailArc.position.set(0.05, 1.12, 2.72);
        const backRidge = [];
        for (let i = 0; i < 5; i += 1) {
          const ridge = new THREE.Mesh(new THREE.ConeGeometry(0.045, 0.18, 8), stripeMat);
          ridge.rotation.x = Math.PI;
          ridge.position.set(0, 0.78 - i * 0.05, -0.3 + i * 0.58);
          backRidge.push(ridge);
        }

        g.add(body, chest, hip, neck, head, snout, jaw, earL, earR, eyeL, eyeR, nose, fangL, fangR, ...whiskers, mane, ...stripeParts, ...shoulderSpikes, ...legs, ...backRidge, tailBase, bolt1, bolt2, bolt3, tailArc);
        g.userData.core = body;
        g.userData.anim = {
          type: "liger",
          head,
          shoulder: chest,
          tail: tailBase,
          bolt1,
          bolt2,
          bolt3,
          tailArc,
          legFrontL: legs[0],
          legFrontR: legs[3],
          jaw
        };
        g.scale.setScalar(3);
        return g;
      }

      function buildHyunmuBossModel() {
        const g = new THREE.Group();
        const shellMat = new THREE.MeshStandardMaterial({ color: 0x43d66d, emissive: 0x0f4b1f, roughness: 0.42, metalness: 0.25 });
        const plateMat = new THREE.MeshStandardMaterial({ color: 0x2f964f, roughness: 0.6, metalness: 0.2 });
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2a7d40, roughness: 0.68, metalness: 0.12 });
        const shell = new THREE.Mesh(new THREE.SphereGeometry(1.12, 24, 20), shellMat);
        shell.scale.set(1.35, 0.75, 1.35);
        shell.position.y = 0.48;
        const ring = new THREE.Mesh(new THREE.TorusGeometry(0.86, 0.08, 10, 24), plateMat);
        ring.rotation.x = Math.PI / 2;
        ring.position.y = 0.53;
        const shellSpikes = [];
        for (let i = 0; i < 8; i += 1) {
          const spike = new THREE.Mesh(new THREE.ConeGeometry(0.07, 0.2, 8), plateMat);
          const a = (Math.PI * 2 * i) / 8;
          spike.position.set(Math.cos(a) * 0.75, 0.87, Math.sin(a) * 0.75);
          shellSpikes.push(spike);
        }
        const shellHexes = [];
        for (let i = 0; i < 10; i += 1) {
          const plate = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.09, 0.04, 6), new THREE.MeshStandardMaterial({ color: 0x58d279, emissive: 0x1d6a38, roughness: 0.5, metalness: 0.25 }));
          const a = (Math.PI * 2 * i) / 10;
          const r = i % 2 === 0 ? 0.42 : 0.62;
          plate.position.set(Math.cos(a) * r, 0.9, Math.sin(a) * r);
          plate.rotation.y = a;
          shellHexes.push(plate);
        }
        const shellRidges = [];
        for (let i = 0; i < 6; i += 1) {
          const ridge = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.12, 0.4), plateMat);
          ridge.position.set(0, 0.98 - i * 0.03, -0.74 + i * 0.29);
          ridge.rotation.x = -0.16;
          shellRidges.push(ridge);
        }
        const body = new THREE.Mesh(new THREE.BoxGeometry(1.75, 0.5, 1.65), bodyMat);
        body.position.y = 0.15;
        const bellyPlate = new THREE.Mesh(new THREE.BoxGeometry(1.22, 0.2, 1.08), new THREE.MeshStandardMaterial({ color: 0x7de894, emissive: 0x285f35, roughness: 0.62, metalness: 0.1 }));
        bellyPlate.position.set(0, -0.02, 0.02);
        const neck = new THREE.Mesh(new THREE.CapsuleGeometry(0.14, 0.38, 6, 10), bodyMat);
        neck.rotation.x = Math.PI / 2;
        neck.position.set(0, 0.28, -1.02);
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.34, 14, 12), bodyMat);
        head.position.set(0, 0.3, -1.28);
        const jaw = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.12, 0.26), bodyMat);
        jaw.position.set(0, 0.16, -1.5);
        const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.05, 10, 10), new THREE.MeshStandardMaterial({ color: 0xa8ffb2, emissive: 0x44aa55 }));
        eyeL.position.set(-0.12, 0.36, -1.53);
        const eyeR = eyeL.clone();
        eyeR.position.x = 0.12;
        const legGeo = new THREE.CylinderGeometry(0.16, 0.19, 0.55, 8);
        const legs = [new THREE.Mesh(legGeo, bodyMat), new THREE.Mesh(legGeo, bodyMat), new THREE.Mesh(legGeo, bodyMat), new THREE.Mesh(legGeo, bodyMat)];
        legs[0].position.set(-0.75, -0.05, -0.62);
        legs[1].position.set(0.75, -0.05, -0.62);
        legs[2].position.set(-0.75, -0.05, 0.62);
        legs[3].position.set(0.75, -0.05, 0.62);
        const longTail1 = new THREE.Mesh(new THREE.CapsuleGeometry(0.11, 0.95, 6, 10), plateMat);
        longTail1.rotation.x = Math.PI / 2;
        longTail1.position.set(0, 0.26, 1.52);
        const longTail2 = new THREE.Mesh(new THREE.CapsuleGeometry(0.09, 0.85, 6, 10), plateMat);
        longTail2.rotation.x = Math.PI / 2;
        longTail2.position.set(0, 0.34, 2.28);
        const longTail3 = new THREE.Mesh(new THREE.CapsuleGeometry(0.07, 0.72, 6, 10), new THREE.MeshStandardMaterial({ color: 0x69ff88, emissive: 0x1c6c2f }));
        longTail3.rotation.x = Math.PI / 2;
        longTail3.position.set(0, 0.42, 2.95);
        const tailFinL = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.38, 8), plateMat);
        tailFinL.rotation.z = Math.PI / 2;
        tailFinL.position.set(-0.14, 0.56, 3.3);
        const tailFinR = tailFinL.clone();
        tailFinR.rotation.z = -Math.PI / 2;
        tailFinR.position.x = 0.14;
        const neckSpikes = [];
        for (let i = 0; i < 3; i += 1) {
          const spike = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.16, 8), plateMat);
          spike.position.set(0, 0.42 + i * 0.07, -0.95 - i * 0.18);
          neckSpikes.push(spike);
        }
        g.add(shell, ring, body, bellyPlate, neck, head, jaw, eyeL, eyeR, ...shellSpikes, ...shellHexes, ...shellRidges, ...legs, ...neckSpikes, longTail1, longTail2, longTail3, tailFinL, tailFinR);
        g.userData.core = shell;
        g.userData.anim = {
          type: "hyunmu",
          head,
          neck,
          tail1: longTail1,
          tail2: longTail2,
          tail3: longTail3,
          tailFinL,
          tailFinR,
          legA: legs[0],
          legB: legs[1]
        };
        g.scale.setScalar(3);
        return g;
      }

      function buildDragoonBossModel() {
        const g = new THREE.Group();
        const scaleMat = new THREE.MeshStandardMaterial({ color: 0x3aa0ff, emissive: 0x123f88, roughness: 0.45, metalness: 0.35 });
        const plateMat = new THREE.MeshStandardMaterial({ color: 0x2d7fd0, roughness: 0.5, metalness: 0.4 });
        const hornMat = new THREE.MeshStandardMaterial({ color: 0xb8e2ff, emissive: 0x3a6ea8, roughness: 0.35, metalness: 0.25 });
        const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.36, 2.8, 8, 16), scaleMat);
        body.rotation.set(Math.PI / 2, 0, 0);
        body.position.set(0, 0.52, 0.2);
        const torsoPlate = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.34, 1.8), plateMat);
        torsoPlate.position.set(0, 0.68, 0.18);
        const neck1 = new THREE.Mesh(new THREE.CapsuleGeometry(0.2, 0.8, 6, 10), scaleMat);
        neck1.rotation.x = Math.PI / 2;
        neck1.position.set(0, 0.78, -1.15);
        const neck2 = new THREE.Mesh(new THREE.CapsuleGeometry(0.16, 0.65, 6, 10), scaleMat);
        neck2.rotation.x = Math.PI / 2;
        neck2.position.set(0, 0.95, -1.78);
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.76, 0.56, 0.95), scaleMat);
        head.position.set(0, 1.08, -2.26);
        const snout = new THREE.Mesh(new THREE.BoxGeometry(0.46, 0.26, 0.62), scaleMat);
        snout.position.set(0, 0.98, -2.84);
        const jaw = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.16, 0.56), plateMat);
        jaw.position.set(0, 0.84, -2.74);
        const teeth = [];
        for (let i = -2; i <= 2; i += 1) {
          const tooth = new THREE.Mesh(new THREE.ConeGeometry(0.025, 0.13, 6), new THREE.MeshStandardMaterial({ color: 0xe4f4ff, roughness: 0.35 }));
          tooth.rotation.x = Math.PI;
          tooth.position.set(i * 0.08, 0.76, -2.96);
          teeth.push(tooth);
        }
        const hornL = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.7, 8), hornMat);
        const hornR = hornL.clone();
        hornL.rotation.x = -Math.PI / 6;
        hornR.rotation.x = -Math.PI / 6;
        hornL.position.set(-0.24, 1.44, -2.42);
        hornR.position.set(0.24, 1.44, -2.42);
        const browL = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.28, 8), hornMat);
        browL.rotation.x = -Math.PI / 3;
        browL.position.set(-0.16, 1.23, -2.86);
        const browR = browL.clone();
        browR.position.x = 0.16;
        const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.06, 10, 10), new THREE.MeshStandardMaterial({ color: 0xd7f5ff, emissive: 0x63b8ff }));
        eyeL.position.set(-0.18, 1.1, -2.9);
        const eyeR = eyeL.clone();
        eyeR.position.x = 0.18;
        const wingMat = new THREE.MeshStandardMaterial({ color: 0x5fb6ff, emissive: 0x1a4f88, roughness: 0.5, metalness: 0.18 });
        const wingBoneL = new THREE.Mesh(new THREE.CapsuleGeometry(0.11, 1.45, 6, 10), plateMat);
        wingBoneL.rotation.z = -1.05;
        wingBoneL.position.set(-0.95, 0.92, -0.28);
        const wingBoneR = wingBoneL.clone();
        wingBoneR.rotation.z = 1.05;
        wingBoneR.position.x = 0.95;
        const wingMemL1 = new THREE.Mesh(new THREE.ConeGeometry(0.34, 1.85, 14), wingMat);
        wingMemL1.rotation.z = -Math.PI / 2;
        wingMemL1.rotation.y = 0.52;
        wingMemL1.position.set(-1.72, 0.72, -0.22);
        const wingMemL2 = new THREE.Mesh(new THREE.ConeGeometry(0.26, 1.4, 12), wingMat);
        wingMemL2.rotation.z = -Math.PI / 2;
        wingMemL2.rotation.y = 0.76;
        wingMemL2.position.set(-1.45, 0.48, 0.22);
        const wingMemR1 = wingMemL1.clone();
        wingMemR1.rotation.z = Math.PI / 2;
        wingMemR1.position.x = 1.72;
        const wingMemR2 = wingMemL2.clone();
        wingMemR2.rotation.z = Math.PI / 2;
        wingMemR2.position.x = 1.45;
        const wingFingerL = [];
        const wingFingerR = [];
        for (let i = 0; i < 3; i += 1) {
          const finger = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.03, 1.1 + i * 0.2, 6), hornMat);
          finger.rotation.z = -1.2 + i * 0.22;
          finger.position.set(-1.36 - i * 0.15, 0.88 - i * 0.1, -0.1 + i * 0.22);
          wingFingerL.push(finger);
          const mirror = finger.clone();
          mirror.rotation.z = -finger.rotation.z;
          mirror.position.x = -finger.position.x;
          wingFingerR.push(mirror);
        }
        const legGeo = new THREE.CylinderGeometry(0.11, 0.14, 0.66, 8);
        const legs = [new THREE.Mesh(legGeo, scaleMat), new THREE.Mesh(legGeo, scaleMat), new THREE.Mesh(legGeo, scaleMat), new THREE.Mesh(legGeo, scaleMat)];
        legs[0].position.set(-0.62, 0.02, -0.52);
        legs[1].position.set(0.62, 0.02, -0.52);
        legs[2].position.set(-0.62, 0.02, 0.86);
        legs[3].position.set(0.62, 0.02, 0.86);
        const clawMat = new THREE.MeshStandardMaterial({ color: 0xcde7ff, roughness: 0.4, metalness: 0.2 });
        const claws = [new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.22, 8), clawMat), new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.22, 8), clawMat), new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.22, 8), clawMat), new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.22, 8), clawMat)];
        claws[0].rotation.x = Math.PI; claws[1].rotation.x = Math.PI; claws[2].rotation.x = Math.PI; claws[3].rotation.x = Math.PI;
        claws[0].position.set(-0.62, -0.42, -0.6);
        claws[1].position.set(0.62, -0.42, -0.6);
        claws[2].position.set(-0.62, -0.42, 0.78);
        claws[3].position.set(0.62, -0.42, 0.78);
        const tail1 = new THREE.Mesh(new THREE.CapsuleGeometry(0.15, 1.35, 6, 10), scaleMat);
        tail1.rotation.x = Math.PI / 2;
        tail1.position.set(0, 0.48, 1.82);
        const tail2 = new THREE.Mesh(new THREE.CapsuleGeometry(0.13, 1.2, 6, 10), scaleMat);
        tail2.rotation.x = Math.PI / 2;
        tail2.position.set(0, 0.6, 2.86);
        const tail3 = new THREE.Mesh(new THREE.CapsuleGeometry(0.1, 1.0, 6, 10), plateMat);
        tail3.rotation.x = Math.PI / 2;
        tail3.position.set(0, 0.73, 3.76);
        const dorsalSpines = [];
        for (let i = 0; i < 6; i += 1) {
          const spine = new THREE.Mesh(new THREE.ConeGeometry(0.06 + i * 0.005, 0.28 + i * 0.03, 8), new THREE.MeshStandardMaterial({ color: 0x8fd2ff, emissive: 0x2a74a8 }));
          spine.position.set(0, 0.95 - i * 0.03, -0.25 + i * 0.52);
          dorsalSpines.push(spine);
        }
        const sidePlates = [];
        for (let side of [-1, 1]) {
          for (let i = 0; i < 4; i += 1) {
            const plate = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.3), plateMat);
            plate.position.set(side * (0.52 + i * 0.02), 0.58 - i * 0.03, 0.18 + i * 0.62);
            plate.rotation.z = side * 0.24;
            sidePlates.push(plate);
          }
        }
        const chinHorn = new THREE.Mesh(new THREE.ConeGeometry(0.055, 0.22, 8), hornMat);
        chinHorn.rotation.x = Math.PI;
        chinHorn.position.set(0, 0.72, -2.84);
        g.add(body, torsoPlate, neck1, neck2, head, snout, jaw, chinHorn, ...teeth, hornL, hornR, browL, browR, eyeL, eyeR, wingBoneL, wingBoneR, wingMemL1, wingMemL2, wingMemR1, wingMemR2, ...wingFingerL, ...wingFingerR, ...dorsalSpines, ...sidePlates, ...legs, ...claws, tail1, tail2, tail3);
        g.userData.core = body;
        g.userData.anim = {
          type: "dragoon",
          neck1,
          neck2,
          head,
          wingL: wingBoneL,
          wingR: wingBoneR,
          wingMemL: wingMemL1,
          wingMemR: wingMemR1,
          tail1,
          tail2,
          tail3,
          jaw,
          legA: legs[0],
          legB: legs[1]
        };
        g.scale.setScalar(3);
        return g;
      }

      function createBossModel(kind) {
        if (kind === "phoenix") return buildPhoenixBossModel();
        if (kind === "liger") return buildLigerBossModel();
        if (kind === "hyunmu") return buildHyunmuBossModel();
        return buildDragoonBossModel();
      }

      function animateBossModel(boss, now, delta) {
        const anim = boss.mesh.userData.anim;
        if (!anim) return;
        const action = now < (boss.animActionUntil || 0)
          ? (boss.animAction || "idle")
          : (boss.aggro ? "chase" : (boss.state === "return" ? "return" : "idle"));
        const actionSpeed =
          action === "ultimate" ? 2.9
          : action === "melee" ? 2.6
          : action === "dash" ? 2.7
          : action === "ranged" ? 2.1
          : action === "defense" ? 1.2
          : action === "chase" ? 2.2
          : action === "return" ? 1.4
          : 1.05;
        const actionPower =
          action === "ultimate" ? 1.45
          : action === "melee" ? 1.3
          : action === "dash" ? 1.24
          : action === "ranged" ? 1.08
          : action === "defense" ? 0.7
          : action === "chase" ? 1
          : action === "return" ? 0.72
          : 0.56;
        const phase = (boss.animatePhase || 0) + now * actionSpeed;
        const pulse = Math.sin(phase * 2.4) * actionPower;
        if (anim.type === "phoenix") {
          const flap = Math.sin(phase * 3.1) * (0.16 + actionPower * 0.14);
          if (anim.wingL) anim.wingL.rotation.z = -1.05 - flap;
          if (anim.wingR) anim.wingR.rotation.z = 1.05 + flap;
          if (anim.wingTipL) anim.wingTipL.rotation.y = 0.48 + flap * 0.9;
          if (anim.wingTipR) anim.wingTipR.rotation.y = 0.48 - flap * 0.9;
          if (anim.head) anim.head.rotation.x = Math.sin(phase * 1.7) * (0.04 + actionPower * 0.05);
          if (anim.tail) anim.tail.rotation.y = Math.sin(phase * 1.3) * (0.1 + actionPower * 0.11);
          if (anim.tailTip) anim.tailTip.rotation.y = Math.sin(phase * 2.1) * (0.16 + actionPower * 0.14);
          if (anim.tailFlare) anim.tailFlare.rotation.z = Math.sin(phase * 3.8) * 0.45;
          if (anim.chestRing) anim.chestRing.rotation.z = Math.sin(phase * 2.1) * 0.22;
          if (anim.wingAuraL) anim.wingAuraL.rotation.y = 0.2 + Math.sin(phase * 2.7) * 0.24;
          if (anim.wingAuraR) anim.wingAuraR.rotation.y = -0.2 - Math.sin(phase * 2.7) * 0.24;
          if (anim.legL) anim.legL.rotation.x = Math.sin(phase * 2.2) * (0.08 + actionPower * 0.1);
          if (anim.legR) anim.legR.rotation.x = -Math.sin(phase * 2.2) * (0.08 + actionPower * 0.1);
        } else if (anim.type === "liger") {
          if (anim.head) anim.head.rotation.x = Math.sin(phase * 1.4) * (0.03 + actionPower * 0.05);
          if (anim.shoulder) anim.shoulder.position.y = 0.44 + Math.sin(phase * 2.2) * (0.02 + actionPower * 0.025);
          if (anim.tail) anim.tail.rotation.y = Math.sin(phase * 1.9) * (0.14 + actionPower * 0.22);
          if (anim.bolt1) anim.bolt1.position.y = 0.7 + Math.sin(phase * 3.4) * 0.05;
          if (anim.bolt2) anim.bolt2.position.y = 0.95 + Math.sin(phase * 3.2 + 0.6) * 0.05;
          if (anim.bolt3) anim.bolt3.position.y = 1.13 + Math.sin(phase * 3.0 + 1.2) * 0.05;
          if (anim.tailArc) anim.tailArc.rotation.z = Math.sin(phase * 3.6) * 0.38;
          if (anim.legFrontL) anim.legFrontL.rotation.x = Math.sin(phase * 2.5) * (0.1 + actionPower * 0.14);
          if (anim.legFrontR) anim.legFrontR.rotation.x = -Math.sin(phase * 2.5) * (0.1 + actionPower * 0.14);
          if (anim.jaw) {
            const jawOpen =
              action === "melee" ? 0.08
              : action === "ranged" ? 0.05
              : action === "ultimate" ? 0.12
              : 0.03;
            anim.jaw.rotation.x = -0.08 + jawOpen + Math.sin(phase * 3.2) * 0.03;
          }
        } else if (anim.type === "hyunmu") {
          if (anim.neck) anim.neck.rotation.y = Math.sin(phase * 1.1) * (0.06 + actionPower * 0.08);
          if (anim.head) anim.head.rotation.y = Math.sin(phase * 1.7) * (0.08 + actionPower * 0.12);
          if (anim.tail1) anim.tail1.rotation.y = Math.sin(phase * 1.3) * (0.05 + actionPower * 0.07);
          if (anim.tail2) anim.tail2.rotation.y = Math.sin(phase * 1.6 + 0.5) * (0.08 + actionPower * 0.1);
          if (anim.tail3) anim.tail3.rotation.y = Math.sin(phase * 2.1 + 1.1) * (0.12 + actionPower * 0.12);
          if (anim.tailFinL) anim.tailFinL.rotation.y = Math.sin(phase * 2.4) * (0.08 + actionPower * 0.14);
          if (anim.tailFinR) anim.tailFinR.rotation.y = -Math.sin(phase * 2.4) * (0.08 + actionPower * 0.14);
          if (anim.legA) anim.legA.rotation.z = Math.sin(phase * 1.8) * (0.04 + actionPower * 0.06);
          if (anim.legB) anim.legB.rotation.z = -Math.sin(phase * 1.8) * (0.04 + actionPower * 0.06);
        } else if (anim.type === "dragoon") {
          const wing = Math.sin(phase * 2.5) * (0.1 + actionPower * 0.14);
          if (anim.wingL) anim.wingL.rotation.z = -1.05 - wing;
          if (anim.wingR) anim.wingR.rotation.z = 1.05 + wing;
          if (anim.wingMemL) anim.wingMemL.rotation.y = 0.52 + wing * 0.7;
          if (anim.wingMemR) anim.wingMemR.rotation.y = 0.52 - wing * 0.7;
          if (anim.neck1) anim.neck1.rotation.y = Math.sin(phase * 1.2) * (0.05 + actionPower * 0.07);
          if (anim.neck2) anim.neck2.rotation.y = Math.sin(phase * 1.5 + 0.5) * (0.08 + actionPower * 0.1);
          if (anim.head) anim.head.rotation.y = Math.sin(phase * 1.9 + 1.0) * (0.1 + actionPower * 0.12);
          if (anim.tail1) anim.tail1.rotation.y = Math.sin(phase * 1.2) * (0.06 + actionPower * 0.08);
          if (anim.tail2) anim.tail2.rotation.y = Math.sin(phase * 1.6 + 0.7) * (0.1 + actionPower * 0.1);
          if (anim.tail3) anim.tail3.rotation.y = Math.sin(phase * 2.1 + 1.2) * (0.12 + actionPower * 0.14);
          if (anim.jaw) {
            const jawOpen =
              action === "ranged" ? 0.08
              : action === "ultimate" ? 0.14
              : action === "melee" ? 0.06
              : 0.02;
            anim.jaw.rotation.x = -0.04 + jawOpen + Math.sin(phase * 2.8) * 0.04;
          }
          if (anim.legA) anim.legA.rotation.x = Math.sin(phase * 2.2) * (0.06 + actionPower * 0.09);
          if (anim.legB) anim.legB.rotation.x = -Math.sin(phase * 2.2) * (0.06 + actionPower * 0.09);
        }
        const bob =
          action === "dash" ? Math.sin(phase * 3.4) * 0.01
          : action === "defense" ? Math.sin(phase * 1.3) * 0.005
          : Math.sin(phase * 1.8) * (0.006 + actionPower * 0.01);
        if (boss.core) {
          if (typeof boss.core.userData.baseY !== "number") {
            boss.core.userData.baseY = boss.core.position.y;
          }
          boss.core.position.y = boss.core.userData.baseY + bob;
        }
        if (boss.mesh) {
          const tiltTarget =
            action === "melee" ? 0.16
            : action === "dash" ? 0.12
            : action === "ranged" ? 0.06
            : action === "defense" ? -0.04
            : action === "ultimate" ? 0.18
            : 0;
          boss.mesh.rotation.x += (tiltTarget - boss.mesh.rotation.x) * Math.min(1, delta * 5.5);
        }
      }

      function emitBossAmbientEffects(boss, now) {
        if (now >= (boss.nextAuraAt || 0)) {
          const auraColor = boss.kind === "phoenix"
            ? 0xff7a2f
            : boss.kind === "liger"
              ? 0xfff06a
              : boss.kind === "hyunmu"
                ? 0x6eff8a
                : 0x7cc4ff;
          const yOffset = 0.8 + Math.random() * 1.6;
          const angle = Math.random() * Math.PI * 2;
          const radius = boss.aggro ? 1.05 : 0.82;
          const pos = boss.mesh.position.clone().add(new THREE.Vector3(Math.cos(angle) * radius, yOffset, Math.sin(angle) * radius));
          spawnProjectileParticle(pos, auraColor, boss.aggro ? 0.05 : 0.035, boss.aggro ? 0.35 : 0.25);
          boss.nextAuraAt = now + (boss.aggro ? 0.018 : 0.03);
        }
        if (boss.aggro && now >= (boss.nextTrailAt || 0)) {
          const trailColor = boss.kind === "phoenix"
            ? 0xff4b2f
            : boss.kind === "liger"
              ? 0xffd93d
              : boss.kind === "hyunmu"
                ? 0x43d66d
                : 0x3aa0ff;
          spawnStatusBurst(boss.mesh.position.clone().add(new THREE.Vector3(0, 0.45, 0)), trailColor, 2, 0.75, 0.35, "boss-trail");
          boss.nextTrailAt = now + 0.11;
        }
      }

      function emitBossTertiarySignatureEffect(boss, now) {
        if (!boss.aggro) return;
        if (now < (boss.nextTertiaryFxAt || 0)) return;
        const subtype = getBossTertiarySubtype(boss);
        const profileColor = ATTRIBUTE_PROFILE[subtype]?.particleColor || ATTRIBUTE_PROFILE[subtype]?.color || boss.baseColor;
        const origin = boss.mesh.position.clone().add(new THREE.Vector3(0, 0.9, 0));
        if (subtype === DAMAGE_SUBTYPE.CLUSTER) {
          spawnStatusBurst(origin, profileColor, 20, 2.4, 0.6, "boss-trail");
          for (let i = 0; i < 10; i += 1) {
            const a = (Math.PI * 2 * i) / 10;
            const p = origin.clone().add(new THREE.Vector3(Math.cos(a) * 0.8, (Math.random() - 0.5) * 0.5, Math.sin(a) * 0.8));
            spawnProjectileParticle(p, profileColor, 0.05, 0.5);
          }
          boss.nextTertiaryFxAt = now + 0.65;
        } else if (subtype === DAMAGE_SUBTYPE.FLASH) {
          spawnBossTelegraphCircle(boss.mesh.position.clone(), 3.6, profileColor, 0.22);
          spawnStatusBurst(origin, profileColor, 26, 2.8, 0.45, "flash");
          boss.nextTertiaryFxAt = now + 0.75;
        } else if (subtype === DAMAGE_SUBTYPE.SMOKE) {
          spawnStatusBurst(origin, profileColor, 22, 2.6, 1.15, "smoke");
          for (let i = 0; i < 8; i += 1) {
            const p = origin.clone().add(new THREE.Vector3((Math.random() - 0.5) * 1.2, Math.random() * 0.7, (Math.random() - 0.5) * 1.2));
            spawnProjectileParticle(p, 0xb0b0b0, 0.08, 0.8);
          }
          boss.nextTertiaryFxAt = now + 0.7;
        } else if (subtype === DAMAGE_SUBTYPE.PULSE) {
          spawnBossTelegraphCircle(boss.mesh.position.clone(), 4.0, profileColor, 0.24);
          spawnStatusBurst(origin, profileColor, 20, 3.1, 0.5, "freeze");
          boss.nextTertiaryFxAt = now + 0.62;
        } else {
          spawnStatusBurst(origin, profileColor, 12, 1.8, 0.4, "boss-trail");
          boss.nextTertiaryFxAt = now + 0.8;
        }
      }

      function getRoomBounds(roomIndex) {
        const room = rooms[roomIndex];
        const margin = enemyRadius + 0.4;
        return {
          minX: room.x - half + margin,
          maxX: room.x + half - margin,
          minZ: room.z - half + margin,
          maxZ: room.z + half - margin
        };
      }

      function randomPointInRoom(roomIndex) {
        const bounds = getRoomBounds(roomIndex);
        return new THREE.Vector3(
          bounds.minX + Math.random() * (bounds.maxX - bounds.minX),
          floorY + enemyRadius,
          bounds.minZ + Math.random() * (bounds.maxZ - bounds.minZ)
        );
      }

      function getRoomIndexForPos(pos) {
        for (let i = 0; i < rooms.length; i += 1) {
          const room = rooms[i];
          const minX = room.x - half + (room.openings.w ? -playerHalf : playerHalf);
          const maxX = room.x + half + (room.openings.e ? playerHalf : -playerHalf);
          const minZ = room.z - half + (room.openings.n ? -playerHalf : playerHalf);
          const maxZ = room.z + half + (room.openings.s ? playerHalf : -playerHalf);
          if (pos.x >= minX && pos.x <= maxX && pos.z >= minZ && pos.z <= maxZ) {
            return i;
          }
        }
        return -1;
      }

      function spawnEnemy(type) {
        const group = new THREE.Group();
        const coreMat = new THREE.MeshStandardMaterial({
          color: type.color,
          roughness: 0.6,
          metalness: 0.1
        });
        const core = new THREE.Mesh(new THREE.SphereGeometry(enemyRadius, 16, 16), coreMat);
        const glowMat = new THREE.MeshBasicMaterial({
          color: 0xff2f2f,
          transparent: true,
          opacity: 0
        });
        const glow = new THREE.Mesh(
          new THREE.SphereGeometry(enemyRadius * 1.08, 16, 16),
          glowMat
        );
        group.add(core, glow);
        group.position.copy(randomPointInRoom(type.roomIndex));
        scene.add(group);
        const label = document.createElement("div");
        label.className = "enemyLabel";
        label.textContent = "AP 5000 / PA 1000";
        document.body.appendChild(label);
        const now = performance.now() / 1000;
        const nextBeam = now + 50 + Math.random() * 5;
        enemies.push({
          mesh: group,
          core,
          glow,
          label,
          roomIndex: type.roomIndex,
          baseColor: new THREE.Color(type.color),
          nextBall: now + 5 + Math.random() * 2,
          nextBeam,
          chargeStart: nextBeam - 10,
          ap: 5000,
          pa: 1000,
          defense: {
            en: type.defense?.en ?? 200,
            ballistic: type.defense?.ballistic ?? 200,
            explosive: type.defense?.explosive ?? 200
          },
          ballSubtype: type.ballSubtype || "pulse",
          beamSubtype: type.beamSubtype || "laser",
          freezeStacks: [],
          moveTarget: randomPointInRoom(type.roomIndex),
          nextMoveUpdate: now + 0.3 + Math.random() * 0.4,
          spawnTime: now,
          velocity: new THREE.Vector3()
        });
      }

      enemyTypes.forEach((type) => {
        const initialCount = 10 + Math.floor(Math.random() * 21);
        for (let i = 0; i < initialCount; i += 1) {
          spawnEnemy(type);
        }
        enemySpawnTimers.set(type.roomIndex, performance.now() / 1000 + 10 + Math.random() * 10);
      });

      const bossTypes = [
        { roomIndex: 5, rareName: "피닉스 레어", name: "피닉스", kind: "phoenix", color: 0xff4b4b, primarySubtype: "coral", secondarySubtype: "flame", tertiarySubtype: "cluster", ballSubtype: "coral", beamSubtype: "flame", defense: { en: 420, ballistic: 360, explosive: 320 } },
        { roomIndex: 6, rareName: "라이거 레어", name: "라이거", kind: "liger", color: 0xffd93d, primarySubtype: "plasma", secondarySubtype: "shock", tertiarySubtype: "flash", ballSubtype: "plasma", beamSubtype: "shock", defense: { en: 320, ballistic: 420, explosive: 320 } },
        { roomIndex: 7, rareName: "현무 레어", name: "현무", kind: "hyunmu", color: 0x43d66d, primarySubtype: "acid", secondarySubtype: "kojima", tertiarySubtype: "smoke", ballSubtype: "acid", beamSubtype: "kojima", defense: { en: 320, ballistic: 320, explosive: 420 } },
        { roomIndex: 8, rareName: "드라군 레어", name: "드라군", kind: "dragoon", color: 0x3aa0ff, primarySubtype: "laser", secondarySubtype: "freeze", tertiarySubtype: "pulse", ballSubtype: "freeze", beamSubtype: "laser", defense: { en: 380, ballistic: 380, explosive: 380 } }
      ];

      function spawnBoss(type) {
        const room = rooms[type.roomIndex];
        if (!room) return;
        const spawnPos = new THREE.Vector3(room.x, floorY + enemyRadius, room.z);
        const towardWhite = new THREE.Vector3(-room.x, 0, -room.z).normalize();
        const spawnYaw = Math.atan2(-towardWhite.x, -towardWhite.z);
        const mesh = createBossModel(type.kind || "dragoon");
        mesh.position.copy(spawnPos);
        mesh.rotation.y = spawnYaw;
        scene.add(mesh);
        const label = createBossLabel();
        const now = performance.now() / 1000;
        bosses.push({
          mesh,
          core: mesh.userData.core || null,
          label,
          kind: type.kind,
          name: type.name,
          rareName: type.rareName,
          roomIndex: type.roomIndex,
          spawnPos: spawnPos.clone(),
          spawnYaw,
          animatePhase: Math.random() * Math.PI * 2,
          baseColor: new THREE.Color(type.color),
          ap: 1000000,
          pa: 50000,
          defense: {
            en: type.defense?.en ?? 360,
            ballistic: type.defense?.ballistic ?? 360,
            explosive: type.defense?.explosive ?? 360
          },
          primarySubtype: type.primarySubtype || type.ballSubtype || "pulse",
          secondarySubtype: type.secondarySubtype || type.beamSubtype || "laser",
          tertiarySubtype: type.tertiarySubtype || "cluster",
          ballSubtype: type.ballSubtype || type.primarySubtype || "pulse",
          beamSubtype: type.beamSubtype || type.secondarySubtype || "laser",
          freezeStacks: [],
          velocity: new THREE.Vector3(),
          moveTarget: spawnPos.clone(),
          nextMoveUpdate: now,
          aggro: false,
          state: "idle",
          animAction: "idle",
          animActionUntil: now + 0.2,
          shieldUntil: 0,
          ultimateUntil: 0,
          nextUltimatePulseAt: 0,
          ultimatePulseIndex: 0,
          nextAuraAt: now + 0.06,
          nextTrailAt: now + 0.08,
          nextTertiaryFxAt: now + 0.35,
          nextMeleeAt: now + 0.9,
          nextMoveSkillAt: now + 1.35,
          nextRangedAt: now + 1.1,
          nextDefenseAt: now + 6,
          nextUltimateAt: now + 16,
          meleePatternIndex: 0,
          movePatternIndex: 0,
          rangedPatternIndex: 0,
          bossType: type
        });
      }

      function createBossCoreDrop(boss) {
        const coreColor = boss.baseColor ? boss.baseColor.getHex() : 0xffffff;
        const mesh = new THREE.Mesh(
          new THREE.OctahedronGeometry(0.24, 1),
          new THREE.MeshStandardMaterial({ color: coreColor, emissive: coreColor, emissiveIntensity: 0.7, roughness: 0.28, metalness: 0.35 })
        );
        mesh.position.copy(boss.mesh.position).add(new THREE.Vector3(0, 0.45, 0));
        scene.add(mesh);
        const label = document.createElement("div");
        label.className = "enemyLabel";
        label.textContent = `${boss.name} 코어`;
        document.body.appendChild(label);
        bossCoreDrops.push({
          mesh,
          label,
          roomIndex: boss.roomIndex,
          name: `${boss.name} 코어`,
          bornAt: performance.now() / 1000
        });
      }

      function removeBossCoreDrop(core) {
        if (!core) return;
        scene.remove(core.mesh);
        if (core.label) core.label.remove();
        const idx = bossCoreDrops.indexOf(core);
        if (idx >= 0) bossCoreDrops.splice(idx, 1);
      }

      function removeBossEgg(egg) {
        if (!egg) return;
        scene.remove(egg.mesh);
        const idx = bossEggs.indexOf(egg);
        if (idx >= 0) bossEggs.splice(idx, 1);
      }

      function createBossEgg(roomIndex, bossType, bossName, colorHex) {
        const existing = bossEggs.find((e) => e.roomIndex === roomIndex);
        if (existing) {
          removeBossEgg(existing);
        }
        const room = rooms[roomIndex];
        if (!room) return;
        const shell = new THREE.Mesh(
          new THREE.SphereGeometry(0.48, 20, 16),
          new THREE.MeshStandardMaterial({ color: 0xe8e8e8, roughness: 0.45, metalness: 0.1 })
        );
        shell.scale.set(0.75, 1.05, 0.75);
        const coreGlow = new THREE.Mesh(
          new THREE.SphereGeometry(0.25, 16, 12),
          new THREE.MeshStandardMaterial({ color: colorHex || 0xffffff, emissive: colorHex || 0xffffff, emissiveIntensity: 0.6, transparent: true, opacity: 0.75 })
        );
        coreGlow.position.y = 0.02;
        const eggGroup = new THREE.Group();
        eggGroup.add(shell, coreGlow);
        eggGroup.position.set(room.x, floorY + 0.42, room.z);
        scene.add(eggGroup);
        bossEggs.push({
          mesh: eggGroup,
          roomIndex,
          bossType,
          bossName,
          holdTime: 0
        });
      }

      function reviveBossFromEgg(egg) {
        if (!egg || !egg.bossType) return;
        spawnStatusBurst(egg.mesh.position.clone(), egg.bossType.color || 0xffffff, 40, 3.6, 1.2, "boss-revive");
        createExplosionField(egg.mesh.position.clone(), 2.6, 0, egg.bossType.color || 0xffffff, buildDamagePacket(0, egg.bossType.ballSubtype || DAMAGE_SUBTYPE.PULSE));
        removeBossEgg(egg);
        spawnBoss(egg.bossType);
      }

      bossTypes.forEach((type) => {
        spawnBoss(type);
      });

    const player = {
      position: new THREE.Vector3(0, floorY, 0),
      velocity: new THREE.Vector3(),
      grounded: true
    };

    const dummy = new THREE.Group();
    const dummyMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.8, metalness: 0.0 });
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), dummyMat);
    head.position.set(0, 1.6, 0);
    const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.3), dummyMat);
    torso.position.set(0, 1.1, 0);
    const armL = new THREE.Group();
    const armR = new THREE.Group();
    const armUpperL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 0.2), dummyMat);
    const armUpperR = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 0.2), dummyMat);
    armUpperL.position.set(0, -0.2, 0);
    armUpperR.position.set(0, -0.2, 0);
    const forearmL = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.35, 0.18), dummyMat);
    const forearmR = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.35, 0.18), dummyMat);
    forearmL.position.set(0, -0.45, 0.05);
    forearmR.position.set(0, -0.45, 0.05);
    forearmL.rotation.x = Math.PI / 4;
    forearmR.rotation.x = Math.PI / 4;
    armL.add(armUpperL, forearmL);
    armR.add(armUpperR, forearmR);
    armL.position.set(-0.45, 1.3, 0);
    armR.position.set(0.45, 1.3, 0);
    armL.rotation.x = Math.PI / 4;
    armR.rotation.x = Math.PI / 4;
    const legL = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.7, 0.25), dummyMat);
    legL.position.set(-0.15, 0.45, 0);
    const legR = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.7, 0.25), dummyMat);
    legR.position.set(0.15, 0.45, 0);
    dummy.add(head, torso, armL, armR, legL, legR);
    dummy.scale.set(0.7, 0.7, 0.7);
    scene.add(dummy);

    function buildGun(color) {
      const gunGroup = new THREE.Group();
      const gunMat = new THREE.MeshStandardMaterial({ color, roughness: 0.6, metalness: 0.2 });
      const gunMain = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.22, 0.22), gunMat);
      gunMain.position.set(0.45, 0, 0);
      gunGroup.add(gunMain);
      return gunGroup;
    }

    const gunRight = buildGun(0x111111);
    gunRight.position.set(0, -0.14, -0.12);
    gunRight.rotation.set(0, Math.PI / 2, -Math.PI / 2);
    forearmR.add(gunRight);

    const gunLeft = buildGun(0xf2f2f2);
    gunLeft.position.set(0, -0.14, -0.12);
    gunLeft.rotation.set(0, Math.PI / 2, -Math.PI / 2);
    forearmL.add(gunLeft);

    let yaw = 0;
    let pitch = 0;
    const keys = { w: false, a: false, s: false, d: false, shift: false, space: false, f: false };
    const isTouchDevice = window.matchMedia("(pointer: coarse)").matches || ("ontouchstart" in window) || navigator.maxTouchPoints > 0;
    const uiPanel = document.getElementById("ui");
    const hint = document.getElementById("hint");
    const mobileControls = document.getElementById("mobileControls");
    const mobileMoveZone = document.getElementById("mobileMoveZone");
    const mobileMoveStick = document.getElementById("mobileMoveStick");
    const mobileLookZone = document.getElementById("mobileLookZone");
    const mobileLookStick = document.getElementById("mobileLookStick");
    const mobileJumpBtn = document.getElementById("mobileJumpBtn");
    const mobileBoostBtn = document.getElementById("mobileBoostBtn");
    const mobileFireLBtn = document.getElementById("mobileFireLBtn");
    const mobileFireRBtn = document.getElementById("mobileFireRBtn");
    const mobileMenuBtn = document.getElementById("mobileMenuBtn");
    const staminaFill = document.getElementById("staminaFill");
    const menuOverlay = document.getElementById("menuOverlay");
    const ammoLeft = document.getElementById("ammoLeft");
      const ammoRight = document.getElementById("ammoRight");
      const apPanel = document.getElementById("apPanel");
      const apFill = document.getElementById("apFill");
      const paPanel = document.getElementById("paPanel");
      const paFill = document.getElementById("paFill");
      const enFill = document.getElementById("enFill");
      const energyWarning = document.getElementById("energyWarning");
      const apWarning = document.getElementById("apWarning");
      const lockWarning = document.getElementById("lockWarning");
      const bossEggHint = document.getElementById("bossEggHint");
      const threatArrows = [];
      for (let i = 0; i < 12; i += 1) {
        const el = document.createElement("div");
        el.className = "threatArrow";
        document.body.appendChild(el);
        threatArrows.push(el);
      }
      const minimapCanvas = document.getElementById("minimapCanvas");
      let minimapCtx = minimapCanvas ? minimapCanvas.getContext("2d") : null;
      const septiaCountEl = document.getElementById("septiaCount");
      const septiaGaugeEl = document.getElementById("septiaGauge");
      const lockCircleLarge = document.getElementById("lockCircleLarge");
      const aimModePanel = document.getElementById("aimModePanel");
      const hitGreen = document.getElementById("hitGreen");
      const hitRed = document.getElementById("hitRed");
      const expansionCooldownEl = document.getElementById("expansionCooldown");
      const expansionOverlay = document.getElementById("expansionOverlay");
      const kitCountEl = document.getElementById("kitCount");
      const kitCooldownEl = document.getElementById("kitCooldown");
    const repairOverlay = document.getElementById("repairOverlay");
    const damageShield = document.getElementById("damageShield");
    const statusBlackOverlay = document.getElementById("statusBlackOverlay");
    const statusWhiteOverlay = document.getElementById("statusWhiteOverlay");
    const menuClose = document.getElementById("menuClose");
    const menuTabs = Array.from(document.querySelectorAll(".menuTab"));
    const menuSections = Array.from(document.querySelectorAll(".menuSection"));
    const assemblyItems = Array.from(document.querySelectorAll(".assemblyItem"));
    const assemblyDetail = document.getElementById("assemblyDetail");
    const assemblyDetailTitle = document.getElementById("assemblyDetailTitle");
    const assemblyDetailClose = document.getElementById("assemblyDetailClose");
    const assemblyDetailCurrent = document.getElementById("assemblyDetailCurrent");
    const assemblyDetailInventory = document.getElementById("assemblyDetailInventory");
    const assemblyDetailStatus = document.getElementById("assemblyDetailStatus");
    const assemblyUnequip = document.getElementById("assemblyUnequip");
    const codexGridWrap = document.getElementById("codexGridWrap");
    const itemGridWrap = document.getElementById("itemGridWrap");
    const shopGridWrap = document.getElementById("shopGridWrap");
    const codexDetailName = document.getElementById("codexDetailName");
    const itemDetailName = document.getElementById("itemDetailName");
    const shopDetailName = document.getElementById("shopDetailName");
    const codexDetailIcon = document.getElementById("codexDetailIcon");
    const itemDetailIcon = document.getElementById("itemDetailIcon");
    const shopDetailIcon = document.getElementById("shopDetailIcon");
    const codexDetailDesc = document.getElementById("codexDetailDesc");
    const itemDetailDesc = document.getElementById("itemDetailDesc");
    const shopDetailDesc = document.getElementById("shopDetailDesc");
    const codexGrid = document.getElementById("codexGrid");
    const itemGrid = document.getElementById("itemGrid");
    const shopGrid = document.getElementById("shopGrid");
    const previewCanvas = document.getElementById("assemblyPreviewCanvas");
      if (isTouchDevice) {
        document.body.classList.add("mobile-mode");
        if (uiPanel) {
          const mobileGuide = document.createElement("p");
          mobileGuide.textContent = "모바일: 좌측 패드 이동 · 우측 패드 시점 · JUMP/BOOST/FIRE 버튼 사용";
          uiPanel.appendChild(mobileGuide);
        }
      } else if (mobileControls) {
        mobileControls.style.display = "none";
      }
      let stamina = 100;
      let en = 100;
      let enCooldown = false;
      let staminaCooldown = false;
      let staminaCooldownEnd = 0;
      let energyLock = false;
      let frameNow = 0;
    let cameraRoll = 0;
    let dashTiltPulse = 0;
    let paused = false;
    let previewRotX = 0;
    let previewRotY = 0;
    let armRaiseL = false;
    let armRaiseR = false;
    let firingLeft = false;
    let firingRight = false;
    let fireCooldown = 0;
      const magMax = 1000;
    let magLeft = magMax;
    let magRight = magMax;
    let reserveLeft = Infinity;
    let reserveRight = Infinity;
    let reloadingLeft = false;
    let reloadingRight = false;
      let reloadEndLeft = 0;
      let reloadEndRight = 0;
      const reloadTime = 0.1;
      const apMax = 99999;
      let ap = apMax;
      const paMax = 9999;
      let pa = paMax;
      let paCooldown = false;
      let paCooldownEnd = 0;
      let paInvulnUntil = 0;
      let expansionHolding = false;
      let expansionHoldStart = null;
      let expansionCooldownEnd = 0;
      let expansionActiveUntil = 0;
      let expansionNextHeal = 0;
      let expansionShockDone = false;
      let apCriticalUntil = 0;
      let septiaFiring = false;
      let septiaFireCooldown = 0;
      let lockTarget = null;
      let lockTargetUntil = 0;
      const lockTargets = [];
      let lockCircleOffset = 0;
      let autoAimMode = true;
      let aimAssistHolding = false;
      let aimAssistBoostUntil = 0;
      let aimAssistTarget = null;
      let aimAssistAcquirePending = false;
      let aimAssistDownMouse5 = false;
      let hitGreenUntil = 0;
      let hitRedUntil = 0;
      let hitRedDamageUntil = 0;
      const lockCircles = [];
      for (let i = 0; i < 13; i += 1) {
        const el = document.createElement("div");
        el.className = "lockCircleSmall";
        el.style.display = "none";
        document.body.appendChild(el);
        lockCircles.push(el);
      }
      function updateAimModeDisplay(forcedManual = false) {
        if (!aimModePanel) return;
        if (forcedManual) {
          aimModePanel.textContent = "조준 모드: 수동(강제)";
          aimModePanel.style.borderColor = "rgba(255, 255, 255, 0.45)";
        } else {
          aimModePanel.textContent = `조준 모드: ${autoAimMode ? "자동" : "수동"}`;
          aimModePanel.style.borderColor = autoAimMode ? "rgba(255, 90, 90, 0.55)" : "rgba(255, 255, 255, 0.45)";
        }
      }
      updateAimModeDisplay();

      function beginAimAssist() {
        aimAssistHolding = true;
        aimAssistAcquirePending = true;
        aimAssistBoostUntil = 0;
      }

      function endAimAssist() {
        aimAssistHolding = false;
        aimAssistAcquirePending = false;
        aimAssistTarget = null;
        aimAssistBoostUntil = 0;
      }

      function syncAimAssistHoldState() {
        const active = aimAssistDownMouse5;
        if (active) {
          if (!aimAssistHolding) beginAimAssist();
        } else if (aimAssistHolding) {
          endAimAssist();
        }
      }

      function setAimAssistMouseDownState(isDown) {
        if (aimAssistDownMouse5 === isDown) return;
        aimAssistDownMouse5 = isDown;
        syncAimAssistHoldState();
      }

      function toggleAutoAimMode() {
        autoAimMode = !autoAimMode;
        updateAimModeDisplay();
      }

      function syncAimAssistMouse5FromButtons(buttonMask) {
        const sideDown = (buttonMask & 16) !== 0;
        setAimAssistMouseDownState(sideDown);
      }

      function getTargetScreenPos(target) {
        if (!target || !target.mesh) return null;
        if (!(enemies.includes(target) || bosses.includes(target) || destructibleBlocks.includes(target))) return null;
        const projected = target.mesh.position.clone().project(camera);
        if (projected.z > 1) return null;
        return {
          x: (projected.x * 0.5 + 0.5) * window.innerWidth,
          y: (-projected.y * 0.5 + 0.5) * window.innerHeight
        };
      }

      function isTargetInAimAssistRange(target, effectiveAutoAim, centerX, centerY, lockCircleOffsetLocal) {
        const pos = getTargetScreenPos(target);
        if (!pos) return false;
        if (effectiveAutoAim) {
          const radiusPx = 320;
          const dx = pos.x - (centerX + lockCircleOffsetLocal);
          const dy = pos.y - centerY;
          return (dx * dx + dy * dy) <= radiusPx * radiusPx;
        }
        const manualRadius = 72;
        const dx = pos.x - centerX;
        const dy = pos.y - centerY;
        return (dx * dx + dy * dy) <= manualRadius * manualRadius;
      }

      function findAimAssistTarget(effectiveAutoAim, centerX, centerY, lockCircleOffsetLocal) {
        if (effectiveAutoAim) {
          let best = null;
          let bestD2 = Infinity;
          for (const t of lockTargets) {
            if (!t || !t.target || !t.target.mesh) continue;
            if (!(enemies.includes(t.target) || bosses.includes(t.target) || destructibleBlocks.includes(t.target))) continue;
            const inRange = t.target.mesh.position.distanceTo(player.position) <= 150;
            if (!inRange) continue;
            const dx = (t.x || centerX) - centerX;
            const dy = (t.y || centerY) - centerY;
            const d2 = dx * dx + dy * dy;
            if (d2 < bestD2) {
              best = t.target;
              bestD2 = d2;
            }
          }
          if (best) return best;
          return null;
        }
        const manualRadius = 72;
        const manualRadiusSq = effectiveAutoAim ? Infinity : (manualRadius * manualRadius);
        let best = null;
        let bestD2 = manualRadiusSq;
        const candidates = enemies.concat(bosses, destructibleBlocks);
        for (const candidate of candidates) {
          const pos = getTargetScreenPos(candidate);
          if (!pos) continue;
          const x = pos.x;
          const y = pos.y;
          const dx = x - centerX;
          const dy = y - centerY;
          const d2 = dx * dx + dy * dy;
          if (d2 <= bestD2) {
            best = candidate;
            bestD2 = d2;
          }
        }
        return best;
      }

      function applyAimAssist(target, delta, snap = false) {
        if (!target || !target.mesh) return false;
        if (!(enemies.includes(target) || bosses.includes(target) || destructibleBlocks.includes(target))) return false;
        const eye = new THREE.Vector3(player.position.x, player.position.y + playerSize * 0.8, player.position.z);
        const yOffset = enemies.includes(target) ? (enemyRadius * 0.15) : 0;
        const aimPoint = target.mesh.position.clone().add(new THREE.Vector3(0, yOffset, 0));
        const toTarget = aimPoint.sub(eye);
        if (toTarget.lengthSq() < 1e-8) return false;
        toTarget.normalize();
        const desiredYaw = Math.atan2(-toTarget.x, -toTarget.z);
        const desiredPitch = Math.asin(clamp(toTarget.y, -1, 1));
        const yawDiff = Math.atan2(Math.sin(desiredYaw - yaw), Math.cos(desiredYaw - yaw));
        const smooth = snap ? 1 : Math.min(1, 12 * delta);
        yaw += yawDiff * smooth;
        pitch += (desiredPitch - pitch) * smooth;
        pitch = clamp(pitch, -Math.PI / 2 + 0.05, Math.PI / 2 - 0.05);
        return true;
      }
    let kitCount = Infinity;
    let kitHoldStart = null;
    let kitHolding = false;
      let repairCooldownEnd = 0;
      let repairHealStart = 0;
      let repairHealEnd = 0;
      let repairHealAmount = 0;
      let repairHealApplied = 0;
      let repairOverlayUntil = 0;
      let repairActiveStart = 0;
      let repairActiveUntil = 0;
      let damageScale = 1;
      const DAMAGE_FAMILY = {
        EN: "en",
        BALLISTIC: "ballistic",
        EXPLOSIVE: "explosive"
      };
      const DAMAGE_SUBTYPE = {
        LASER: "laser",
        PULSE: "pulse",
        PLASMA: "plasma",
        CORAL: "coral",
        KOJIMA: "kojima",
        FLAME: "flame",
        SHOCK: "shock",
        FREEZE: "freeze",
        ACID: "acid",
        CLUSTER: "cluster",
        SMOKE: "smoke",
        FLASH: "flash"
      };
      const ATTRIBUTE_PROFILE = {
        laser: { families: [DAMAGE_FAMILY.EN], color: 0x3aa0ff, particleColor: 0x3aa0ff },
        pulse: { families: [DAMAGE_FAMILY.EN], color: 0xffffff, particleColor: 0xffffff },
        plasma: {
          families: [DAMAGE_FAMILY.EN],
          color: 0xb45cff,
          particleColor: 0xb45cff,
          onHitExplosion: { scale: 0.45, radius: 2.2, subtype: DAMAGE_SUBTYPE.PLASMA }
        },
        coral: {
          families: [DAMAGE_FAMILY.EN],
          color: 0xff4b4b,
          particleColor: 0xff4b4b,
          ignoreDefense: [DAMAGE_FAMILY.EN],
          onHitExplosion: { scale: 0.45, radius: 2.3, subtype: DAMAGE_SUBTYPE.CORAL }
        },
        kojima: {
          families: [DAMAGE_FAMILY.EN, DAMAGE_FAMILY.BALLISTIC, DAMAGE_FAMILY.EXPLOSIVE],
          color: 0x48ff7a,
          particleColor: 0x48ff7a,
          ignoreDefense: [DAMAGE_FAMILY.BALLISTIC],
          onHitExplosion: { scale: 0.42, radius: 2.4, subtype: DAMAGE_SUBTYPE.KOJIMA }
        },
        flame: { families: [DAMAGE_FAMILY.BALLISTIC], color: 0x111111, particleColor: 0xff4b4b },
        shock: { families: [DAMAGE_FAMILY.BALLISTIC], color: 0xf6d54a, particleColor: 0xfff06a },
        freeze: { families: [DAMAGE_FAMILY.BALLISTIC], color: 0x808080, particleColor: 0x67b8ff },
        acid: { families: [DAMAGE_FAMILY.BALLISTIC], color: 0x747474, particleColor: 0x66ff66 },
        cluster: { families: [DAMAGE_FAMILY.EXPLOSIVE], color: 0x111111, particleColor: 0x999999 },
        smoke: { families: [DAMAGE_FAMILY.EXPLOSIVE], color: 0x777777, particleColor: 0xb0b0b0 },
        flash: { families: [DAMAGE_FAMILY.EXPLOSIVE], color: 0xf6f6f6, particleColor: 0xffffff }
      };
      const playerDefense = { en: 220, ballistic: 220, explosive: 220 };
      const projectileParticles = [];
      const statusParticles = [];
      const statusLinks = [];
      const acidMarks = [];
      let playerShockDrainPending = 0;
      let playerEnDrainPending = 0;
      const playerFreezeStacks = [];
      let playerPaRegenBlockedUntil = 0;
      let minimapBlindUntil = 0;
      let blackOutFullUntil = 0;
      let blackOutRecoverUntil = 0;
      let whiteOutFullUntil = 0;
      let whiteOutRecoverUntil = 0;
    const bullets = [];
    const dashCooldownEnd = { w: 0, a: 0, s: 0, d: 0 };

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function clampCameraPosition(pos) {
      const roomsHere = getRoomsForPos(pos);
      const epsilon = 0.2;
      if (roomsHere.length === 0) return pos;

      let best = null;
      let bestDist = Infinity;
      for (const room of roomsHere) {
        const minX = room.x - half + (room.openings.w ? -playerHalf : playerHalf) + epsilon;
        const maxX = room.x + half + (room.openings.e ? playerHalf : -playerHalf) - epsilon;
        const minZ = room.z - half + (room.openings.n ? -playerHalf : playerHalf) + epsilon;
        const maxZ = room.z + half + (room.openings.s ? playerHalf : -playerHalf) - epsilon;
        const clamped = new THREE.Vector3(
          clamp(pos.x, minX, maxX),
          clamp(pos.y, floorY + epsilon, ceilingY - epsilon),
          clamp(pos.z, minZ, maxZ)
        );
        const dist = clamped.distanceToSquared(pos);
        if (dist < bestDist) {
          bestDist = dist;
          best = clamped;
        }
      }
      return best ?? pos;
    }

    function updateCamera() {
      if (paused) return;
      const eyeHeight = playerSize * 0.8;
      dummy.position.set(player.position.x, player.position.y - playerHalf, player.position.z);
      dummy.rotation.y = yaw;
      dummy.rotation.z = cameraRoll;
      dashTiltPulse += (0 - dashTiltPulse) * Math.min(1, 6 * (1 / 60));
      const tiltStrength = 0.12;
      const strafe = (keys.d ? 1 : 0) - (keys.a ? 1 : 0);
      const targetRoll = -tiltStrength * strafe;
      const rollSpeed = 3;
      cameraRoll += (targetRoll - cameraRoll) * Math.min(1, rollSpeed * (1 / 60));
      const roll = cameraRoll + dashTiltPulse;
      const armBase = 0;
      const armTargetL = armRaiseL ? (Math.PI / 4 + pitch) : armBase;
      const armTargetR = armRaiseR ? (Math.PI / 4 + pitch) : armBase;
      const armSpeed = 8;
      armL.rotation.x += (armTargetL - armL.rotation.x) * Math.min(1, armSpeed * (1 / 60));
      armR.rotation.x += (armTargetR - armR.rotation.x) * Math.min(1, armSpeed * (1 / 60));
      const forearmRest = Math.PI / 4;
      forearmL.rotation.x = reloadingLeft ? 0 : forearmRest;
      forearmR.rotation.x = reloadingRight ? 0 : forearmRest;

      if (keys.shift) {
        const distance = 0.3 * cellSize;
        const height = 0.12 * cellSize;
        camera.fov = 60;
        camera.updateProjectionMatrix();
        const back = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
        const desired = new THREE.Vector3(
          player.position.x,
          player.position.y + height,
          player.position.z
        ).addScaledVector(back, -distance);
        const clamped = clampCameraPosition(desired);
        camera.position.copy(clamped);
        camera.rotation.set(pitch, yaw, roll, "YXZ");
      } else {
        camera.fov = 75;
        camera.updateProjectionMatrix();
        const desired = new THREE.Vector3(
          player.position.x,
          player.position.y + (eyeHeight - playerHalf),
          player.position.z
        );
        const clamped = clampCameraPosition(desired);
        camera.position.copy(clamped);
        camera.rotation.set(pitch, yaw, roll, "YXZ");
      }
    }

    function isInsideAnyRoom(pos) {
      for (const room of rooms) {
        const minX = room.x - half + (room.openings.w ? -playerHalf : playerHalf);
        const maxX = room.x + half + (room.openings.e ? playerHalf : -playerHalf);
        const minZ = room.z - half + (room.openings.n ? -playerHalf : playerHalf);
        const maxZ = room.z + half + (room.openings.s ? playerHalf : -playerHalf);
        if (pos.x >= minX && pos.x <= maxX && pos.z >= minZ && pos.z <= maxZ) {
          return true;
        }
      }
      return false;
    }

    function getRoomsForPos(pos) {
      const result = [];
      for (const room of rooms) {
        const minX = room.x - half + (room.openings.w ? -playerHalf : playerHalf);
        const maxX = room.x + half + (room.openings.e ? playerHalf : -playerHalf);
        const minZ = room.z - half + (room.openings.n ? -playerHalf : playerHalf);
        const maxZ = room.z + half + (room.openings.s ? playerHalf : -playerHalf);
        if (pos.x >= minX && pos.x <= maxX && pos.z >= minZ && pos.z <= maxZ) {
          result.push(room);
        }
      }
      return result;
    }

    function collidesWithBlocks(pos) {
      const roomsHere = getRoomsForPos(pos);
      if (roomsHere.length === 0) return true;

      const epsilon = 0.0001;
      const minX = pos.x - playerHalf + epsilon;
      const maxX = pos.x + playerHalf - epsilon;
      const minZ = pos.z - playerHalf + epsilon;
      const maxZ = pos.z + playerHalf - epsilon;
      const minY = pos.y - playerHalf + epsilon;
      const maxY = pos.y + playerHalf - epsilon;

      for (const room of roomsHere) {
        for (const box of room.blockBoxes) {
          const overlapX = maxX >= box.minX && minX <= box.maxX;
          const overlapY = maxY >= box.minY && minY <= box.maxY;
          const overlapZ = maxZ >= box.minZ && minZ <= box.maxZ;
          if (overlapX && overlapY && overlapZ) {
            return true;
          }
        }
      }
      return false;
    }

    function resolveVertical(nextY) {
      if (nextY > ceilingY) {
        player.position.y = ceilingY;
        player.velocity.y = 0;
        return;
      }
      if (nextY < floorY) {
        player.position.y = floorY;
        player.velocity.y = 0;
        player.grounded = true;
        return;
      }

      const testPos = new THREE.Vector3(player.position.x, nextY, player.position.z);
      if (!collidesWithBlocks(testPos)) {
        player.position.y = nextY;
        return;
      }

      if (player.velocity.y <= 0) {
        const roomsHere = getRoomsForPos(player.position);
        let highestTop = floorY;
        for (const room of roomsHere) {
          for (const box of room.blockBoxes) {
            const overlapX = (player.position.x + playerHalf) >= box.minX &&
              (player.position.x - playerHalf) <= box.maxX;
            const overlapZ = (player.position.z + playerHalf) >= box.minZ &&
              (player.position.z - playerHalf) <= box.maxZ;
            if (!overlapX || !overlapZ) continue;
            const topY = box.maxY + playerHalf;
            if (topY > highestTop) highestTop = topY;
          }
        }
        player.position.y = highestTop;
        player.velocity.y = 0;
        player.grounded = true;
      } else {
        player.velocity.y = 0;
      }
    }

      function applyMovement(delta) {
        if (paused) return;
        const now = frameNow || performance.now() / 1000;
        const forward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
        const forwardFly = new THREE.Vector3(
          -Math.sin(yaw) * Math.cos(pitch),
          Math.sin(pitch),
          -Math.cos(yaw) * Math.cos(pitch)
        ).normalize();
      const right = new THREE.Vector3(Math.sin(yaw + Math.PI / 2), 0, Math.cos(yaw + Math.PI / 2));
      const direction = new THREE.Vector3();
        const dashingInput = keys.shift && keys.space;
        const expansionActive = now < expansionActiveUntil;
        const energyAvailable = expansionActive ? true : (staminaCooldown ? en > 0 : stamina > 0);
        const flyingInput = keys.shift && keys.w && !dashingInput && energyAvailable;

      if (keys.w) direction.add(forward);
      if (keys.s) direction.sub(forward);
      if (keys.d) direction.add(right);
      if (keys.a) direction.sub(right);

        if (direction.lengthSq() > 0) {
          const sprinting = keys.shift && energyAvailable && !energyLock;
          const expansionBoost = expansionActive ? 2 : 1;
          const criticalSlow = now < apCriticalUntil ? 0.5 : 1;
          const freezeSlow = getPlayerFreezeFactor(now);
          const speed = moveSpeed * (sprinting ? 1.5 : 1) * expansionBoost * (energyLock ? 0.5 : 1) * criticalSlow * freezeSlow;
          direction.normalize().multiplyScalar(speed);
          player.velocity.x = direction.x;
          player.velocity.z = direction.z;
        } else {
          player.velocity.x = 0;
          player.velocity.z = 0;
        }

        if (flyingInput) {
          const flySpeed = flyAccel;
          const strafe = (keys.d ? 1 : 0) - (keys.a ? 1 : 0);
          const strafeVec = right.clone().multiplyScalar(strafe * flySpeed * 0.6);
          const flyVec = forwardFly.clone().multiplyScalar(flySpeed).add(strafeVec);
          player.velocity.set(flyVec.x, flyVec.y, flyVec.z);
          player.grounded = false;
        }

      const jumpCost = 4;
      const jumpSpeed = baseJumpSpeed;

        if (!flyingInput && !energyLock && keys.space && !dashingInput && energyAvailable && player.position.y < ceilingY) {
          const cost = jumpCost * delta * 10;
          consumeEnergy(cost, now);
          if (!staminaCooldown || en > 0) {
            player.velocity.y = Math.max(player.velocity.y, jumpSpeed);
          }
        } else if (!flyingInput) {
          player.velocity.y -= gravity * delta;
        }

        if (keys.shift && !player.grounded && !keys.w) {
          if (energyAvailable) {
            player.velocity.y = Math.max(0, player.velocity.y);
          }
        }

      const next = player.position.clone().addScaledVector(player.velocity, delta);

      const tryX = new THREE.Vector3(next.x, player.position.y, player.position.z);
      if (isInsideAnyRoom(tryX) && !collidesWithBlocks(tryX)) {
        player.position.x = tryX.x;
      }

      const tryZ = new THREE.Vector3(player.position.x, player.position.y, next.z);
      if (isInsideAnyRoom(tryZ) && !collidesWithBlocks(tryZ)) {
        player.position.z = tryZ.z;
      }

      resolveVertical(next.y);

      player.position.x = clamp(player.position.x, -worldHalfX + playerHalf, worldHalfX - playerHalf);
      player.position.z = clamp(player.position.z, -worldHalfZ + playerHalf, worldHalfZ - playerHalf);

      if (player.position.y <= floorY) {
        player.position.y = floorY;
        player.velocity.y = 0;
        player.grounded = true;
      } else if (player.position.y >= ceilingY) {
        player.position.y = ceilingY;
        player.velocity.y = Math.min(0, player.velocity.y);
      }
    }

      function startJump() {
        if (!player.grounded) return;
        const energyAvailable = frameNow < expansionActiveUntil ? true : (staminaCooldown ? en > 0 : stamina > 0);
        if (!energyAvailable || energyLock) return;
        player.velocity.y = 0;
        player.grounded = false;
      }

      function consumeEnergy(amount, now) {
        if (amount <= 0) return;
        if (now < expansionActiveUntil) return;
        if (staminaCooldown) {
          en = Math.max(0, en - amount);
          if (en <= 0) {
            en = 0;
            enCooldown = true;
          }
          return;
        }
        stamina = Math.max(0, stamina - amount);
        if (stamina <= 0) {
          stamina = 0;
          staminaCooldown = true;
          staminaCooldownEnd = now + 10;
        }
      }

      function hasEnergyForCost(amount, now) {
        if (now < expansionActiveUntil) return true;
        return staminaCooldown ? en >= amount : stamina >= amount;
      }

      function normalizeDamagePacket(input, fallbackSubtype) {
        if (typeof input === "number") {
          return {
            subtype: fallbackSubtype || DAMAGE_SUBTYPE.FLAME,
            attacks: [{ family: DAMAGE_FAMILY.BALLISTIC, amount: Math.max(0, input), ignoreDefense: false }]
          };
        }
        if (!input || !Array.isArray(input.attacks)) {
          return {
            subtype: fallbackSubtype || DAMAGE_SUBTYPE.FLAME,
            attacks: [{ family: DAMAGE_FAMILY.BALLISTIC, amount: 0, ignoreDefense: false }]
          };
        }
        return {
          subtype: input.subtype || fallbackSubtype || DAMAGE_SUBTYPE.FLAME,
          attacks: input.attacks
            .filter((a) => a && typeof a.amount === "number")
            .map((a) => ({
              family: a.family || DAMAGE_FAMILY.BALLISTIC,
              amount: Math.max(0, a.amount),
              ignoreDefense: !!a.ignoreDefense
            }))
        };
      }

      function buildDamagePacket(baseDamage, subtype, override) {
        const profile = ATTRIBUTE_PROFILE[subtype] || ATTRIBUTE_PROFILE.flame;
        const families = profile.families || [DAMAGE_FAMILY.BALLISTIC];
        const split = families.length > 0 ? baseDamage / families.length : baseDamage;
        const attacks = families.map((family) => ({
          family,
          amount: Math.max(0, split),
          ignoreDefense: !!(profile.ignoreDefense && profile.ignoreDefense.includes(family))
        }));
        const packet = {
          subtype: subtype || DAMAGE_SUBTYPE.FLAME,
          attacks
        };
        if (override) {
          if (typeof override.scale === "number") {
            packet.attacks = packet.attacks.map((a) => ({ ...a, amount: a.amount * override.scale }));
          }
          if (Array.isArray(override.families) && override.families.length > 0) {
            const customSplit = baseDamage / override.families.length;
            packet.attacks = override.families.map((family) => ({
              family,
              amount: Math.max(0, customSplit),
              ignoreDefense: !!(override.ignoreDefense && override.ignoreDefense.includes(family))
            }));
          }
          if (typeof override.subtype === "string") {
            packet.subtype = override.subtype;
          }
        }
        return packet;
      }

      function scaleDamagePacket(packet, scale) {
        const normalized = normalizeDamagePacket(packet);
        return {
          subtype: normalized.subtype,
          attacks: normalized.attacks.map((a) => ({
            family: a.family,
            amount: a.amount * scale,
            ignoreDefense: a.ignoreDefense
          }))
        };
      }

      const HOSTILE_ENEMY_DAMAGE_SCALE = 0.58;
      const HOSTILE_BOSS_DAMAGE_SCALE = 0.52;

      function buildHostileDamagePacket(baseDamage, subtype, sourceType = "enemy", override = null) {
        const basePacket = buildDamagePacket(baseDamage, subtype, override);
        const scale = sourceType === "boss" ? HOSTILE_BOSS_DAMAGE_SCALE : HOSTILE_ENEMY_DAMAGE_SCALE;
        return scaleDamagePacket(basePacket, scale);
      }

      function resolveAttributeDamage(packetInput, defenseProfile) {
        const packet = normalizeDamagePacket(packetInput);
        const defense = defenseProfile || { en: 0, ballistic: 0, explosive: 0 };
        let totalIncoming = 0;
        let totalAfterDefense = 0;
        for (const attack of packet.attacks) {
          const incoming = Math.max(0, attack.amount);
          totalIncoming += incoming;
          if (incoming <= 0) continue;
          if (attack.ignoreDefense) {
            totalAfterDefense += incoming;
            continue;
          }
          const def = defense[attack.family] || 0;
          const effective = incoming - def;
          if (effective > 0) {
            totalAfterDefense += effective;
          }
        }
        return {
          subtype: packet.subtype,
          incoming: totalIncoming,
          damage: Math.max(0, totalAfterDefense),
          blocked: totalIncoming > 0 && totalAfterDefense <= 0
        };
      }

      function spawnProjectileParticle(position, color, size, life) {
        const geo = new THREE.SphereGeometry(size || 0.035, 6, 6);
        const mat = new THREE.MeshBasicMaterial({ color: color || 0xffffff, transparent: true, opacity: 0.9 });
        const p = new THREE.Mesh(geo, mat);
        p.position.copy(position);
        p.userData.life = life || 0.22;
        p.userData.startLife = p.userData.life;
        scene.add(p);
        projectileParticles.push(p);
      }

      function getPacketTotalDamage(packetInput) {
        const packet = normalizeDamagePacket(packetInput);
        let total = 0;
        for (const attack of packet.attacks) total += Math.max(0, attack.amount || 0);
        return total;
      }

      function playerHasActivePaShield() {
        return !paCooldown && pa > 0;
      }

      function getPlayerFreezeFactor(now) {
        for (let i = playerFreezeStacks.length - 1; i >= 0; i -= 1) {
          if (playerFreezeStacks[i] <= now) playerFreezeStacks.splice(i, 1);
        }
        const stackCount = Math.min(10, playerFreezeStacks.length);
        return Math.max(0.5, 1 - stackCount * 0.05);
      }

      function getEnemyFreezeFactor(enemy, now) {
        if (!enemy.freezeStacks) enemy.freezeStacks = [];
        for (let i = enemy.freezeStacks.length - 1; i >= 0; i -= 1) {
          if (enemy.freezeStacks[i] <= now) enemy.freezeStacks.splice(i, 1);
        }
        const stackCount = Math.min(10, enemy.freezeStacks.length);
        return Math.max(0.5, 1 - stackCount * 0.05);
      }

      function createStatusLink(a, b, color) {
        const mat = new THREE.LineBasicMaterial({ color: color || 0xfff06a, transparent: true, opacity: 0.95 });
        const geo = new THREE.BufferGeometry().setFromPoints([a.clone(), b.clone()]);
        const line = new THREE.Line(geo, mat);
        line.userData.life = 0.1;
        line.userData.startLife = 0.1;
        statusLinks.push(line);
        scene.add(line);
      }

      function spawnStatusBurst(center, color, count, speed, life, mode) {
        for (let i = 0; i < count; i += 1) {
          const geo = new THREE.SphereGeometry(0.05 + Math.random() * 0.03, 6, 6);
          const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.95 });
          const p = new THREE.Mesh(geo, mat);
          p.position.copy(center);
          const dir = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.1, Math.random() - 0.5).normalize();
          const vel = dir.multiplyScalar((speed || 2) * (0.6 + Math.random() * 0.8));
          p.userData.life = life || 1.2;
          p.userData.startLife = p.userData.life;
          p.userData.velocity = vel;
          p.userData.mode = mode || "";
          scene.add(p);
          statusParticles.push(p);
        }
      }

      function tryApplyShockChain(hitPos, sourceKind, sourceRef, packet) {
        const chainPacket = scaleDamagePacket(packet, 0.1);
        if (getPacketTotalDamage(chainPacket) <= 0) return;
        if (sourceKind === "enemy") {
          for (const enemy of enemies) {
            if (enemy === sourceRef) continue;
            if (enemy.mesh.position.distanceTo(hitPos) > 3) continue;
            createStatusLink(hitPos, enemy.mesh.position, 0xfff06a);
            applyEnemyDamage(enemy, chainPacket, { position: enemy.mesh.position.clone(), direct: false }, { skipStatus: true });
          }
          for (const block of destructibleBlocks) {
            if (block.mesh.position.distanceTo(hitPos) > 3) continue;
            createStatusLink(hitPos, block.mesh.position, 0xfff06a);
            applyDestructibleDamage(block, chainPacket, { position: block.mesh.position.clone(), direct: false }, { skipStatus: true });
          }
          for (const boss of bosses) {
            if (boss === sourceRef) continue;
            if (boss.mesh.position.distanceTo(hitPos) > 3) continue;
            createStatusLink(hitPos, boss.mesh.position, 0xfff06a);
            applyBossDamage(boss, chainPacket, { position: boss.mesh.position.clone(), direct: false }, { skipStatus: true });
          }
        } else if (sourceKind === "player") {
          for (const enemy of enemies) {
            if (enemy.mesh.position.distanceTo(hitPos) > 3) continue;
            createStatusLink(hitPos, enemy.mesh.position, 0xfff06a);
            applyEnemyDamage(enemy, chainPacket, { position: enemy.mesh.position.clone(), direct: false }, { skipStatus: true });
          }
          for (const boss of bosses) {
            if (boss.mesh.position.distanceTo(hitPos) > 3) continue;
            createStatusLink(hitPos, boss.mesh.position, 0xfff06a);
            applyBossDamage(boss, chainPacket, { position: boss.mesh.position.clone(), direct: false }, { skipStatus: true });
          }
          for (const block of destructibleBlocks) {
            if (block.mesh.position.distanceTo(hitPos) > 3) continue;
            createStatusLink(hitPos, block.mesh.position, 0xfff06a);
            applyDestructibleDamage(block, chainPacket, { position: block.mesh.position.clone(), direct: false }, { skipStatus: true });
          }
        }
      }

      function createAcidMark(targetKind, targetRef, worldPos, now, tickDamage) {
        const mark = new THREE.Mesh(
          new THREE.CircleGeometry(0.22, 16),
          new THREE.MeshBasicMaterial({ color: 0x5cff66, transparent: true, opacity: 0.9, side: THREE.DoubleSide })
        );
        mark.rotation.x = -Math.PI / 2;
        if (targetKind === "enemy" && targetRef && targetRef.mesh) {
          const local = targetRef.mesh.worldToLocal(worldPos.clone());
          mark.position.copy(local);
          targetRef.mesh.add(mark);
        } else {
          const local = dummy.worldToLocal(worldPos.clone());
          mark.position.copy(local);
          dummy.add(mark);
        }
        acidMarks.push({
          mesh: mark,
          targetKind,
          targetRef,
          endAt: now + 5,
          nextTickAt: now + 1,
          tickDamage
        });
      }

      function applyOnHitStatus(targetKind, targetRef, packetInput, result, hitInfo, options) {
        if (options && options.skipStatus) return;
        if (!result || result.incoming <= 0) return;
        const packet = normalizeDamagePacket(packetInput);
        const subtype = packet.subtype;
        const now = performance.now() / 1000;
        const hitPos = hitInfo?.position
          ? hitInfo.position.clone()
          : (targetKind === "enemy" ? targetRef.mesh.position.clone() : player.position.clone());
        const totalDamage = getPacketTotalDamage(packet);

        if (subtype === DAMAGE_SUBTYPE.SHOCK) {
          spawnStatusBurst(hitPos, 0xfff06a, 18, 2.4, 0.9, "shock");
          if (targetKind === "player" && !playerHasActivePaShield()) {
            playerShockDrainPending += 8;
          }
          tryApplyShockChain(hitPos, targetKind, targetRef, packet);
        }

        if (subtype === DAMAGE_SUBTYPE.FREEZE) {
          spawnStatusBurst(hitPos, 0x67b8ff, 14, 1.8, 1.2, "freeze");
          if (targetKind === "player") {
            playerFreezeStacks.push(now + 5);
            if (!playerHasActivePaShield()) {
              playerEnDrainPending += 8;
            }
          } else if (targetKind === "enemy" && targetRef) {
            if (!targetRef.freezeStacks) targetRef.freezeStacks = [];
            targetRef.freezeStacks.push(now + 5);
          }
        }

        if (subtype === DAMAGE_SUBTYPE.ACID) {
          const markPos = hitPos.clone();
          createAcidMark(targetKind, targetRef, markPos, now, totalDamage * 0.1);
          spawnStatusBurst(markPos, 0x6aff77, 8, 0.8, 1.4, "acid");
          if (targetKind === "player") {
            playerPaRegenBlockedUntil = Math.max(playerPaRegenBlockedUntil, now + 5);
          }
        }

        if (subtype === DAMAGE_SUBTYPE.SMOKE) {
          spawnStatusBurst(hitPos, 0x9f9f9f, 70, 3.4, 2.2, "smoke");
          if (player.position.distanceTo(hitPos) <= 5) {
            minimapBlindUntil = Math.max(minimapBlindUntil, now + 3);
          }
          if (hitInfo?.direct && targetKind === "player") {
            blackOutFullUntil = Math.max(blackOutFullUntil, now + 2);
            blackOutRecoverUntil = Math.max(blackOutRecoverUntil, now + 5);
          }
        }

        if (subtype === DAMAGE_SUBTYPE.FLASH) {
          spawnStatusBurst(hitPos, 0xffffff, 42, 3.8, 0.7, "flash");
          const toFlash = hitPos.clone().sub(camera.position);
          const dist = toFlash.length();
          if (dist <= 20) {
            toFlash.normalize();
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            if (forward.dot(toFlash) > 0.3) {
              whiteOutFullUntil = Math.max(whiteOutFullUntil, now + 5);
              whiteOutRecoverUntil = Math.max(whiteOutRecoverUntil, now + 10);
            }
          }
        }
      }

      function applyDamage(amountOrPacket, hitInfo = null, options = null) {
        const now = performance.now() / 1000;
        hitRedUntil = now + 0.3;
        const scaledPacket = typeof amountOrPacket === "number"
          ? amountOrPacket * damageScale
          : scaleDamagePacket(amountOrPacket, damageScale);
        const result = resolveAttributeDamage(scaledPacket, playerDefense);
        let dmg = result.damage;
        if (result.incoming <= 0) {
          hitRedDamageUntil = 0;
          return;
        }
        if (now < expansionActiveUntil) {
          hitRedDamageUntil = 0;
          return;
        }
        if (now < paInvulnUntil) {
          hitRedDamageUntil = 0;
          return;
        }
        const damageLine = hitRed ? hitRed.querySelector("div:nth-child(2)") : null;
        if (damageLine) {
          damageLine.textContent = `DAMAGE ${Math.ceil(dmg)}`;
        }
        let tookDamage = false;
        if (!paCooldown && pa > 0) {
          const used = Math.min(pa, dmg);
          pa -= used;
          dmg -= used;
          if (used > 0) tookDamage = true;
          if (pa <= 0) {
            pa = 0;
            paCooldown = true;
            paCooldownEnd = now + 50;
          }
        }
        if (dmg > 0) {
          ap = Math.max(1, ap - dmg);
          tookDamage = true;
          hitRedDamageUntil = now + 0.3;
        } else {
          if (damageLine) damageLine.textContent = "DAMAGE 0";
          hitRedDamageUntil = result.blocked || tookDamage ? now + 0.3 : 0;
        }
        if (ap <= 1) {
          ap = 1;
          player.position.set(0, floorY, 0);
          player.velocity.set(0, 0, 0);
          apCriticalUntil = now + 10;
        }
        applyOnHitStatus("player", null, scaledPacket, result, hitInfo, options);
      }

      function applyEnemyDamage(enemy, amountOrPacket, hitInfo = null, options = null) {
        const result = resolveAttributeDamage(amountOrPacket, enemy.defense);
        let dmg = result.damage;
        if (result.blocked && (!hitInfo || hitInfo.direct !== false)) {
          spawnFloatingText(enemy.mesh.position, "HIT", "#ffffff");
          spawnFloatingText(enemy.mesh.position, "DAMAGE 0", "#cfcfcf");
        }
        if (enemy.pa > 0) {
          const usePa = Math.min(enemy.pa, dmg);
          enemy.pa -= usePa;
          dmg -= usePa;
          if (usePa > 0) spawnFloatingText(enemy.mesh.position, `-PA ${Math.ceil(usePa)}`, "#7ad7ff");
        }
        if (dmg > 0) {
          enemy.ap = Math.max(0, enemy.ap - dmg);
          spawnFloatingText(enemy.mesh.position, `-AP ${Math.ceil(dmg)}`, "#ff8a8a");
        }
        if (result.incoming > 0) {
          hitGreenUntil = performance.now() / 1000 + 0.3;
        }
        applyOnHitStatus("enemy", enemy, amountOrPacket, result, hitInfo, options);
        if (enemy.ap <= 0) {
          scene.remove(enemy.mesh);
          if (enemy.label) enemy.label.remove();
          const idx = enemies.indexOf(enemy);
          if (idx >= 0) enemies.splice(idx, 1);
        }
      }

      function applyBossDamage(boss, amountOrPacket, hitInfo = null, options = null) {
        const result = resolveAttributeDamage(amountOrPacket, boss.defense);
        let dmg = result.damage;
        if (result.blocked && (!hitInfo || hitInfo.direct !== false)) {
          spawnFloatingText(boss.mesh.position, "HIT", "#ffffff");
          spawnFloatingText(boss.mesh.position, "DAMAGE 0", "#cfcfcf");
        }
        if (boss.shieldUntil && performance.now() / 1000 < boss.shieldUntil) {
          dmg *= 0.6;
        }
        if (boss.pa > 0) {
          const usePa = Math.min(boss.pa, dmg);
          boss.pa -= usePa;
          dmg -= usePa;
          if (usePa > 0) spawnFloatingText(boss.mesh.position, `-PA ${Math.ceil(usePa)}`, "#7ad7ff");
        }
        if (dmg > 0) {
          boss.ap = Math.max(0, boss.ap - dmg);
          spawnFloatingText(boss.mesh.position, `-AP ${Math.ceil(dmg)}`, "#ff8a8a");
        }
        if (result.incoming > 0) {
          hitGreenUntil = performance.now() / 1000 + 0.3;
        }
        applyOnHitStatus("enemy", boss, amountOrPacket, result, hitInfo, options);
        if (boss.ap <= 0) {
          createBossCoreDrop(boss);
          createBossEgg(
            boss.roomIndex,
            boss.bossType || bossTypes.find((t) => t.roomIndex === boss.roomIndex),
            boss.name,
            boss.baseColor ? boss.baseColor.getHex() : 0xffffff
          );
          scene.remove(boss.mesh);
          if (boss.label) boss.label.remove();
          const idx = bosses.indexOf(boss);
          if (idx >= 0) bosses.splice(idx, 1);
        }
      }

      function applyDestructibleDamage(block, amountOrPacket, hitInfo = null, options = null) {
        const result = resolveAttributeDamage(amountOrPacket, block.defense);
        let dmg = result.damage;
        if (block.pa > 0) {
          const usePa = Math.min(block.pa, dmg);
          block.pa -= usePa;
          dmg -= usePa;
        }
        if (dmg > 0) {
          block.ap = Math.max(0, block.ap - dmg);
        }
        if (result.incoming > 0) {
          hitGreenUntil = performance.now() / 1000 + 0.3;
        }
        if (block.ap <= 0) {
          scene.remove(block.mesh);
          const room = rooms[block.roomIndex];
          if (room && room.destructibles) {
            const idx = room.destructibles.indexOf(block);
            if (idx >= 0) room.destructibles.splice(idx, 1);
            const boxIdx = room.blockBoxes.indexOf(block.box);
            if (boxIdx >= 0) room.blockBoxes.splice(boxIdx, 1);
            if (room.destructibleOccupied && block.slotIndex !== undefined) {
              room.destructibleOccupied.delete(block.slotIndex);
            }
          }
          const allIdx = destructibleBlocks.indexOf(block);
          if (allIdx >= 0) destructibleBlocks.splice(allIdx, 1);
        }
        if (!(options && options.skipStatus) && result.incoming > 0) {
          const packet = normalizeDamagePacket(amountOrPacket);
          if (packet.subtype === DAMAGE_SUBTYPE.SMOKE) {
            const now = performance.now() / 1000;
            const at = hitInfo?.position || block.mesh.position;
            spawnStatusBurst(at.clone(), 0x9f9f9f, 70, 3.4, 2.2, "smoke");
            if (player.position.distanceTo(at) <= 5) minimapBlindUntil = Math.max(minimapBlindUntil, now + 3);
          }
          if (packet.subtype === DAMAGE_SUBTYPE.FLASH) {
            applyOnHitStatus("player", null, amountOrPacket, { incoming: 1, damage: 0 }, { position: hitInfo?.position || block.mesh.position, direct: false }, options);
          }
        }
      }

      function createExplosionField(center, radius, dps, color, damagePacket) {
        const fxGeo = new THREE.SphereGeometry(0.6, 16, 16);
        const fxMat = new THREE.MeshStandardMaterial({ color, transparent: true, opacity: 0.9 });
        const fx = new THREE.Mesh(fxGeo, fxMat);
        fx.position.copy(center);
        fx.userData.life = 3;
        fx.userData.startLife = 3;
        fx.userData.radius = radius;
        fx.userData.dps = dps;
        fx.userData.damagePacket = damagePacket || buildDamagePacket(dps, DAMAGE_SUBTYPE.CLUSTER);
        explosionFields.push(fx);
        scene.add(fx);
      }

      function spawnFloatingText(pos, text, color) {
        const el = document.createElement("div");
        el.className = "floatText";
        el.style.color = color;
        el.textContent = text;
        document.body.appendChild(el);
        floatingTexts.push({
          el,
          pos: pos.clone(),
          life: 0.8,
          startLife: 0.8,
          velocity: new THREE.Vector3(0, 0.8, 0)
        });
      }


      function findSeptiaTarget(pos, range) {
        let best = null;
        let bestDist = Infinity;
        for (const enemy of enemies) {
          const d2 = enemy.mesh.position.distanceToSquared(pos);
          if (!best || d2 < bestDist) {
            best = enemy;
            bestDist = d2;
          }
        }
        for (const boss of bosses) {
          const d2 = boss.mesh.position.distanceToSquared(pos);
          if (!best || d2 < bestDist) {
            best = boss;
            bestDist = d2;
          }
        }
        for (const block of destructibleBlocks) {
          const d2 = block.mesh.position.distanceToSquared(pos);
          if (!best || d2 < bestDist) {
            best = block;
            bestDist = d2;
          }
        }
        return best;
      }

      function isSeptiaTargetAlive(target) {
        return !!(target && target.mesh && (enemies.includes(target) || bosses.includes(target) || destructibleBlocks.includes(target)));
      }

      function applySeptiaDamage(target, amount, hitPos) {
        if (!target || amount <= 0) return;
        if (enemies.includes(target)) {
          applyEnemyDamage(target, amount, { position: hitPos || target.mesh.position.clone(), direct: true });
          return;
        }
        if (bosses.includes(target)) {
          applyBossDamage(target, amount, { position: hitPos || target.mesh.position.clone(), direct: true });
          return;
        }
        if (destructibleBlocks.includes(target)) {
          applyDestructibleDamage(target, amount, { position: hitPos || target.mesh.position.clone(), direct: true });
        }
      }

      function spawnHostileProjectile(origin, dir, subtype, speed, life, damageValue, scale = 0.16) {
        const profile = ATTRIBUTE_PROFILE[subtype] || ATTRIBUTE_PROFILE.pulse;
        const projectile = new THREE.Mesh(
          new THREE.SphereGeometry(scale, 10, 10),
          new THREE.MeshStandardMaterial({
            color: profile.color || 0xffffff,
            emissive: profile.particleColor || profile.color || 0xffffff,
            emissiveIntensity: 0.5
          })
        );
        projectile.position.copy(origin);
        projectile.userData.velocity = dir.clone().normalize().multiplyScalar(speed);
        projectile.userData.life = life;
        projectile.userData.subtype = subtype;
        projectile.userData.damagePacket = buildHostileDamagePacket(damageValue, subtype, "boss");
        scene.add(projectile);
        enemyProjectiles.push(projectile);
      }

      function spawnBossTelegraphCircle(center, radius, color, life = 0.42) {
        const geo = new THREE.RingGeometry(Math.max(0.05, radius - 0.14), radius, 48);
        const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.85, side: THREE.DoubleSide });
        const ring = new THREE.Mesh(geo, mat);
        ring.rotation.x = -Math.PI / 2;
        ring.position.copy(center).setY(floorY + 0.03);
        ring.userData.life = life;
        ring.userData.startLife = life;
        ring.userData.kind = "circle";
        scene.add(ring);
        bossTelegraphs.push(ring);
      }

      function spawnBossTelegraphLine(from, to, color, life = 0.42) {
        const dir = to.clone().sub(from);
        const len = Math.max(0.2, dir.length());
        const geo = new THREE.PlaneGeometry(0.34, len);
        const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
        const line = new THREE.Mesh(geo, mat);
        line.position.copy(from.clone().add(to).multiplyScalar(0.5)).setY(floorY + 0.03);
        line.rotation.x = -Math.PI / 2;
        line.rotation.z = Math.atan2(dir.x, dir.z);
        line.userData.life = life;
        line.userData.startLife = life;
        line.userData.kind = "line";
        scene.add(line);
        bossTelegraphs.push(line);
      }

      function spawnBossTelegraphSector(center, forward, radius, arcRad, color, life = 0.45) {
        const geo = new THREE.RingGeometry(0.2, radius, 50, 1, -arcRad * 0.5, arcRad);
        const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.78, side: THREE.DoubleSide });
        const sector = new THREE.Mesh(geo, mat);
        sector.rotation.x = -Math.PI / 2;
        sector.position.copy(center).setY(floorY + 0.031);
        const yaw = Math.atan2(forward.x, forward.z);
        sector.rotation.z = yaw;
        sector.userData.life = life;
        sector.userData.startLife = life;
        sector.userData.kind = "sector";
        scene.add(sector);
        bossTelegraphs.push(sector);
      }

      function getBossPatternSubtype(boss, patternIndex) {
        const primary = boss.primarySubtype || boss.ballSubtype || DAMAGE_SUBTYPE.PULSE;
        const secondary = boss.secondarySubtype || boss.beamSubtype || DAMAGE_SUBTYPE.LASER;
        return patternIndex % 2 === 0 ? primary : secondary;
      }

      function getBossAlternateSubtype(boss, patternIndex) {
        const primary = boss.primarySubtype || boss.ballSubtype || DAMAGE_SUBTYPE.PULSE;
        const secondary = boss.secondarySubtype || boss.beamSubtype || DAMAGE_SUBTYPE.LASER;
        return patternIndex % 2 === 0 ? secondary : primary;
      }

      function getBossTertiarySubtype(boss) {
        return boss.tertiarySubtype || DAMAGE_SUBTYPE.CLUSTER;
      }

      function setBossAnimAction(boss, action, now, duration = 0.38) {
        boss.animAction = action;
        boss.animActionUntil = now + Math.max(0.08, duration);
      }

      function performBossMeleePattern(boss, patternIndex, now, distToPlayer) {
        setBossAnimAction(boss, "melee", now, 0.48);
        const impactSubtype = getBossPatternSubtype(boss, patternIndex);
        const zoneSubtype = getBossAlternateSubtype(boss, patternIndex);
        const impactColor = ATTRIBUTE_PROFILE[impactSubtype]?.color || boss.baseColor;
        spawnBossTelegraphCircle(boss.mesh.position.clone(), patternIndex % 2 === 0 ? 2.8 : 3.8, impactColor);
        if (patternIndex % 2 === 0) {
          if (distToPlayer <= 2.8) {
            applyDamage(buildHostileDamagePacket(2800, impactSubtype, "boss"), { position: boss.mesh.position.clone(), direct: true });
          }
          spawnStatusBurst(boss.mesh.position.clone(), impactColor, 18, 1.8, 0.8, "boss-melee");
        } else {
          if (distToPlayer <= 3.8) {
            applyDamage(buildHostileDamagePacket(2100, impactSubtype, "boss"), { position: boss.mesh.position.clone(), direct: true });
          }
          const ringPacket = buildHostileDamagePacket(1200, zoneSubtype, "boss");
          createExplosionField(boss.mesh.position.clone(), 2.6, 0, impactColor, ringPacket);
        }
        boss.nextMeleeAt = now + 1.5;
      }

      function performBossMovePattern(boss, patternIndex, now) {
        setBossAnimAction(boss, "dash", now, 0.42);
        const moveSubtype = getBossPatternSubtype(boss, patternIndex);
        const moveColor = ATTRIBUTE_PROFILE[moveSubtype]?.color || boss.baseColor;
        const extraSubtype = getBossTertiarySubtype(boss);
        const extraColor = ATTRIBUTE_PROFILE[extraSubtype]?.color || moveColor;
        const toPlayer = player.position.clone().sub(boss.mesh.position);
        toPlayer.y = 0;
        if (toPlayer.lengthSq() > 0.0001) toPlayer.normalize();
        spawnBossTelegraphSector(boss.mesh.position.clone(), toPlayer.lengthSq() > 0.0001 ? toPlayer : new THREE.Vector3(0, 0, -1), 4.6, Math.PI * 0.75, moveColor);
        if (patternIndex % 2 === 0) {
          boss.mesh.position.addScaledVector(toPlayer, 5.8);
        } else {
          const side = new THREE.Vector3(-toPlayer.z, 0, toPlayer.x).normalize();
          boss.mesh.position.addScaledVector(side, (Math.random() < 0.5 ? -1 : 1) * 4.8);
        }
        const shockPacket = buildHostileDamagePacket(1500, moveSubtype, "boss");
        createExplosionField(boss.mesh.position.clone(), 2.2, 0, moveColor, shockPacket);
        const tertiaryPacket = buildHostileDamagePacket(1200, extraSubtype, "boss");
        createExplosionField(boss.mesh.position.clone(), 2.6, 0, extraColor, tertiaryPacket);
        if (player.position.distanceTo(boss.mesh.position) <= 2.5) {
          applyDamage(shockPacket, { position: boss.mesh.position.clone(), direct: false });
          applyDamage(tertiaryPacket, { position: boss.mesh.position.clone(), direct: false });
        }
        boss.nextMoveSkillAt = now + 2.1;
      }

      function performBossRangedPattern(boss, patternIndex, now) {
        setBossAnimAction(boss, "ranged", now, 0.52);
        const rangedSubtype = getBossPatternSubtype(boss, patternIndex);
        const rangedColor = ATTRIBUTE_PROFILE[rangedSubtype]?.color || boss.baseColor;
        const toPlayer = player.position.clone().sub(boss.mesh.position);
        const dist = Math.max(0.01, toPlayer.length());
        const dir = toPlayer.clone().normalize();
        spawnBossTelegraphLine(boss.mesh.position.clone(), player.position.clone(), rangedColor);
        if (patternIndex % 2 === 0) {
          for (let i = 0; i < 3; i += 1) {
            const spreadYaw = (i - 1) * 0.08;
            const spreadDir = dir.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), spreadYaw).normalize();
            spawnHostileProjectile(
              boss.mesh.position.clone().addScaledVector(spreadDir, enemyRadius + 0.45),
              spreadDir,
              rangedSubtype,
              7.5,
              6,
              Math.max(1200, 2200 - dist * 60),
              0.14
            );
          }
        } else {
          applyDamage(buildHostileDamagePacket(6500, rangedSubtype, "boss"), { position: player.position.clone(), direct: true });
          const beamMat = new THREE.LineBasicMaterial({ color: rangedColor });
          const beamGeo = new THREE.BufferGeometry().setFromPoints([boss.mesh.position.clone(), player.position.clone()]);
          const beam = new THREE.Line(beamGeo, beamMat);
          beam.userData.life = 0.35;
          scene.add(beam);
          enemyBeams.push(beam);
        }
        boss.nextRangedAt = now + 1.9;
      }

      function triggerBossDefensePattern(boss, now) {
        setBossAnimAction(boss, "defense", now, 0.82);
        const defenseSubtype = getBossTertiarySubtype(boss);
        const defenseColor = ATTRIBUTE_PROFILE[defenseSubtype]?.color || 0x9fd7ff;
        spawnBossTelegraphCircle(boss.mesh.position.clone(), 3.2, defenseColor, 0.5);
        boss.shieldUntil = now + 5;
        boss.pa = Math.min(50000, boss.pa + 10000);
        spawnStatusBurst(boss.mesh.position.clone(), defenseColor, 28, 2.4, 1.2, "boss-shield");
        createExplosionField(boss.mesh.position.clone(), 2.2, 0, defenseColor, buildHostileDamagePacket(900, defenseSubtype, "boss"));
        boss.nextDefenseAt = now + 7;
      }

      function triggerBossUltimatePattern(boss, now) {
        setBossAnimAction(boss, "ultimate", now, 1.1);
        spawnBossTelegraphCircle(boss.mesh.position.clone(), 8.2, boss.baseColor, 0.65);
        boss.ultimateUntil = now + 6;
        boss.nextUltimatePulseAt = now;
        boss.ultimatePulseIndex = 0;
        boss.nextUltimateAt = now + 18;
        spawnStatusBurst(boss.mesh.position.clone(), boss.baseColor, 36, 3.2, 1.6, "boss-ultimate");
      }

      function segmentPointDistanceSquared(a, b, p) {
        const ab = b.clone().sub(a);
        const abLenSq = ab.lengthSq();
        if (abLenSq <= 1e-8) return p.distanceToSquared(a);
        const t = clamp(p.clone().sub(a).dot(ab) / abLenSq, 0, 1);
        const closest = a.clone().addScaledVector(ab, t);
        return p.distanceToSquared(closest);
      }

      function segmentIntersectsAABB(a, b, box) {
        const dir = b.clone().sub(a);
        let tMin = 0;
        let tMax = 1;
        const axes = [
          { o: a.x, d: dir.x, min: box.minX, max: box.maxX },
          { o: a.y, d: dir.y, min: box.minY, max: box.maxY },
          { o: a.z, d: dir.z, min: box.minZ, max: box.maxZ }
        ];
        for (const axis of axes) {
          if (Math.abs(axis.d) < 1e-8) {
            if (axis.o < axis.min || axis.o > axis.max) return false;
            continue;
          }
          const invD = 1 / axis.d;
          let t1 = (axis.min - axis.o) * invD;
          let t2 = (axis.max - axis.o) * invD;
          if (t1 > t2) {
            const tmp = t1;
            t1 = t2;
            t2 = tmp;
          }
          tMin = Math.max(tMin, t1);
          tMax = Math.min(tMax, t2);
          if (tMin > tMax) return false;
        }
        return tMax >= 0 && tMin <= 1;
      }

    function setActiveTab(name) {
      menuTabs.forEach((tab) => {
        const active = tab.dataset.tab === name;
        tab.classList.toggle("active", active);
        tab.setAttribute("aria-selected", active ? "true" : "false");
      });
      menuSections.forEach((section) => {
        section.classList.toggle("active", section.id === `tab-${name}`);
      });
        if (name === "assembly") {
          previewRotX = 0;
          previewRotY = Math.PI;
        }
    }

    function toggleMenu() {
      paused = !paused;
      document.body.classList.toggle("menu-open", paused);
      menuOverlay.classList.toggle("active", paused);
      menuOverlay.setAttribute("aria-hidden", paused ? "false" : "true");
      if (paused) {
        setActiveTab("controls");
      }
      if (paused) {
        if (document.pointerLockElement === document.body) {
          document.exitPointerLock();
        }
        keys.w = false;
        keys.a = false;
        keys.s = false;
        keys.d = false;
        keys.shift = false;
        keys.space = false;
        keys.f = false;
        firingLeft = false;
        firingRight = false;
        armRaiseL = false;
        armRaiseR = false;
      }
    }

      document.addEventListener("keydown", (event) => {
        if (event.code === "KeyE") {
          toggleMenu();
          return;
        }
        if (event.code === "KeyQ") {
          if (!expansionHolding) {
            expansionHolding = true;
            expansionHoldStart = performance.now();
          }
        }
        if (event.code === "Digit2") {
          septiaFiring = true;
        }
        if (event.code === "Digit1") {
          if (!kitHolding) {
            kitHolding = true;
            kitHoldStart = performance.now();
          }
      }
      if (event.code === "KeyF") keys.f = true;
      if (event.code === "KeyW") keys.w = true;
      if (event.code === "KeyA") keys.a = true;
      if (event.code === "KeyS") keys.s = true;
      if (event.code === "KeyD") keys.d = true;
      if (event.code === "ShiftLeft" || event.code === "ShiftRight") keys.shift = true;
        if (event.code === "Space") {
          keys.space = true;
          if (!energyLock) startJump();
          const dashKeyMap = { KeyW: "w", KeyA: "a", KeyS: "s", KeyD: "d" };
          if (keys.shift && keys.w) {
            const dashKey = "w";
            const now = performance.now() / 1000;
            if (
              hasEnergyForCost(8, now) &&
              now >= dashCooldownEnd[dashKey]
            ) {
              const dashForward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
              const dashDir = dashForward.clone().normalize();
              const step = dashDir.clone().multiplyScalar(dashDistance);
              const dashTryX = new THREE.Vector3(player.position.x + step.x, player.position.y, player.position.z);
              if (isInsideAnyRoom(dashTryX) && !collidesWithBlocks(dashTryX)) {
                player.position.x = dashTryX.x;
              }
              const dashTryZ = new THREE.Vector3(player.position.x, player.position.y, player.position.z + step.z);
              if (isInsideAnyRoom(dashTryZ) && !collidesWithBlocks(dashTryZ)) {
                player.position.z = dashTryZ.z;
              }
              consumeEnergy(8, now);
              dashCooldownEnd[dashKey] = now + dashCooldown;
            }
          }
        }
        const dashKeyMap = { KeyW: "w", KeyA: "a", KeyS: "s", KeyD: "d" };
        const dashKey = dashKeyMap[event.code];
        const now = performance.now() / 1000;
      if (
        dashKey &&
        keys.shift && keys.space &&
        hasEnergyForCost(8, now) &&
        !energyLock &&
        now >= dashCooldownEnd[dashKey]
      ) {
        const dashForward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
        const dashRight = new THREE.Vector3(Math.sin(yaw + Math.PI / 2), 0, Math.cos(yaw + Math.PI / 2));
        let dashDir = new THREE.Vector3();
        if (dashKey === "w") dashDir = dashForward;
        if (dashKey === "s") dashDir = dashForward.clone().multiplyScalar(-1);
        if (dashKey === "d") dashDir = dashRight;
        if (dashKey === "a") dashDir = dashRight.clone().multiplyScalar(-1);
        if (dashDir.lengthSq() > 0) {
          dashDir.normalize();
          const expansionBoost = performance.now() / 1000 < expansionActiveUntil ? 3 : 1;
          const step = dashDir.clone().multiplyScalar(dashDistance * expansionBoost);
          const dashTryX = new THREE.Vector3(player.position.x + step.x, player.position.y, player.position.z);
          if (isInsideAnyRoom(dashTryX) && !collidesWithBlocks(dashTryX)) {
            player.position.x = dashTryX.x;
          }
          const dashTryZ = new THREE.Vector3(player.position.x, player.position.y, player.position.z + step.z);
          if (isInsideAnyRoom(dashTryZ) && !collidesWithBlocks(dashTryZ)) {
            player.position.z = dashTryZ.z;
          }
          if (dashKey === "a") dashTiltPulse = 0.2;
          if (dashKey === "d") dashTiltPulse = -0.2;
          consumeEnergy(8, now);
          dashCooldownEnd[dashKey] = now + dashCooldown;
        }
      }
    });

      document.addEventListener("keyup", (event) => {
        if (event.code === "KeyE") return;
        if (event.code === "KeyQ") {
          expansionHolding = false;
          expansionHoldStart = null;
        }
        if (event.code === "Digit2") {
          septiaFiring = false;
        }
        if (event.code === "Digit1") {
          kitHolding = false;
          kitHoldStart = null;
        }
      if (event.code === "KeyF") keys.f = false;
      if (event.code === "KeyW") keys.w = false;
      if (event.code === "KeyA") keys.a = false;
      if (event.code === "KeyS") keys.s = false;
      if (event.code === "KeyD") keys.d = false;
      if (event.code === "ShiftLeft" || event.code === "ShiftRight") keys.shift = false;
      if (event.code === "Space") keys.space = false;
    });

    document.addEventListener("mousedown", (event) => {
      if (event.button === 0) armRaiseL = true;
      if (event.button === 2) armRaiseR = true;
      if (event.button === 3) {
        toggleAutoAimMode();
        event.preventDefault();
        event.stopPropagation();
        return;
      }
      if (event.button === 4) {
        syncAimAssistMouse5FromButtons(event.buttons);
        if ((event.buttons & 16) === 0) {
          setAimAssistMouseDownState(true);
        }
        event.preventDefault();
        event.stopImmediatePropagation();
        event.stopPropagation();
      }
    });

    document.addEventListener("mouseup", (event) => {
      if (event.button === 0) armRaiseL = false;
      if (event.button === 2) armRaiseR = false;
      if (event.button === 4) {
        syncAimAssistMouse5FromButtons(event.buttons);
        if ((event.buttons & 16) === 0) {
          setAimAssistMouseDownState(false);
        }
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    });

    document.addEventListener("contextmenu", (event) => {
      event.preventDefault();
    });
    document.addEventListener("auxclick", (event) => {
      if (event.button === 3 || event.button === 4) {
        event.preventDefault();
      }
    });
    window.addEventListener("blur", () => {
      setAimAssistMouseDownState(false);
      syncAimAssistHoldState();
    });
    window.addEventListener("mousedown", (event) => {
      if (event.button === 4) {
        syncAimAssistMouse5FromButtons(event.buttons);
        if ((event.buttons & 16) === 0) {
          setAimAssistMouseDownState(true);
        }
        event.preventDefault();
      }
    }, true);
    window.addEventListener("mouseup", (event) => {
      if (event.button === 4) {
        syncAimAssistMouse5FromButtons(event.buttons);
        if ((event.buttons & 16) === 0) {
          setAimAssistMouseDownState(false);
        }
      }
    }, true);
    // Keep aim-assist state tied to Mouse5 hold state.

    document.addEventListener("mousedown", (event) => {
      if (event.button === 0) firingLeft = true;
      if (event.button === 2) firingRight = true;
    });
    document.addEventListener("mouseup", (event) => {
      if (event.button === 0) firingLeft = false;
      if (event.button === 2) firingRight = false;
    });

    function onMouseMove(event) {
      const sideBitsDown = (event.buttons & 16) !== 0;
      if (sideBitsDown !== aimAssistDownMouse5) {
        setAimAssistMouseDownState(sideBitsDown);
      }
      if (aimAssistHolding) return;
      const sensitivity = 0.002;
      yaw -= event.movementX * sensitivity;
      pitch -= event.movementY * sensitivity;
      pitch = clamp(pitch, -Math.PI / 2 + 0.05, Math.PI / 2 - 0.05);
    }

      function initMobileControls() {
        if (!isTouchDevice || !mobileControls || !mobileMoveZone || !mobileLookZone) return;

        const moveState = { id: null, cx: 0, cy: 0, radius: 1 };
        const lookState = { id: null, x: 0, y: 0, cx: 0, cy: 0, radius: 1 };

        function setStickPosition(stick, dx, dy, radius) {
          if (!stick) return;
          const len = Math.hypot(dx, dy);
          const limit = radius * 0.55;
          let px = dx;
          let py = dy;
          if (len > limit) {
            const scale = limit / len;
            px *= scale;
            py *= scale;
          }
          stick.style.transform = `translate(calc(-50% + ${px}px), calc(-50% + ${py}px))`;
        }

        function resetMove() {
          keys.w = false;
          keys.a = false;
          keys.s = false;
          keys.d = false;
          setStickPosition(mobileMoveStick, 0, 0, moveState.radius);
        }

        function applyMove(dx, dy) {
          const nx = dx / moveState.radius;
          const ny = dy / moveState.radius;
          const dead = 0.18;
          keys.w = ny < -dead;
          keys.s = ny > dead;
          keys.a = nx < -dead;
          keys.d = nx > dead;
          setStickPosition(mobileMoveStick, dx, dy, moveState.radius);
        }

        function resetLook() {
          lookState.id = null;
          setStickPosition(mobileLookStick, 0, 0, lookState.radius);
        }

        function bindHoldButton(button, onStart, onEnd) {
          if (!button) return;
          let activeId = null;
          button.addEventListener("pointerdown", (event) => {
            event.preventDefault();
            activeId = event.pointerId;
            button.classList.add("active");
            if (onStart) onStart();
            if (button.setPointerCapture) button.setPointerCapture(event.pointerId);
          });
          const release = (event) => {
            if (activeId === null || event.pointerId !== activeId) return;
            activeId = null;
            button.classList.remove("active");
            if (onEnd) onEnd();
          };
          button.addEventListener("pointerup", release);
          button.addEventListener("pointercancel", release);
          button.addEventListener("lostpointercapture", release);
        }

        mobileMoveZone.addEventListener("pointerdown", (event) => {
          if (moveState.id !== null) return;
          event.preventDefault();
          const rect = mobileMoveZone.getBoundingClientRect();
          moveState.id = event.pointerId;
          moveState.cx = rect.left + rect.width * 0.5;
          moveState.cy = rect.top + rect.height * 0.5;
          moveState.radius = rect.width * 0.5;
          applyMove(event.clientX - moveState.cx, event.clientY - moveState.cy);
          if (mobileMoveZone.setPointerCapture) mobileMoveZone.setPointerCapture(event.pointerId);
        });
        mobileMoveZone.addEventListener("pointermove", (event) => {
          if (event.pointerId !== moveState.id) return;
          event.preventDefault();
          applyMove(event.clientX - moveState.cx, event.clientY - moveState.cy);
        });
        const releaseMove = (event) => {
          if (event.pointerId !== moveState.id) return;
          moveState.id = null;
          resetMove();
        };
        mobileMoveZone.addEventListener("pointerup", releaseMove);
        mobileMoveZone.addEventListener("pointercancel", releaseMove);
        mobileMoveZone.addEventListener("lostpointercapture", releaseMove);

        mobileLookZone.addEventListener("pointerdown", (event) => {
          if (lookState.id !== null) return;
          event.preventDefault();
          const rect = mobileLookZone.getBoundingClientRect();
          lookState.id = event.pointerId;
          lookState.x = event.clientX;
          lookState.y = event.clientY;
          lookState.cx = rect.left + rect.width * 0.5;
          lookState.cy = rect.top + rect.height * 0.5;
          lookState.radius = rect.width * 0.5;
          if (mobileLookZone.setPointerCapture) mobileLookZone.setPointerCapture(event.pointerId);
        });
        mobileLookZone.addEventListener("pointermove", (event) => {
          if (event.pointerId !== lookState.id) return;
          event.preventDefault();
          const dx = event.clientX - lookState.x;
          const dy = event.clientY - lookState.y;
          lookState.x = event.clientX;
          lookState.y = event.clientY;
          const sensitivity = 0.0035;
          yaw -= dx * sensitivity;
          pitch -= dy * sensitivity;
          pitch = clamp(pitch, -Math.PI / 2 + 0.05, Math.PI / 2 - 0.05);
          setStickPosition(mobileLookStick, event.clientX - lookState.cx, event.clientY - lookState.cy, lookState.radius);
        });
        const releaseLook = (event) => {
          if (event.pointerId !== lookState.id) return;
          resetLook();
        };
        mobileLookZone.addEventListener("pointerup", releaseLook);
        mobileLookZone.addEventListener("pointercancel", releaseLook);
        mobileLookZone.addEventListener("lostpointercapture", releaseLook);

        bindHoldButton(mobileJumpBtn, () => {
          keys.space = true;
          if (!energyLock) startJump();
        }, () => {
          keys.space = false;
        });
        bindHoldButton(mobileBoostBtn, () => {
          keys.shift = true;
        }, () => {
          keys.shift = false;
        });
        bindHoldButton(mobileFireLBtn, () => {
          armRaiseL = true;
          firingLeft = true;
        }, () => {
          armRaiseL = false;
          firingLeft = false;
        });
        bindHoldButton(mobileFireRBtn, () => {
          armRaiseR = true;
          firingRight = true;
        }, () => {
          armRaiseR = false;
          firingRight = false;
        });
        if (mobileMenuBtn) {
          mobileMenuBtn.addEventListener("click", (event) => {
            event.preventDefault();
            toggleMenu();
          });
        }
      }
      initMobileControls();

      document.body.addEventListener("click", () => {
        if (isTouchDevice) return;
        if (paused) return;
        if (document.pointerLockElement !== document.body) {
          document.body.requestPointerLock();
        }
      });
      renderer.domElement.addEventListener("click", () => {
        if (isTouchDevice) return;
        if (paused) return;
        if (document.pointerLockElement !== document.body) {
          document.body.requestPointerLock();
        }
      });
      window.addEventListener("mousedown", () => {
        if (isTouchDevice) return;
        if (paused) return;
        if (document.pointerLockElement !== document.body) {
          document.body.requestPointerLock();
        }
      });

    menuClose.addEventListener("click", () => {
      if (paused) toggleMenu();
    });

    menuTabs.forEach((tab) => {
      tab.addEventListener("click", () => {
        setActiveTab(tab.dataset.tab);
      });
    });

    const equipped = {};
    const statusCatalog = {
      "테스트용 머신핸드건": [
        ["무기 타입", "머신핸드건"],
        ["장탄수", "1000"],
        ["재장전 시간", "0.1초"],
        ["발사 방식", "13발 펠릿"],
        ["피해량", "펠릿 1000 + 폭발 500"],
        ["운용 메모", "좌/우 손 슬롯 장착 가능"]
      ]
    };

    assemblyItems.forEach((item) => {
      const labelEl = item.querySelector(".assemblyLabel");
      const slotName = item.dataset.slot || labelEl.textContent.trim();
      item.dataset.slot = slotName;
      item.dataset.defaultName = slotName;
      const currentName = labelEl.textContent.trim();
      if (currentName !== slotName) {
        equipped[slotName] = currentName;
      }
    });

    function isHandSlot(slotName) {
      return slotName.includes("우측 손") || slotName.includes("좌측 손");
    }

    function getStatusRows(slotName, equippedName) {
      if (equippedName && statusCatalog[equippedName]) {
        return statusCatalog[equippedName];
      }
      if (isHandSlot(slotName)) {
        return [
          ["무기 타입", "비어 있음"],
          ["장비 상태", "무장 해제"],
          ["안내", "소지한 파츠에서 장착 가능"]
        ];
      }
      return [
        ["슬롯", slotName],
        ["장비 상태", equippedName || "장착 없음"],
        ["안내", "해당 슬롯 데이터는 추후 확장 예정"]
      ];
    }

    function renderAssemblyStatus(slotName, equippedName) {
      if (!assemblyDetailStatus) return;
      assemblyDetailStatus.innerHTML = "";
      const rows = getStatusRows(slotName, equippedName);
      const wrap = document.createElement("div");
      wrap.className = "statusRows";
      rows.forEach(([keyName, valueText]) => {
        const row = document.createElement("div");
        row.className = "statusRow";
        const keyEl = document.createElement("div");
        keyEl.className = "key";
        keyEl.textContent = keyName;
        const valueEl = document.createElement("div");
        valueEl.className = "value";
        valueEl.textContent = valueText;
        row.appendChild(keyEl);
        row.appendChild(valueEl);
        wrap.appendChild(row);
      });
      assemblyDetailStatus.appendChild(wrap);
    }

    function renderAssemblyDetail(slotName) {
      assemblyDetailTitle.textContent = slotName;
      assemblyDetail.classList.add("active");
      assemblyDetailCurrent.innerHTML = "";
      assemblyDetailInventory.innerHTML = "";

      const current = document.createElement("div");
      current.className = "detailIcon";
      current.title = "현재 착용";
      assemblyDetailCurrent.appendChild(current);

      const equippedName = equipped[slotName];
      current.innerHTML = `<div class="assemblyLabel">${equippedName || "장착 없음"}</div>`;
      if (!equippedName) {
        current.style.opacity = "0.2";
      }

      if (isHandSlot(slotName)) {
        const inventory = document.createElement("div");
        inventory.className = "detailIcon";
        inventory.title = "테스트용 머신핸드건";
        inventory.innerHTML = "<div class=\"assemblyLabel\">테스트용 머신핸드건</div>";
        assemblyDetailInventory.appendChild(inventory);
        inventory.addEventListener("click", () => {
          equipped[slotName] = "테스트용 머신핸드건";
          current.style.opacity = "1";
          current.innerHTML = "<div class=\"assemblyLabel\">테스트용 머신핸드건</div>";
          const slotItem = assemblyItems.find((i) => i.dataset.slot === slotName);
          if (slotItem) {
            const icon = slotItem.querySelector(".assemblyIcon");
            const label = slotItem.querySelector(".assemblyLabel");
            icon.classList.add("machinehandgun");
            label.textContent = "테스트용 머신핸드건";
          }
          renderAssemblyStatus(slotName, equipped[slotName]);
        });
      } else {
        const empty = document.createElement("div");
        empty.className = "detailIcon";
        empty.style.opacity = "0.5";
        empty.innerHTML = "<div class=\"assemblyLabel\">호환 파츠 없음</div>";
        assemblyDetailInventory.appendChild(empty);
      }
      renderAssemblyStatus(slotName, equippedName);
      assemblyUnequip.disabled = !equippedName;
    }

    assemblyItems.forEach((item) => {
      item.addEventListener("click", () => {
        const slotName = item.dataset.slot || item.dataset.assembly || "파츠";
        renderAssemblyDetail(slotName);
      });
    });

    assemblyDetailClose.addEventListener("click", () => {
      assemblyDetail.classList.remove("active");
    });

    assemblyUnequip.addEventListener("click", () => {
      const name = assemblyDetailTitle.textContent || "";
      equipped[name] = null;
      const slotItem = assemblyItems.find((i) => i.dataset.slot === name);
      if (slotItem) {
        const icon = slotItem.querySelector(".assemblyIcon");
        const label = slotItem.querySelector(".assemblyLabel");
        icon.classList.remove("machinehandgun");
        label.textContent = slotItem.dataset.defaultName || name;
      }
      renderAssemblyDetail(name);
    });

    const previewScene = new THREE.Scene();
    previewScene.background = new THREE.Color(0x0f0f12);
    const previewCamera = new THREE.PerspectiveCamera(40, 1, 0.1, 100);
    previewCamera.position.set(0, 0.6, 5.6);
    const previewRenderer = new THREE.WebGLRenderer({ canvas: previewCanvas, antialias: true, alpha: true });
    previewRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const previewLight = new THREE.DirectionalLight(0xffffff, 0.9);
    previewLight.position.set(2, 4, 3);
    previewScene.add(new THREE.AmbientLight(0xffffff, 0.4), previewLight);

      const previewPivot = new THREE.Group();
      const previewDummy = dummy.clone(true);
      previewDummy.traverse((node) => {
        if (node.material) node.material = node.material.clone();
      });
      previewDummy.position.set(0, -1.1, 0);
      previewPivot.add(previewDummy);
      previewScene.add(previewPivot);
      const expansionSphere = new THREE.Mesh(
        new THREE.SphereGeometry(playerSize * 0.7, 24, 24),
        new THREE.MeshStandardMaterial({ color: 0xff3b3b, transparent: true, opacity: 0.2 })
      );
      expansionSphere.visible = false;
      scene.add(expansionSphere);
      const expansionParticles = [];
      let expansionParticleTimer = 0;
      const expansionParticleGeo = new THREE.BoxGeometry(0.04, 0.04, 0.04);
      const expansionParticleMat = new THREE.MeshStandardMaterial({
        color: 0xff4a4a,
        transparent: true,
        opacity: 0.8
      });

      const septiaGroup = new THREE.Group();
      scene.add(septiaGroup);
      const septiaDiamonds = [];
      const septiaBaseTotal = 72;
      const septiaTotal = 144;
      for (let i = 0; i < septiaTotal; i += 1) {
        const hue = (i % septiaBaseTotal) / septiaBaseTotal;
        const color = new THREE.Color().setHSL(hue, 0.75, 0.6);
        const mat = new THREE.MeshStandardMaterial({
          color,
          emissive: color,
          emissiveIntensity: 0.6,
          roughness: 0.35,
          metalness: 0.2
        });
        const d = new THREE.Mesh(new THREE.OctahedronGeometry(0.06), mat);
        d.userData.state = "idle";
        d.userData.timer = 0;
        d.userData.hitCount = 0;
        d.userData.nextHit = 1;
        d.userData.target = null;
        d.userData.extra = i >= septiaBaseTotal;
        septiaGroup.add(d);
        septiaDiamonds.push(d);
      }
    function resizePreview() {
      const rect = previewCanvas.getBoundingClientRect();
      const size = Math.max(200, Math.floor(Math.min(rect.width, rect.height)));
      previewRenderer.setSize(size, size, false);
      previewCamera.aspect = 1;
      previewCamera.updateProjectionMatrix();
    }
    resizePreview();

    let previewDragging = false;
    let previewLastX = 0;
    let previewLastY = 0;
    previewCanvas.addEventListener("mousedown", (e) => {
      previewDragging = true;
      previewCanvas.classList.add("dragging");
      previewLastX = e.clientX;
      previewLastY = e.clientY;
    });
    window.addEventListener("mouseup", () => {
      previewDragging = false;
      previewCanvas.classList.remove("dragging");
    });
    previewCanvas.addEventListener("mousemove", (e) => {
      if (!previewDragging) return;
      const dx = e.clientX - previewLastX;
      const dy = e.clientY - previewLastY;
      previewLastX = e.clientX;
      previewLastY = e.clientY;
      previewRotY += dx * 0.01;
      previewRotX += dy * 0.01;
      previewRotX = clamp(previewRotX, -0.8, 0.8);
    });

    function populateGrid(container, prefix, total = 50) {
      for (let i = 1; i <= total; i += 1) {
        const item = document.createElement("div");
        item.className = "gridItem";
        item.dataset.name = `${prefix} ${i}`;
        item.innerHTML = `
          <div class="gridIcon"></div>
          <div class="gridLabel">${prefix} ${i}</div>
        `;
        container.appendChild(item);
      }
    }

    function getCoreIconClass(name) {
      if (name.includes("피닉스")) return "core-phoenix";
      if (name.includes("라이거")) return "core-liger";
      if (name.includes("현무")) return "core-hyunmu";
      if (name.includes("드라군")) return "core-dragoon";
      return "";
    }

    function getBossIconClass(name) {
      if (name.includes("피닉스")) return "boss-phoenix";
      if (name.includes("라이거")) return "boss-liger";
      if (name.includes("현무")) return "boss-hyunmu";
      if (name.includes("드라군")) return "boss-dragoon";
      return "";
    }

    function buildBossGlyphSvg(name) {
      if (name.includes("피닉스")) {
        return `<svg viewBox="0 0 64 64" aria-hidden="true"><path d="M32 11l6 7 9 4-7 3-3 5-5-4-5 4-3-5-7-3 9-4z"/><path d="M14 34l11-3 7 5 7-5 11 3-8 7-10 2-10-2z"/><path d="M24 44l8 3 8-3-3 8h-10z"/></svg>`;
      }
      if (name.includes("라이거")) {
        return `<svg viewBox="0 0 64 64" aria-hidden="true"><path d="M18 24l6-4 8 2 8-2 6 4 2 10-6 8H22l-6-8z"/><path d="M22 42l8 0 2 6-8 0zM34 42l8 0-2 6-8 0z"/><path d="M24 28l6 3 4-1 6-3-4 7-2 1-4 0-2-1z"/></svg>`;
      }
      if (name.includes("현무")) {
        return `<svg viewBox="0 0 64 64" aria-hidden="true"><path d="M18 29l10-8h8l10 8-2 11-10 8H30l-10-8z"/><path d="M24 31h16v8H24z"/><path d="M14 34l-4 2 4 2zM50 34l4 2-4 2z"/><path d="M30 18l2-6 2 6zM30 52l2 4 2-4z"/></svg>`;
      }
      if (name.includes("드라군")) {
        return `<svg viewBox="0 0 64 64" aria-hidden="true"><path d="M14 42l8-8 10-2 8-10 8 2-5 7 9 4-8 2-6 8-10-1-8 5z"/><path d="M24 33l6-7 7 1-5 6z"/><path d="M30 44l7 2-4 6-7-2z"/></svg>`;
      }
      return `<svg viewBox="0 0 64 64" aria-hidden="true"><circle cx="32" cy="32" r="12"/></svg>`;
    }

    function buildEntryIconHtml(entryType, name, iconBaseClass = "gridIcon") {
      if (entryType === "item_core" || entryType === "codex_core") {
        const coreClass = getCoreIconClass(name || "");
        return `<div class="${iconBaseClass} coreModel ${coreClass}"><div class="coreGem"></div></div>`;
      }
      if (entryType === "codex_boss") {
        const bossClass = getBossIconClass(name || "");
        return `<div class="${iconBaseClass} bossModel ${bossClass}"><div class="bossSig">${buildBossGlyphSvg(name || "")}</div></div>`;
      }
      return `<div class="${iconBaseClass}"></div>`;
    }

    function applyDetailIcon(detailIconEl, entryType, baseName) {
      if (!detailIconEl) return;
      detailIconEl.innerHTML = "";
      detailIconEl.className = "detailIconLarge";
      if (entryType === "codex_boss") {
        const bossClass = getBossIconClass(baseName || "");
        const unlockCoreName = codexBossUnlockByCore[baseName];
        const unlocked = unlockCoreName ? !!bossCoreCodexUnlocked[unlockCoreName] : true;
        detailIconEl.classList.add("bossModel");
        if (!unlocked) detailIconEl.classList.add("locked");
        if (bossClass) detailIconEl.classList.add(bossClass);
        detailIconEl.innerHTML = `<div class="bossSig">${buildBossGlyphSvg(baseName || "")}</div>`;
        return;
      }
      if (entryType === "item_core" || entryType === "codex_core") {
        const coreClass = getCoreIconClass(baseName || "");
        const unlocked = entryType === "item_core"
          ? true
          : (isBossCoreName(baseName) ? bossCoreCodexUnlocked[baseName] : true);
        detailIconEl.classList.add("coreModel");
        if (!unlocked) detailIconEl.classList.add("coreLocked");
        if (coreClass) detailIconEl.classList.add(coreClass);
        detailIconEl.innerHTML = `<div class="coreGem"></div>`;
      }
    }

    function populateGridEntries(container, entries) {

      entries.forEach((entry) => {
        const item = document.createElement("div");
        item.className = "gridItem";
        item.dataset.baseName = entry.name || "항목";
        item.dataset.baseDesc = entry.desc || "";
        item.dataset.entryType = entry.entryType || "generic";
        item.dataset.name = entry.name || "항목";
        item.dataset.desc = entry.desc || "";
        item.innerHTML = `
          ${buildEntryIconHtml(entry.entryType || "generic", entry.name || "항목")}
          <div class="gridLabel">${entry.name || "항목"}</div>
        `;
        container.appendChild(item);
      });
    }

    const rareBossCodexEntries = [
      { name: "피닉스", desc: "피닉스 레어의 보스. 코랄/화염 속성을 사용하며 폭발과 화염 근접 패턴이 강력하다.", entryType: "codex_boss" },
      { name: "라이거", desc: "라이거 레어의 보스. 플라즈마/감전 속성을 사용해 돌진 후 전격 압박을 이어간다.", entryType: "codex_boss" },
      { name: "현무", desc: "현무 레어의 보스. 산성/코지마 속성을 사용하며 장기 지속 지역 제어에 특화되어 있다.", entryType: "codex_boss" },
      { name: "드라군", desc: "드라군 레어의 보스. 레이저/빙결 속성을 사용해 원거리 관통과 감속 압박을 수행한다.", entryType: "codex_boss" },
      { name: "피닉스 코어", desc: "화염 속성 특징을 지닌 보스 코어. 고온 잔열이 내부에 응축되어 있다.", entryType: "codex_core" },
      { name: "라이거 코어", desc: "감전 속성 특징을 지닌 보스 코어. 전하가 축적되어 주기적으로 스파크를 튄다.", entryType: "codex_core" },
      { name: "현무 코어", desc: "산성 속성 특징을 지닌 보스 코어. 부식성 에너지가 점성 있게 맴돈다.", entryType: "codex_core" },
      { name: "드라군 코어", desc: "빙결 속성 특징을 지닌 보스 코어. 내부 온도가 매우 낮아 냉기가 번져 나온다.", entryType: "codex_core" }
    ];

    const rareBossItemEntries = [
      { name: "피닉스 코어", desc: "피닉스 처치 보상. 화염 속성 특징을 지닌 핵심 코어.", entryType: "item_core" },
      { name: "라이거 코어", desc: "라이거 처치 보상. 감전 속성 특징을 지닌 핵심 코어.", entryType: "item_core" },
      { name: "현무 코어", desc: "현무 처치 보상. 산성 속성 특징을 지닌 핵심 코어.", entryType: "item_core" },
      { name: "드라군 코어", desc: "드라군 처치 보상. 빙결 속성 특징을 지닌 핵심 코어.", entryType: "item_core" }
    ];

    function isBossCoreName(name) {
      return Object.prototype.hasOwnProperty.call(bossCoreInventory, name);
    }

    function isCodexBossUnlocked(name) {
      const coreName = codexBossUnlockByCore[name];
      if (!coreName) return true;
      return !!bossCoreCodexUnlocked[coreName];
    }

    function getEntryDisplayName(entryType, baseName) {
      if (entryType === "item_core" && isBossCoreName(baseName)) {
        return `${baseName} x${bossCoreInventory[baseName]}`;
      }
      if (entryType === "codex_core" && isBossCoreName(baseName)) {
        return `${baseName} ${bossCoreCodexUnlocked[baseName] ? "[해금]" : "[미해금]"}`;
      }
      return baseName;
    }

    function getEntryDisplayDesc(entryType, baseName, baseDesc) {
      if (entryType === "item_core" && isBossCoreName(baseName)) {
        if (bossCoreInventory[baseName] <= 0) return "-";
        return `${baseDesc} 현재 보유 수량: ${bossCoreInventory[baseName]}`;
      }
      if (entryType === "codex_core" && isBossCoreName(baseName)) {
        if (!bossCoreCodexUnlocked[baseName]) return "-";
        return baseDesc;
      }
      if (entryType === "codex_boss") {
        if (!isCodexBossUnlocked(baseName)) return "-";
        return baseDesc;
      }
      return baseDesc || `${baseName}의 설명이 이 영역에 표시됩니다.`;
    }

    function refreshCoreCollectionUI() {
      const allCodexItemEntries = document.querySelectorAll(".gridItem[data-entry-type='item_core'], .gridItem[data-entry-type='codex_core'], .gridItem[data-entry-type='codex_boss']");
      allCodexItemEntries.forEach((entry) => {
        const baseName = entry.dataset.baseName || entry.dataset.name || "항목";
        const entryType = entry.dataset.entryType || "generic";
        const baseDesc = entry.dataset.baseDesc || "";
        const unlocked = isBossCoreName(baseName)
          ? (entryType === "item_core" ? bossCoreInventory[baseName] > 0 : bossCoreCodexUnlocked[baseName])
          : true;
        const bossUnlocked = entryType === "codex_boss" ? isCodexBossUnlocked(baseName) : true;
        if (entryType === "item_core") {
          entry.style.display = unlocked ? "" : "none";
        }
        entry.dataset.name = getEntryDisplayName(entryType, baseName);
        entry.dataset.desc = getEntryDisplayDesc(entryType, baseName, baseDesc);
        const label = entry.querySelector(".gridLabel");
        if (label) label.textContent = entry.dataset.name;
        const iconEl = entry.querySelector(".gridIcon");
        if (iconEl) {
          if (entryType === "item_core") {
            iconEl.classList.remove("coreLocked");
          } else if (entryType === "codex_core" && !unlocked) {
            iconEl.classList.add("coreLocked");
          } else {
            iconEl.classList.remove("coreLocked");
          }
          if (entryType === "codex_boss" && !bossUnlocked) {
            iconEl.classList.add("locked");
          } else {
            iconEl.classList.remove("locked");
          }
        }
      });

      const codexBaseName = codexDetailName.dataset.baseName || "";
      const codexEntryType = codexDetailName.dataset.entryType || "";
      const codexBaseDesc = codexDetailDesc.dataset.baseDesc || codexDetailDesc.textContent || "";
      if ((codexEntryType === "codex_core" && isBossCoreName(codexBaseName)) || codexEntryType === "codex_boss") {
        codexDetailName.textContent = getEntryDisplayName(codexEntryType, codexBaseName);
        codexDetailDesc.textContent = getEntryDisplayDesc(codexEntryType, codexBaseName, codexBaseDesc);
        applyDetailIcon(codexDetailIcon, codexEntryType, codexBaseName);
      }

      const itemBaseName = itemDetailName.dataset.baseName || "";
      const itemEntryType = itemDetailName.dataset.entryType || "";
      const itemBaseDesc = itemDetailDesc.dataset.baseDesc || itemDetailDesc.textContent || "";
      if (itemEntryType === "item_core" && isBossCoreName(itemBaseName)) {
        itemDetailName.textContent = getEntryDisplayName(itemEntryType, itemBaseName);
        itemDetailDesc.textContent = getEntryDisplayDesc(itemEntryType, itemBaseName, itemBaseDesc);
        applyDetailIcon(itemDetailIcon, itemEntryType, itemBaseName);
      }
    }

    populateGridEntries(codexGridWrap, rareBossCodexEntries);
    populateGrid(codexGridWrap, "도감", 42);
    populateGridEntries(itemGridWrap, rareBossItemEntries);
    populateGrid(itemGridWrap, "아이템", 46);
    populateGrid(shopGridWrap, "상점");
    refreshCoreCollectionUI();

    function bindGrid(gridEl, nameEl, descEl, iconEl) {
      gridEl.addEventListener("click", (event) => {
        const target = event.target.closest(".gridItem");
        if (!target) return;
        const entryType = target.dataset.entryType || "generic";
        const baseName = target.dataset.baseName || target.dataset.name || "항목";
        const baseDesc = target.dataset.baseDesc || target.dataset.desc || "";
        nameEl.dataset.entryType = entryType;
        nameEl.dataset.baseName = baseName;
        descEl.dataset.baseDesc = baseDesc;
        nameEl.textContent = getEntryDisplayName(entryType, baseName);
        descEl.textContent = getEntryDisplayDesc(entryType, baseName, baseDesc);
        applyDetailIcon(iconEl, entryType, baseName);
      });
    }

    bindGrid(codexGrid, codexDetailName, codexDetailDesc, codexDetailIcon);
    bindGrid(itemGrid, itemDetailName, itemDetailDesc, itemDetailIcon);
    bindGrid(shopGrid, shopDetailName, shopDetailDesc, shopDetailIcon);

    function enableDragScroll(container) {
      let isDown = false;
      let startY = 0;
      let scrollTop = 0;

      container.addEventListener("mousedown", (e) => {
        isDown = true;
        container.classList.add("dragging");
        startY = e.pageY - container.offsetTop;
        scrollTop = container.scrollTop;
      });
      window.addEventListener("mouseup", () => {
        isDown = false;
        container.classList.remove("dragging");
      });
      container.addEventListener("mouseleave", () => {
        isDown = false;
        container.classList.remove("dragging");
      });
      container.addEventListener("mousemove", (e) => {
        if (!isDown) return;
        e.preventDefault();
        const y = e.pageY - container.offsetTop;
        const walk = (y - startY) * 1.2;
        container.scrollTop = scrollTop - walk;
      });
    }

    enableDragScroll(codexGrid);
    enableDragScroll(itemGrid);
    enableDragScroll(shopGrid);

    document.addEventListener("pointerlockchange", () => {
      if (document.pointerLockElement === document.body) {
        if (hint) hint.style.display = "none";
        document.addEventListener("mousemove", onMouseMove);
      } else {
        if (hint) hint.style.display = "none";
        document.removeEventListener("mousemove", onMouseMove);
      }
    });

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      resizePreview();
    });

      function updateStamina(delta) {
        if (paused) return;
        let enConsuming = false;
        const movingInput = keys.w || keys.a || keys.s || keys.d;
        const sprintingInput = keys.shift && movingInput;
        const dashingInput = keys.shift && keys.space;
        const flyingInput = keys.shift && keys.w && !dashingInput;
        const now = performance.now() / 1000;

        const hoverInput = keys.shift && !player.grounded && !flyingInput;
        if (staminaCooldown) {
          // Stamina keeps recharging; actions consume EN instead.
          let cost = 0;
          if (sprintingInput) cost += 8 * delta;
          if (hoverInput) cost += 0.4 * delta;
          if (flyingInput) cost += 10 * delta;
          if (cost > 0 && en > 0) {
            enConsuming = true;
            consumeEnergy(cost, now);
          }
          stamina = Math.min(100, stamina + 40 * delta);
          if (stamina >= 100) {
            staminaCooldown = false;
          }
        } else {
          if (flyingInput) {
            consumeEnergy(10 * delta, now);
          } else if (hoverInput) {
            consumeEnergy(0.4 * delta, now);
          } else if (sprintingInput && stamina > 0) {
            consumeEnergy(8 * delta, now);
          } else {
            stamina = Math.min(100, stamina + 25.6 * delta);
          }
        }

        if (playerShockDrainPending > 0 && !playerHasActivePaShield()) {
          const drain = Math.min(playerShockDrainPending, 6 * delta);
          stamina = Math.max(0, stamina - drain);
          playerShockDrainPending -= drain;
          if (stamina <= 0) {
            stamina = 0;
            staminaCooldown = true;
            staminaCooldownEnd = now + 10;
          }
        }
        if (playerEnDrainPending > 0 && !playerHasActivePaShield()) {
          const drain = Math.min(playerEnDrainPending, 6 * delta);
          en = Math.max(0, en - drain);
          playerEnDrainPending -= drain;
          if (en <= 0) {
            en = 0;
            enCooldown = true;
          }
        }

        staminaFill.style.width = `${stamina.toFixed(1)}%`;
        staminaFill.style.background = staminaCooldown ? "#ff4b4b" : "#ffd93d";
        if (enFill) {
          if (!enConsuming) {
            en = Math.min(100, en + 25.6 * delta);
            if (en >= 100) {
              enCooldown = false;
            }
          }
          enFill.style.width = `${en.toFixed(1)}%`;
          enFill.style.background = enCooldown ? "#ff4b4b" : "#4aa3ff";
        }
        if (!energyLock && staminaCooldown && enCooldown) {
          energyLock = true;
        }
        if (energyLock && (stamina >= 100 || en >= 100)) {
          energyLock = false;
        }
        if (frameNow < expansionActiveUntil) {
          energyLock = false;
        }
        if (energyWarning) {
          energyWarning.style.display = energyLock ? "block" : "none";
        }
        if (apWarning) {
          apWarning.style.display = frameNow < apCriticalUntil ? "block" : "none";
        }
      }

      const clock = new THREE.Clock();
      function animate() {
        const delta = Math.min(clock.getDelta(), 0.033);
        const now = performance.now() / 1000;
        const sensoryBlind = now < blackOutFullUntil || now < whiteOutFullUntil;
        const effectiveAutoAim = autoAimMode && !sensoryBlind;
        updateAimModeDisplay(sensoryBlind);
        frameNow = now;
        const playerRoomIndex = getRoomIndexForPos(player.position);
        applyMovement(delta);
        updateStamina(delta);
        updateCamera();

      if (minimapCtx) {
          const size = Math.min(minimapCanvas.clientWidth || 320, minimapCanvas.clientHeight || 320);
          if (minimapCanvas.width !== size) minimapCanvas.width = size;
          if (minimapCanvas.height !== size) minimapCanvas.height = size;
          const ctx = minimapCtx;
          ctx.clearRect(0, 0, size, size);
          ctx.save();
          ctx.beginPath();
          ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
          ctx.clip();
          ctx.fillStyle = "rgba(6,6,10,0.8)";
          ctx.fillRect(0, 0, size, size);
          if (now < minimapBlindUntil) {
            ctx.fillStyle = "rgba(0,0,0,0.98)";
            ctx.fillRect(0, 0, size, size);
            ctx.restore();
          } else {
          const radiusUnits = 5 * cellSize;
          const scale = size / (radiusUnits * 2);
          const centerX = size / 2;
          const centerY = size / 2;
          ctx.save();
          ctx.translate(centerX, centerY);
          ctx.rotate(yaw);
          ctx.translate(-centerX, -centerY);
          // room tiles
          for (let i = 0; i < rooms.length; i += 1) {
            const room = rooms[i];
            const dx = room.x - player.position.x;
            const dz = room.z - player.position.z;
            const rx = centerX + dx * scale - (roomSize * scale) / 2;
            const rz = centerY + dz * scale - (roomSize * scale) / 2;
            ctx.fillStyle = `#${roomColors[i].toString(16).padStart(6, "0")}`;
            ctx.globalAlpha = 0.25;
            ctx.fillRect(rx, rz, roomSize * scale, roomSize * scale);
            ctx.globalAlpha = 0.6;
            ctx.strokeStyle = "rgba(255,255,255,0.25)";
            ctx.strokeRect(rx, rz, roomSize * scale, roomSize * scale);
          }
          // enemies on minimap
          const mmRange = radiusUnits;
          const visibleDots = [];
          ctx.globalAlpha = 1;
          const minimapHostiles = [...enemies, ...bosses];
          for (const enemy of minimapHostiles) {
            const dx = enemy.mesh.position.x - player.position.x;
            const dz = enemy.mesh.position.z - player.position.z;
            const dist = Math.hypot(dx, dz);
            const angle = Math.atan2(dx, dz);
            const rotX = Math.sin(angle) * dist;
            const rotZ = Math.cos(angle) * dist;
            if (dist <= mmRange) {
              const ex = centerX + rotX * scale;
              const ez = centerY + rotZ * scale;
              ctx.fillStyle = "rgba(255,60,60,0.9)";
              ctx.beginPath();
              ctx.arc(ex, ez, 2.5, 0, Math.PI * 2);
              ctx.fill();
              visibleDots.push({ target: enemy, x: ex, y: ez });
            } else {
              const ex = centerX + (rotX / dist) * mmRange * scale;
              const ez = centerY + (rotZ / dist) * mmRange * scale;
              ctx.fillStyle = "rgba(255,60,60,0.7)";
              ctx.beginPath();
              ctx.arc(ex, ez, 3, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          // lock-on attackers direction on minimap edge
          for (const enemy of minimapHostiles) {
            const dx = enemy.mesh.position.x - player.position.x;
            const dz = enemy.mesh.position.z - player.position.z;
            const dist = Math.hypot(dx, dz);
            const targeting = playerRoomIndex === enemy.roomIndex && dist <= 7.5;
            if (!targeting) continue;
            const angle = Math.atan2(dx, dz);
            const ex = centerX + Math.sin(angle) * mmRange * scale;
            const ez = centerY + Math.cos(angle) * mmRange * scale;
            ctx.fillStyle = "rgba(255,120,120,0.9)";
            ctx.beginPath();
            ctx.moveTo(ex, ez);
            ctx.lineTo(ex + Math.sin(angle + Math.PI / 2) * 4, ez + Math.cos(angle + Math.PI / 2) * 4);
            ctx.lineTo(ex + Math.sin(angle - Math.PI / 2) * 4, ez + Math.cos(angle - Math.PI / 2) * 4);
            ctx.closePath();
            ctx.fill();
          }
          // lock-on ring on minimap
          for (const dot of visibleDots) {
            if (lockTargets.length > 0 && lockTargets.some((t) => t.target === dot.target)) {
              ctx.strokeStyle = "rgba(255,60,60,0.9)";
              ctx.lineWidth = 1.5;
              ctx.beginPath();
              ctx.arc(dot.x, dot.y, 5.5, 0, Math.PI * 2);
              ctx.stroke();
            }
          }
          // grid lines
          ctx.globalAlpha = 0.25;
          ctx.strokeStyle = "rgba(255,255,255,0.2)";
          ctx.lineWidth = 1;
          for (let gx = -radiusUnits; gx <= radiusUnits; gx += cellSize) {
            const x = centerX + gx * scale;
            ctx.beginPath();
            ctx.moveTo(x, centerY - radiusUnits * scale);
            ctx.lineTo(x, centerY + radiusUnits * scale);
            ctx.stroke();
          }
          for (let gz = -radiusUnits; gz <= radiusUnits; gz += cellSize) {
            const y = centerY + gz * scale;
            ctx.beginPath();
            ctx.moveTo(centerX - radiusUnits * scale, y);
            ctx.lineTo(centerX + radiusUnits * scale, y);
            ctx.stroke();
          }
          // radius ring
          ctx.globalAlpha = 1;
          ctx.strokeStyle = "rgba(255,255,255,0.2)";
          ctx.beginPath();
          ctx.arc(centerX, centerY, radiusUnits * scale, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
          // view cone (funnel) fixed upward
          ctx.globalAlpha = 0.25;
          ctx.fillStyle = "rgba(255,255,255,0.2)";
          const coneLen = radiusUnits * 1.0 * scale;
          const coneHalf = Math.PI / 4;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(centerX + Math.cos(-Math.PI / 2 - coneHalf) * coneLen, centerY + Math.sin(-Math.PI / 2 - coneHalf) * coneLen);
          ctx.arc(centerX, centerY, coneLen, -Math.PI / 2 - coneHalf, -Math.PI / 2 + coneHalf);
          ctx.closePath();
          ctx.fill();
          // player
          ctx.fillStyle = "#ffffff";
          ctx.beginPath();
          ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
          ctx.fill();
          const roomName = roomDisplayNames[playerRoomIndex];
          if (roomName) {
            ctx.globalAlpha = 1;
            ctx.font = "700 14px 'Segoe UI', 'Malgun Gothic', sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";
            ctx.fillStyle = "rgba(240,240,240,0.95)";
            ctx.strokeStyle = "rgba(0,0,0,0.85)";
            ctx.lineWidth = 3;
            ctx.strokeText(roomName, centerX, size - 8);
            ctx.fillText(roomName, centerX, size - 8);
          }
          ctx.restore();
          }
        }

        const forward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
        const right = new THREE.Vector3(Math.sin(yaw + Math.PI / 2), 0, Math.cos(yaw + Math.PI / 2));
        const up = new THREE.Vector3(0, 1, 0);
        const localForward = new THREE.Vector3(0, 0, -1);
        const localBack = new THREE.Vector3(0, 0, 1);
        const localRight = new THREE.Vector3(1, 0, 0);
        const localUp = new THREE.Vector3(0, 1, 0);
        const septiaAnchors = [
          localBack.clone().multiplyScalar(0.55).addScaledVector(localRight, -0.35).addScaledVector(localUp, 0.95),
          localBack.clone().multiplyScalar(0.55).addScaledVector(localRight, -0.45).addScaledVector(localUp, 0.65),
          localBack.clone().multiplyScalar(0.55).addScaledVector(localRight, -0.35).addScaledVector(localUp, 0.35),
          localBack.clone().multiplyScalar(0.55).addScaledVector(localRight, 0.35).addScaledVector(localUp, 0.95),
          localBack.clone().multiplyScalar(0.55).addScaledVector(localRight, 0.45).addScaledVector(localUp, 0.65),
          localBack.clone().multiplyScalar(0.55).addScaledVector(localRight, 0.35).addScaledVector(localUp, 0.35)
        ];
        septiaGroup.position.copy(player.position);
        septiaGroup.rotation.set(0, yaw, cameraRoll, "YXZ");
        septiaFireCooldown -= delta;
        const septiaExpanded = now < expansionActiveUntil;
        if (septiaFiring && septiaFireCooldown <= 0 && (en > 0 || septiaExpanded) && !energyLock) {
          const available = septiaDiamonds.find((d) => d.userData.state === "idle" && (!d.userData.extra || septiaExpanded));
          if (available) {
            const septiaTarget = findSeptiaTarget(player.position, 150);
            if (!septiaTarget) {
              septiaFireCooldown = 0;
            } else {
            if (now >= expansionActiveUntil) {
              en = Math.max(0, en - 0.5);
            }
            septiaFireCooldown = septiaExpanded ? 0.0125 : 0.025;
            available.userData.state = "attack";
            available.userData.timer = 0;
            available.userData.hitCount = 0;
            available.userData.nextHit = 1;
            available.userData.hitLimit = septiaExpanded ? 6 : 3;
            available.userData.nextHitAt = now + 1;
            available.userData.attackStartAt = now;
            available.userData.engageUntil = now + available.userData.hitLimit;
            available.userData.target = septiaTarget;
            available.userData.dir = new THREE.Vector3(
              -Math.sin(yaw) * Math.cos(pitch),
              Math.sin(pitch),
              -Math.cos(yaw) * Math.cos(pitch)
            ).normalize();
            available.userData.worldPos = null;
            }
          }
        }
        let idleCount = 0;
        let totalActive = septiaExpanded ? septiaTotal : septiaBaseTotal;
        for (let i = 0; i < septiaDiamonds.length; i += 1) {
          const d = septiaDiamonds[i];
          const active = !d.userData.extra || septiaExpanded;
          d.visible = active;
          if (!active) continue;
          const localIndex = d.userData.extra ? i - septiaBaseTotal : i;
          const wing = Math.floor(localIndex / 12);
          const idx = localIndex % 12;
          const wingSide = wing < 3 ? -1 : 1;
          const base = septiaAnchors[wing].clone();
          const spread = d.userData.extra ? 1.2 : 1;
          const colHeights = [1, 2, 3, 3, 2, 1];
          let col = 0;
          let rowInCol = idx;
          for (let c = 0; c < colHeights.length; c += 1) {
            if (rowInCol < colHeights[c]) {
              col = c;
              break;
            }
            rowInCol -= colHeights[c];
          }
          const colCount = colHeights[col];
          const colCenter = (colCount - 1) / 2;
          const sizeScale = (wing === 0 || wing === 3 || wing === 2 || wing === 5) ? 0.7 : 1;
          let x = (col - 2.5) * 0.14 * spread * sizeScale;
          if (wing === 0 || wing === 2) {
            x = -x;
          }
          const y = (rowInCol - colCenter) * 0.09 * spread;
          let tilt = 0;
          if (wing === 0 || wing === 3 || wing === 2 || wing === 5) {
            const endSign = (col - 2.5) / 2.5;
            const tiltAmount = 0.25;
            if (wing === 3 || wing === 5) {
              tilt = endSign * tiltAmount;
            } else {
              tilt = -endSign * tiltAmount;
            }
            if (wing === 2 || wing === 5) {
              tilt = -tilt;
            }
          }
          const offset = base
            .addScaledVector(localRight, wingSide * x)
            .addScaledVector(localUp, y + tilt);
          const basePos = offset;
          if (d.userData.state === "idle") {
            d.position.copy(basePos);
            d.userData.worldPos = null;
            idleCount += 1;
          } else {
            d.userData.timer += delta;
            const t = d.userData.timer;
            const baseWorld = septiaGroup.localToWorld(basePos.clone());
            let target = d.userData.target;
            const limit = d.userData.hitLimit || 6;
            let targetAlive = isSeptiaTargetAlive(target);
            const engageUntil = d.userData.engageUntil || (now + limit);
            const attackWindow = now < engageUntil && d.userData.hitCount < limit;
            if (!d.userData.worldPos) {
              d.userData.worldPos = baseWorld.clone();
            }
            if (attackWindow && !targetAlive) {
              const seekFrom = d.userData.worldPos ? d.userData.worldPos.clone() : baseWorld.clone();
              const retarget = findSeptiaTarget(seekFrom, 150);
              if (isSeptiaTargetAlive(retarget)) {
                d.userData.target = retarget;
                target = retarget;
                targetAlive = true;
                d.userData.nextHitAt = Math.min(d.userData.nextHitAt || (now + 1), now + 0.12);
              } else {
                d.userData.target = null;
                target = null;
              }
            }
            if (attackWindow) {
              if (targetAlive) {
                d.userData.worldPos.lerp(target.mesh.position, Math.min(1, 14 * delta));
              } else {
                d.userData.worldPos.lerp(baseWorld, Math.min(1, 3.2 * delta));
              }
            } else {
              d.userData.worldPos.lerp(baseWorld, Math.min(1, 3.2 * delta));
            }
            const localPos = septiaGroup.worldToLocal(d.userData.worldPos.clone());
            d.position.copy(localPos);
            if (targetAlive && now >= (d.userData.nextHitAt || (now + 1)) && d.userData.hitCount < limit) {
              if (target) {
                applySeptiaDamage(target, septiaExpanded ? 325 : 250, target.mesh.position.clone());
              }
              d.userData.hitCount += 1;
              d.userData.nextHit += 1;
              d.userData.nextHitAt = (d.userData.nextHitAt || now) + 1;
            }
            const returned = d.userData.worldPos.distanceTo(baseWorld) <= 0.08;
            if ((!attackWindow && returned) || now >= (engageUntil + 3)) {
              d.userData.state = "idle";
              d.userData.target = null;
              d.userData.worldPos = null;
              d.userData.nextHitAt = 0;
              d.userData.attackStartAt = 0;
              d.userData.engageUntil = 0;
            }
          }
        }
        if (septiaCountEl) septiaCountEl.textContent = `${idleCount}`;
        if (septiaGaugeEl) {
          septiaGaugeEl.style.transform = `scaleY(${idleCount / totalActive})`;
        }

        for (let i = 1; i <= 4; i += 1) {
          const nextSpawn = destructibleSpawnTimers.get(i) || 0;
          if (now >= nextSpawn) {
            spawnDestructibleInRoom(i);
            destructibleSpawnTimers.set(i, now + 10 + Math.random() * 50);
          }
        }
        enemyTypes.forEach((type) => {
          const roomEnemies = enemies.filter((e) => e.roomIndex === type.roomIndex);
          if (roomEnemies.length >= 30) return;
          const nextSpawn = enemySpawnTimers.get(type.roomIndex) || 0;
          if (now >= nextSpawn) {
            spawnEnemy(type);
            enemySpawnTimers.set(type.roomIndex, now + 10 + Math.random() * 10);
          }
        });

        let anyThreat = false;
        const threatDirs = [];
        for (const enemy of enemies) {
          const enemyPos = enemy.mesh.position;
          const prevEnemyPos = enemyPos.clone();
          const dist = enemyPos.distanceTo(player.position);
          const targeting = playerRoomIndex === enemy.roomIndex && dist <= 7.5;
          if (targeting) anyThreat = true;
          if (now >= enemy.nextMoveUpdate) {
            if (targeting) {
              enemy.moveTarget = player.position.clone();
            } else {
              enemy.moveTarget = randomPointInRoom(enemy.roomIndex);
            }
            enemy.nextMoveUpdate = now + 0.3 + Math.random() * 0.4;
          }
          const desired = enemy.moveTarget.clone();
          const toTarget = desired.sub(enemyPos);
          if (toTarget.lengthSq() > 0.0001) {
            const freezeFactor = getEnemyFreezeFactor(enemy, now);
            const moveStep = Math.min(enemyMoveSpeed * freezeFactor * delta, toTarget.length());
            toTarget.normalize().multiplyScalar(moveStep);
            enemyPos.add(toTarget);
          }
          if (targeting && dist < enemyAvoidRadius) {
            const pushDir = enemyPos.clone().sub(player.position).normalize();
            enemyPos.copy(player.position.clone().addScaledVector(pushDir, enemyAvoidRadius));
          }
          const bounds = getRoomBounds(enemy.roomIndex);
          enemyPos.x = clamp(enemyPos.x, bounds.minX, bounds.maxX);
          enemyPos.z = clamp(enemyPos.z, bounds.minZ, bounds.maxZ);
          enemyPos.y = floorY + enemyRadius;
          enemy.velocity.copy(enemyPos.clone().sub(prevEnemyPos).divideScalar(Math.max(delta, 0.0001)));

          if (enemy.label) {
            enemy.label.textContent = `AP ${Math.ceil(enemy.ap)} / PA ${Math.ceil(enemy.pa)}`;
            const labelPos = enemyPos.clone().add(new THREE.Vector3(0, enemyRadius + 0.4, 0));
            labelPos.project(camera);
            const x = (labelPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-labelPos.y * 0.5 + 0.5) * window.innerHeight;
            enemy.label.style.left = `${x}px`;
            enemy.label.style.top = `${y}px`;
            enemy.label.style.transform = "translate(-50%, -100%)";
            enemy.label.style.display = (!sensoryBlind && labelPos.z < 1) ? "block" : "none";
            enemy.label.classList.toggle("locked", enemy === lockTarget);
          }


          if (enemy.glow) {
            enemy.glow.material.opacity = 0;
          }

          if (now >= enemy.chargeStart && now < enemy.nextBeam) {
            const t = (now - enemy.chargeStart) / 10;
            const whiteT = Math.min(1, t / 0.8);
            const color = enemy.baseColor.clone().lerp(new THREE.Color(0xffffff), whiteT);
            if (enemy.core) enemy.core.material.color.copy(color);
          } else {
            if (enemy.core) enemy.core.material.color.copy(enemy.baseColor);
          }

          if (targeting && now >= enemy.nextBall && dist <= 10) {
            const dir = player.position.clone().sub(enemyPos).normalize();
            const ballSubtype = enemy.ballSubtype || DAMAGE_SUBTYPE.PULSE;
            const ballProfile = ATTRIBUTE_PROFILE[ballSubtype] || ATTRIBUTE_PROFILE.pulse;
            let ball;
            if (ballSubtype === DAMAGE_SUBTYPE.SHOCK || ballSubtype === DAMAGE_SUBTYPE.FREEZE) {
              ball = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 0.5, 10),
                new THREE.MeshStandardMaterial({
                  color: ballProfile.color || enemy.baseColor,
                  emissive: ballProfile.particleColor || ballProfile.color || enemy.baseColor,
                  emissiveIntensity: 0.45
                })
              );
              const up = new THREE.Vector3(0, 1, 0);
              ball.quaternion.setFromUnitVectors(up, dir);
            } else if (ballSubtype === DAMAGE_SUBTYPE.ACID) {
              const group = new THREE.Group();
              const outer = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.08, 0.55, 12),
                new THREE.MeshStandardMaterial({ color: 0x7a7a7a, transparent: true, opacity: 0.45 })
              );
              const inner = new THREE.Mesh(
                new THREE.CylinderGeometry(0.04, 0.04, 0.5, 12),
                new THREE.MeshStandardMaterial({ color: 0x50ff6a, emissive: 0x50ff6a, emissiveIntensity: 0.55 })
              );
              group.add(outer, inner);
              const up = new THREE.Vector3(0, 1, 0);
              group.quaternion.setFromUnitVectors(up, dir);
              ball = group;
            } else {
              ball = new THREE.Mesh(
                new THREE.SphereGeometry(ballSubtype === DAMAGE_SUBTYPE.SMOKE ? 0.16 : 0.12, 12, 12),
                new THREE.MeshStandardMaterial({
                  color: ballProfile.color || enemy.baseColor,
                  emissive: ballProfile.color || enemy.baseColor,
                  emissiveIntensity: 0.55
                })
              );
            }
            ball.position.copy(enemyPos).addScaledVector(dir, enemyRadius + 0.2);
            ball.userData.velocity = dir.clone().multiplyScalar(6);
            ball.userData.life = 5;
            const dmg = Math.max(500, 1000 - (dist / 10) * 500);
            ball.userData.damagePacket = buildHostileDamagePacket(dmg, ballSubtype, "enemy");
            ball.userData.subtype = ballSubtype;
            scene.add(ball);
            enemyProjectiles.push(ball);
            enemy.nextBall = now + 5;
          }

          if (targeting && now >= enemy.nextBeam) {
            const beamSubtype = enemy.beamSubtype || DAMAGE_SUBTYPE.LASER;
            applyDamage(buildHostileDamagePacket(7500, beamSubtype, "enemy"), { position: player.position.clone(), direct: true });
            const beamColor = ATTRIBUTE_PROFILE[beamSubtype]?.color || 0xffffff;
            const beamMat = new THREE.LineBasicMaterial({ color: beamColor });
            const beamGeo = new THREE.BufferGeometry().setFromPoints([enemyPos.clone(), player.position.clone()]);
            const beam = new THREE.Line(beamGeo, beamMat);
            beam.userData.life = 0.3;
            scene.add(beam);
            enemyBeams.push(beam);
            enemy.nextBeam = now + 50;
            enemy.chargeStart = enemy.nextBeam - 10;
          }
          if (targeting) {
            const dx = enemyPos.x - player.position.x;
            const dz = enemyPos.z - player.position.z;
            const localX = dx * Math.cos(yaw) - dz * Math.sin(yaw);
            const localZ = dx * Math.sin(yaw) + dz * Math.cos(yaw);
            threatDirs.push({ x: localX, z: localZ });
          }
        }

        for (const boss of bosses) {
          const bossPos = boss.mesh.position;
          const prevBossPos = bossPos.clone();
          const toPlayerVec = player.position.clone().sub(bossPos);
          const distToPlayer = toPlayerVec.length();
          const horizontalDistToPlayer = Math.hypot(toPlayerVec.x, toPlayerVec.z);
          const verticalDistToPlayer = Math.abs(toPlayerVec.y);
          const playerInSameRare = playerRoomIndex === boss.roomIndex;
          const wasAggro = !!boss.aggro;

          if (playerInSameRare) {
            boss.aggro = true;
            if (boss.state === "idle" || boss.state === "return") boss.state = "chase";
            if (!wasAggro) {
              setBossAnimAction(boss, "alert", now, 0.5);
            }
          } else if (boss.aggro) {
            boss.aggro = false;
            boss.state = "return";
            setBossAnimAction(boss, "return", now, 0.6);
          }

          if (boss.aggro) {
            if (now >= boss.nextMoveUpdate) {
              boss.moveTarget = player.position.clone();
              boss.nextMoveUpdate = now + 0.08;
            }
            if (now >= boss.nextDefenseAt) {
              triggerBossDefensePattern(boss, now);
            }
            if (now >= boss.nextUltimateAt) {
              triggerBossUltimatePattern(boss, now);
            }
            if (horizontalDistToPlayer <= 6.0 && verticalDistToPlayer <= 8.5 && now >= boss.nextMeleeAt) {
              performBossMeleePattern(boss, boss.meleePatternIndex, now, distToPlayer);
              boss.meleePatternIndex = (boss.meleePatternIndex + 1) % 2;
            }
            if (now >= boss.nextMoveSkillAt) {
              performBossMovePattern(boss, boss.movePatternIndex, now);
              boss.movePatternIndex = (boss.movePatternIndex + 1) % 2;
            }
            if (horizontalDistToPlayer <= 30 && verticalDistToPlayer <= 18 && now >= boss.nextRangedAt) {
              performBossRangedPattern(boss, boss.rangedPatternIndex, now);
              boss.rangedPatternIndex = (boss.rangedPatternIndex + 1) % 2;
            }
          } else {
            boss.moveTarget = boss.spawnPos.clone();
          }

          if (now >= (boss.animActionUntil || 0)) {
            if (boss.aggro) {
              setBossAnimAction(boss, "chase", now, 0.35);
            } else if (boss.state === "return") {
              setBossAnimAction(boss, "return", now, 0.45);
            } else {
              setBossAnimAction(boss, "idle", now, 0.55);
            }
          }

          if (now < boss.ultimateUntil && now >= boss.nextUltimatePulseAt) {
            const pulseSubtype = (boss.ultimatePulseIndex || 0) % 2 === 0
              ? (boss.primarySubtype || boss.ballSubtype || DAMAGE_SUBTYPE.PULSE)
              : (boss.secondarySubtype || boss.beamSubtype || DAMAGE_SUBTYPE.LASER);
            const pulseColor = ATTRIBUTE_PROFILE[pulseSubtype]?.color || boss.baseColor;
            createExplosionField(bossPos.clone(), 3.2, 0, pulseColor, buildHostileDamagePacket(3200, pulseSubtype, "boss"));
            if (playerInSameRare && distToPlayer <= 8.2) {
              applyDamage(buildHostileDamagePacket(3200, pulseSubtype, "boss"), { position: bossPos.clone(), direct: false });
            }
            boss.nextUltimatePulseAt = now + 0.75;
            boss.ultimatePulseIndex = (boss.ultimatePulseIndex || 0) + 1;
          }

          const desired = boss.moveTarget.clone();
          const toTarget = desired.sub(bossPos);
          if (toTarget.lengthSq() > 0.0001) {
            const freezeFactor = getEnemyFreezeFactor(boss, now);
            const returnFactor = boss.aggro ? 1.35 : 0.85;
            const moveStep = Math.min(bossMoveSpeed * freezeFactor * returnFactor * delta, toTarget.length());
            toTarget.normalize().multiplyScalar(moveStep);
            bossPos.add(toTarget);
          }

          if (!boss.aggro && bossPos.distanceToSquared(boss.spawnPos) < 0.16) {
            boss.state = "idle";
          }

          const bounds = getRoomBounds(boss.roomIndex);
          bossPos.x = clamp(bossPos.x, bounds.minX, bounds.maxX);
          bossPos.z = clamp(bossPos.z, bounds.minZ, bounds.maxZ);
          const minBossY = floorY + enemyRadius;
          const maxBossY = floorY + enemyRadius + 9.5;
          bossPos.y = clamp(bossPos.y, minBossY, maxBossY);
          boss.velocity.copy(bossPos.clone().sub(prevBossPos).divideScalar(Math.max(delta, 0.0001)));

          let desiredYaw = boss.spawnYaw;
          if (boss.aggro) {
            const forward = player.position.clone().sub(bossPos);
            forward.y = 0;
            if (forward.lengthSq() > 0.0001) {
              desiredYaw = Math.atan2(-forward.x, -forward.z);
            }
          } else if (bossPos.distanceToSquared(boss.spawnPos) > 0.1) {
            const backToSpawn = boss.spawnPos.clone().sub(bossPos);
            backToSpawn.y = 0;
            if (backToSpawn.lengthSq() > 0.0001) {
              desiredYaw = Math.atan2(-backToSpawn.x, -backToSpawn.z);
            }
          }
          const yawDiff = Math.atan2(Math.sin(desiredYaw - boss.mesh.rotation.y), Math.cos(desiredYaw - boss.mesh.rotation.y));
          boss.mesh.rotation.y += yawDiff * Math.min(1, 4.5 * delta);
          animateBossModel(boss, now, delta);
          emitBossAmbientEffects(boss, now);
          emitBossTertiarySignatureEffect(boss, now);

          if (boss.core) {
            const shielding = now < boss.shieldUntil;
            const emissiveBoost = shielding ? 0.9 : 0.35;
            if (boss.core.material && boss.core.material.emissive) {
              boss.core.material.emissive.copy(boss.baseColor).multiplyScalar(emissiveBoost);
            }
          }

          if (boss.label) {
            boss.label.textContent = `${boss.name} AP ${Math.ceil(boss.ap)} / PA ${Math.ceil(boss.pa)}`;
            const labelPos = bossPos.clone().add(new THREE.Vector3(0, enemyRadius + 2.4, 0));
            labelPos.project(camera);
            const x = (labelPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-labelPos.y * 0.5 + 0.5) * window.innerHeight;
            boss.label.style.left = `${x}px`;
            boss.label.style.top = `${y}px`;
            boss.label.style.transform = "translate(-50%, -100%)";
            boss.label.style.display = (!sensoryBlind && labelPos.z < 1) ? "block" : "none";
            boss.label.classList.toggle("locked", boss === lockTarget);
          }

          if (playerInSameRare) {
            anyThreat = true;
            const dx = bossPos.x - player.position.x;
            const dz = bossPos.z - player.position.z;
            const localX = dx * Math.cos(yaw) - dz * Math.sin(yaw);
            const localZ = dx * Math.sin(yaw) + dz * Math.cos(yaw);
            threatDirs.push({ x: localX, z: localZ });
          }
        }

        for (let i = bossCoreDrops.length - 1; i >= 0; i -= 1) {
          const core = bossCoreDrops[i];
          core.mesh.rotation.y += delta * 1.8;
          core.mesh.position.y += Math.sin(now * 3 + i) * 0.002;
          const canPick = core.mesh.position.distanceTo(player.position) <= 1 && playerRoomIndex === core.roomIndex;
          if (canPick) {
            if (isBossCoreName(core.name)) {
              bossCoreInventory[core.name] += 1;
              bossCoreCodexUnlocked[core.name] = true;
              refreshCoreCollectionUI();
            }
            spawnFloatingText(core.mesh.position.clone().add(new THREE.Vector3(0, 0.45, 0)), `${core.name} 획득`, "#ffe7a0");
            removeBossCoreDrop(core);
            continue;
          }
          if (core.label) {
            const labelPos = core.mesh.position.clone().add(new THREE.Vector3(0, 0.45, 0));
            labelPos.project(camera);
            const x = (labelPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-labelPos.y * 0.5 + 0.5) * window.innerHeight;
            core.label.style.left = `${x}px`;
            core.label.style.top = `${y}px`;
            core.label.style.transform = "translate(-50%, -100%)";
            core.label.style.display = (!sensoryBlind && labelPos.z < 1) ? "block" : "none";
          }
        }

        let revivedThisFrame = false;
        let eggInteractHintVisible = false;
        for (let i = 0; i < bossEggs.length; i += 1) {
          const egg = bossEggs[i];
          egg.mesh.rotation.y += delta * 0.55;
          egg.mesh.position.y += Math.sin(now * 2.4 + i) * 0.0015;
          const inRange = egg.mesh.position.distanceTo(player.position) <= 5;
          const inSameRoom = playerRoomIndex === egg.roomIndex;
          if (inRange && inSameRoom) eggInteractHintVisible = true;
          if (keys.f && inRange && inSameRoom) {
            egg.holdTime += delta;
            if (egg.holdTime >= 1 && !revivedThisFrame) {
              spawnFloatingText(egg.mesh.position.clone().add(new THREE.Vector3(0, 0.8, 0)), `${egg.bossName} 부활`, "#ffffff");
              reviveBossFromEgg(egg);
              revivedThisFrame = true;
              break;
            }
          } else {
            egg.holdTime = 0;
          }
        }
        if (bossEggHint) bossEggHint.style.display = eggInteractHintVisible ? "block" : "none";

        if (lockWarning) {
          lockWarning.style.display = anyThreat ? "block" : "none";
        }
        if (hitGreen) {
          hitGreen.style.display = now < hitGreenUntil ? "block" : "none";
        }
        if (hitRed) {
          hitRed.style.display = now < hitRedUntil ? "block" : "none";
          const damageLine = hitRed.querySelector("div:nth-child(2)");
          if (damageLine) {
            damageLine.style.display = now < hitRedDamageUntil ? "block" : "none";
          }
        }
        if (threatArrows.length > 0) {
          const centerX = window.innerWidth / 2;
          const centerY = window.innerHeight / 2;
          const radius = 40;
          for (let i = 0; i < threatArrows.length; i += 1) {
            const el = threatArrows[i];
            if (!anyThreat || i >= threatDirs.length) {
              el.style.display = "none";
              continue;
            }
            const s = threatDirs[i];
            let dx = s.x;
            let dy = s.z;
            const len = Math.max(1, Math.hypot(dx, dy));
            const nx = dx / len;
            const ny = dy / len;
            const px = centerX + nx * radius;
            const py = centerY + ny * radius;
            const angle = Math.atan2(ny, nx) + Math.PI / 2;
            el.style.display = "block";
            el.style.left = `${px}px`;
            el.style.top = `${py}px`;
            el.style.transform = `translate(-50%, -50%) rotate(${angle}rad)`;
          }
        }

        // Lock-on: pick up to 13 enemies inside large circle (auto mode only)
        let count = 0;
        if (effectiveAutoAim) {
          const centerX = window.innerWidth / 2;
          const centerY = window.innerHeight / 2;
          const radiusPx = 320;
          const circleDrift = -cameraRoll * 420;
          lockCircleOffset += (circleDrift - lockCircleOffset) * Math.min(1, 7 * delta);
          if (lockCircleLarge) {
            lockCircleLarge.style.display = "block";
            lockCircleLarge.style.transform = `translate(-50%, -50%) translate(${lockCircleOffset}px, 0px)`;
          }
          const candidates = [];
          const lockCandidates = [];
          for (const candidate of enemies) {
            lockCandidates.push({ obj: candidate, pos: candidate.mesh.position });
          }
          for (const boss of bosses) {
            lockCandidates.push({ obj: boss, pos: boss.mesh.position });
          }
          for (const block of destructibleBlocks) {
            lockCandidates.push({ obj: block, pos: block.mesh.position });
          }
          for (const candidate of lockCandidates) {
            const pos = candidate.pos.clone().project(camera);
            if (pos.z > 1) continue;
            const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;
            const dx = x - (centerX + lockCircleOffset);
            const dy = y - centerY;
            const d2 = dx * dx + dy * dy;
            if (d2 <= radiusPx * radiusPx) {
              candidates.push({ target: candidate.obj, x, y, d2 });
            }
          }
          candidates.sort((a, b) => a.d2 - b.d2);
          lockTargets.length = 0;
          count = Math.min(13, candidates.length);
          for (let i = 0; i < count; i += 1) {
            lockTargets.push(candidates[i]);
          }
          if (count > 0) {
            lockTarget = lockTargets[0].target;
            lockTargetUntil = now + 1.5;
          } else if (now > lockTargetUntil) {
            lockTarget = null;
          }
          for (let i = 0; i < lockCircles.length; i += 1) {
            const el = lockCircles[i];
            if (i < count) {
              const t = lockTargets[i];
              el.style.display = "block";
              el.style.left = `${t.x}px`;
              el.style.top = `${t.y}px`;
              el.style.transform = "translate(-50%, -50%)";
              const targetPos = t.target.mesh.position.clone();
              const inRange = targetPos.distanceTo(player.position) <= 150;
              const color = inRange ? "rgba(255, 90, 90, 0.9)" : "rgba(255, 255, 255, 0.9)";
              const glow = inRange ? "0 0 8px rgba(255, 90, 90, 0.6)" : "0 0 8px rgba(255, 255, 255, 0.6)";
              el.style.borderColor = color;
              el.style.boxShadow = glow;
            } else {
              el.style.display = "none";
            }
          }
        } else {
          lockTargets.length = 0;
          lockTarget = null;
          if (lockCircleLarge) lockCircleLarge.style.display = "none";
          for (let i = 0; i < lockCircles.length; i += 1) {
            lockCircles[i].style.display = "none";
          }
        }

        const aimAssistActive = aimAssistHolding;
        if (aimAssistActive) {
          const centerX = window.innerWidth * 0.5;
          const centerY = window.innerHeight * 0.5;
          const targetAlive = !!(
            aimAssistTarget &&
            aimAssistTarget.mesh &&
            (enemies.includes(aimAssistTarget) || bosses.includes(aimAssistTarget) || destructibleBlocks.includes(aimAssistTarget))
          );
          const inRange = targetAlive
            ? isTargetInAimAssistRange(aimAssistTarget, effectiveAutoAim, centerX, centerY, lockCircleOffset)
            : false;
          if (aimAssistAcquirePending || !targetAlive || !inRange) {
            aimAssistTarget = findAimAssistTarget(effectiveAutoAim, centerX, centerY, lockCircleOffset);
            aimAssistAcquirePending = false;
          }
          if (aimAssistTarget) {
            const adjusted = applyAimAssist(aimAssistTarget, delta, true);
            if (adjusted) updateCamera();
          }
        } else {
          aimAssistAcquirePending = false;
          aimAssistTarget = null;
        }

        if (!paused) {
          fireCooldown -= delta;
          if ((firingLeft || firingRight) && fireCooldown <= 0) {
            fireCooldown = 0.1;
            const dirBase = new THREE.Vector3(
              -Math.sin(yaw) * Math.cos(pitch),
              Math.sin(pitch),
              -Math.cos(yaw) * Math.cos(pitch)
            ).normalize();
            const right = new THREE.Vector3(Math.sin(yaw + Math.PI / 2), 0, Math.cos(yaw + Math.PI / 2));
            const sides = [];
            if (firingLeft && !reloadingLeft && magLeft > 0) sides.push(-0.34);
            if (firingRight && !reloadingRight && magRight > 0) sides.push(0.34);
            for (const side of sides) {
              const isLeft = side < 0;
              const pelletCount = 13;
              const subtype = isLeft ? DAMAGE_SUBTYPE.LASER : DAMAGE_SUBTYPE.FLAME;
              const profile = ATTRIBUTE_PROFILE[subtype] || ATTRIBUTE_PROFILE.flame;
              const origin = new THREE.Vector3();
              if (isLeft) {
                gunLeft.getWorldPosition(origin);
                magLeft = Math.max(0, magLeft - 1);
              } else {
                gunRight.getWorldPosition(origin);
                magRight = Math.max(0, magRight - 1);
              }
              const pelletSpeed = 160;
              const pelletLife = 125;
              const pelletSize = isLeft ? 0.02 : 0.16;
              for (let i = 0; i < pelletCount; i += 1) {
                const isCenterPellet = i === 0;
                const spreadYaw = isCenterPellet ? 0 : (Math.random() - 0.5) * 0.08;
                const spreadPitch = isCenterPellet ? 0 : (Math.random() - 0.5) * 0.08;
                const dir = new THREE.Vector3(
                  -Math.sin(yaw + spreadYaw) * Math.cos(pitch + spreadPitch),
                  Math.sin(pitch + spreadPitch),
                  -Math.cos(yaw + spreadYaw) * Math.cos(pitch + spreadPitch)
                ).normalize();
                const bulletGeo = isLeft
                  ? new THREE.CylinderGeometry(0.02, 0.02, 2.4, 8)
                  : new THREE.BoxGeometry(pelletSize, pelletSize, pelletSize);
                const color = profile.color || 0x111111;
                const bulletMat = isLeft
                  ? new THREE.MeshStandardMaterial({
                    color,
                    emissive: color,
                    emissiveIntensity: 1.2,
                    transparent: true,
                    opacity: 0.75
                  })
                  : new THREE.MeshStandardMaterial({ color });
                const bullet = new THREE.Mesh(bulletGeo, bulletMat);
                if (isLeft) {
                  const up = new THREE.Vector3(0, 1, 0);
                  bullet.quaternion.setFromUnitVectors(up, dir);
                }
                const spawn = origin.clone().addScaledVector(dir, -0.05);
                bullet.position.copy(spawn);
                bullet.userData.velocity = dir.clone().multiplyScalar(pelletSpeed);
                bullet.userData.life = pelletLife;
                bullet.userData.range = 150;
                bullet.userData.travel = 0;
                if (isLeft) {
                  bullet.userData.damagePacket = buildDamagePacket(1000, subtype);
                } else {
                  bullet.userData.damagePacket = {
                    subtype: DAMAGE_SUBTYPE.FLAME,
                    attacks: [{ family: DAMAGE_FAMILY.BALLISTIC, amount: 1000, ignoreDefense: false }]
                  };
                }
                bullet.userData.explosionDamage = 500;
                bullet.userData.explosionPacket = isLeft
                  ? buildDamagePacket(500, DAMAGE_SUBTYPE.CLUSTER)
                  : {
                    subtype: DAMAGE_SUBTYPE.FLAME,
                    attacks: [{ family: DAMAGE_FAMILY.BALLISTIC, amount: 500, ignoreDefense: false }]
                  };
                bullet.userData.explosionRadius = 2;
                bullet.userData.color = color;
                bullet.userData.isBeam = isLeft;
                bullet.userData.hitRadius = isLeft ? 0.2 : pelletSize * 0.6;
                bullet.userData.lockIndex = i;
                bullet.userData.subtype = subtype;
                if (aimAssistActive && aimAssistTarget) {
                  bullet.userData.homingTarget = aimAssistTarget;
                  bullet.userData.assistFocus = true;
                } else if (effectiveAutoAim && lockTargets.length > 0) {
                  const initTarget = lockTargets[i % lockTargets.length];
                  bullet.userData.homingTarget = initTarget ? initTarget.target : null;
                  bullet.userData.assistFocus = false;
                } else {
                  bullet.userData.homingTarget = null;
                  bullet.userData.assistFocus = false;
                }
                scene.add(bullet);
                bullets.push(bullet);
              }
            }
            if (magLeft === 0 && !reloadingLeft && firingLeft) {
              reloadingLeft = true;
              reloadEndLeft = performance.now() / 1000 + reloadTime;
            }
            if (magRight === 0 && !reloadingRight && firingRight) {
              reloadingRight = true;
              reloadEndRight = performance.now() / 1000 + reloadTime;
            }
          }
        }

        for (let i = bullets.length - 1; i >= 0; i -= 1) {
          const b = bullets[i];
          const bulletPacket = b.userData.damagePacket || buildDamagePacket(0, b.userData.subtype || DAMAGE_SUBTYPE.FLAME);
          const bulletProfile = ATTRIBUTE_PROFILE[b.userData.subtype] || ATTRIBUTE_PROFILE.flame;
          let homingTarget = b.userData.homingTarget;
          const homingAlive = !!(homingTarget && homingTarget.mesh && (enemies.includes(homingTarget) || bosses.includes(homingTarget) || destructibleBlocks.includes(homingTarget)));
          if (!homingAlive) {
            b.userData.homingTarget = null;
            homingTarget = null;
            if (b.userData.assistFocus) {
              const assistAlive = !!(
                aimAssistTarget &&
                aimAssistTarget.mesh &&
                (enemies.includes(aimAssistTarget) || bosses.includes(aimAssistTarget) || destructibleBlocks.includes(aimAssistTarget))
              );
              if (assistAlive) {
                homingTarget = aimAssistTarget;
                b.userData.homingTarget = aimAssistTarget;
              }
            } else if (effectiveAutoAim && lockTargets.length > 0) {
              let best = null;
              let bestD2 = Infinity;
              for (const t of lockTargets) {
                if (!t || !t.target || !t.target.mesh) continue;
                const d2 = t.target.mesh.position.distanceToSquared(b.position);
                if (d2 < bestD2) {
                  best = t.target;
                  bestD2 = d2;
                }
              }
              if (best) {
                homingTarget = best;
                b.userData.homingTarget = best;
              }
            }
          }
          if (homingTarget && homingTarget.mesh) {
            const targetPos = homingTarget.mesh.position.clone();
            const targetVel = homingTarget.velocity ? homingTarget.velocity.clone() : new THREE.Vector3();
            const speed = Math.max(1, b.userData.velocity.length());
            const targetDist = b.position.distanceTo(targetPos);
            const leadTime = Math.min(0.45, targetDist / speed);
            const predicted = targetPos.addScaledVector(targetVel, leadTime);
            const toPredicted = predicted.sub(b.position);
            if (toPredicted.lengthSq() > 1e-8) {
              const desired = toPredicted.normalize();
              const current = b.userData.velocity.clone().normalize();
              const nearBoost = targetDist < 3 ? 1 : (targetDist < 8 ? 0.75 : 0.5);
              const steerPower = b.userData.isBeam ? nearBoost : nearBoost * 0.85;
              const steer = current.lerp(desired, steerPower).normalize();
              b.userData.velocity.copy(steer.multiplyScalar(speed));
            }
          }
          const prevPos = b.position.clone();
          const stepDist = b.userData.velocity.length() * delta;
          b.position.addScaledVector(b.userData.velocity, delta);
          b.userData.life -= delta;
          b.userData.travel = (b.userData.travel || 0) + stepDist;
          if ((bulletProfile.families || []).includes(DAMAGE_FAMILY.EN)) {
            const offset = new THREE.Vector3((Math.random() - 0.5) * 0.18, (Math.random() - 0.5) * 0.18, (Math.random() - 0.5) * 0.18);
            spawnProjectileParticle(b.position.clone().add(offset), bulletProfile.particleColor || b.userData.color, 0.032, 0.2);
          } else if (bulletProfile.particleColor && Math.random() < 0.55) {
            spawnProjectileParticle(b.position.clone(), bulletProfile.particleColor, 0.03, 0.16);
          }
          let hit = false;
          const roomsHere = getRoomsForPos(b.position);
          const roomsPrev = getRoomsForPos(prevPos);
          if (roomsHere.length === 0 && roomsPrev.length === 0) {
            hit = true;
          } else {
            for (const room of rooms) {
              for (const box of room.blockBoxes) {
                if (segmentIntersectsAABB(prevPos, b.position, box)) {
                  if (box.destructible) {
                    applyDestructibleDamage(box.destructible, bulletPacket, { position: b.position.clone(), direct: true });
                  }
                  hit = true;
                  break;
                }
              }
              if (hit) break;
            }
          }
          if (!hit) {
            const hitRadius = b.userData.hitRadius || 0.2;
            const hitRadiusSq = (enemyRadius + hitRadius) * (enemyRadius + hitRadius);
            for (const enemy of enemies) {
              const d2 = segmentPointDistanceSquared(prevPos, b.position, enemy.mesh.position);
              if (d2 <= hitRadiusSq) {
                applyEnemyDamage(enemy, bulletPacket, { position: b.position.clone(), direct: true });
                hit = true;
                break;
              }
            }
            if (!hit) {
              for (const boss of bosses) {
                const d2 = segmentPointDistanceSquared(prevPos, b.position, boss.mesh.position);
                if (d2 <= hitRadiusSq * 1.8) {
                  applyBossDamage(boss, bulletPacket, { position: b.position.clone(), direct: true });
                  hit = true;
                  break;
                }
              }
            }
          }
          if (hit) {
            const fxColor = b.userData.color || 0xffffff;
            if (b.userData.explosionDamage > 0) {
              createExplosionField(
                b.position.clone(),
                b.userData.explosionRadius || 2,
                b.userData.explosionDamage || 0,
                fxColor,
                b.userData.explosionPacket || buildDamagePacket(b.userData.explosionDamage || 0, DAMAGE_SUBTYPE.CLUSTER)
              );
            }
            const onHitExplosion = bulletProfile.onHitExplosion;
            if (onHitExplosion) {
              const extraScale = typeof onHitExplosion.scale === "number" ? onHitExplosion.scale : 0.4;
              const extraPacket = buildDamagePacket(
                (bulletPacket.attacks || []).reduce((sum, a) => sum + (a.amount || 0), 0) * extraScale,
                b.userData.subtype || DAMAGE_SUBTYPE.PLASMA,
                {
                  families: onHitExplosion.subtype === DAMAGE_SUBTYPE.KOJIMA
                    ? [DAMAGE_FAMILY.BALLISTIC, DAMAGE_FAMILY.EXPLOSIVE]
                    : [DAMAGE_FAMILY.EN, DAMAGE_FAMILY.EXPLOSIVE],
                  ignoreDefense: onHitExplosion.subtype === DAMAGE_SUBTYPE.KOJIMA ? [DAMAGE_FAMILY.BALLISTIC] : []
                }
              );
              createExplosionField(
                b.position.clone(),
                onHitExplosion.radius || 2.2,
                (bulletPacket.attacks || []).reduce((sum, a) => sum + (a.amount || 0), 0) * extraScale,
                bulletProfile.particleColor || fxColor,
                extraPacket
              );
            }
            scene.remove(b);
            bullets.splice(i, 1);
            continue;
          }
          if (b.userData.life <= 0 || (b.userData.range && b.userData.travel >= b.userData.range) || roomsHere.length === 0) {
            scene.remove(b);
            bullets.splice(i, 1);
          }
        }
        if (bullets.length > 2000) {
          const excess = bullets.length - 2000;
          for (let i = 0; i < excess; i += 1) {
            const b = bullets.shift();
            if (b) scene.remove(b);
          }
        }

        for (let i = enemyProjectiles.length - 1; i >= 0; i -= 1) {
          const p = enemyProjectiles[i];
          if (p.userData.velocity) {
            p.position.addScaledVector(p.userData.velocity, delta);
            p.userData.life -= delta;
            const pProfile = ATTRIBUTE_PROFILE[p.userData.subtype] || ATTRIBUTE_PROFILE.pulse;
            if ((pProfile.families || []).includes(DAMAGE_FAMILY.EN) && Math.random() < 0.9) {
              const wobble = new THREE.Vector3((Math.random() - 0.5) * 0.14, (Math.random() - 0.5) * 0.14, (Math.random() - 0.5) * 0.14);
              spawnProjectileParticle(p.position.clone().add(wobble), pProfile.particleColor || pProfile.color, 0.028, 0.18);
            } else if (p.userData.subtype === DAMAGE_SUBTYPE.SHOCK || p.userData.subtype === DAMAGE_SUBTYPE.FREEZE) {
              if (Math.random() < 0.8) {
                const wobble = new THREE.Vector3((Math.random() - 0.5) * 0.16, (Math.random() - 0.5) * 0.16, (Math.random() - 0.5) * 0.16);
                spawnProjectileParticle(p.position.clone().add(wobble), pProfile.particleColor || pProfile.color, 0.03, 0.22);
              }
            }
            if (p.position.distanceTo(player.position) <= playerHalf + 0.12) {
              applyDamage(p.userData.damagePacket || 500, { position: p.position.clone(), direct: true });
              scene.remove(p);
              enemyProjectiles.splice(i, 1);
              continue;
            }
            if (p.userData.life <= 0 || p.position.distanceTo(player.position) > 30) {
              scene.remove(p);
              enemyProjectiles.splice(i, 1);
            }
          } else {
            p.userData.life -= delta;
            p.userData.startLife = p.userData.startLife || 0.25;
            const ratio = Math.max(0, p.userData.life / p.userData.startLife);
            p.material.opacity = 0.6 * ratio;
            p.scale.setScalar(1 + (1 - ratio) * 1.8);
            if (p.userData.life <= 0) {
              scene.remove(p);
              enemyProjectiles.splice(i, 1);
            }
          }
        }

        for (let i = enemyBeams.length - 1; i >= 0; i -= 1) {
          const beam = enemyBeams[i];
          beam.userData.life -= delta;
          if (beam.userData.life <= 0) {
            scene.remove(beam);
            enemyBeams.splice(i, 1);
          }
        }

        for (let i = bossTelegraphs.length - 1; i >= 0; i -= 1) {
          const tele = bossTelegraphs[i];
          tele.userData.life -= delta;
          const ratio = Math.max(0, tele.userData.life / Math.max(tele.userData.startLife || 0.001, 0.001));
          if (tele.material) tele.material.opacity = 0.9 * ratio;
          if (tele.userData.kind === "circle") {
            const scale = 1 + (1 - ratio) * 0.18;
            tele.scale.set(scale, scale, scale);
          } else if (tele.userData.kind === "line") {
            tele.scale.x = 1 + (1 - ratio) * 0.12;
          } else if (tele.userData.kind === "sector") {
            const pulse = 1 + Math.sin(now * 12) * 0.03;
            tele.scale.set(pulse, pulse, pulse);
          }
          if (tele.userData.life <= 0) {
            scene.remove(tele);
            bossTelegraphs.splice(i, 1);
          }
        }

        for (let i = explosionFields.length - 1; i >= 0; i -= 1) {
          const fx = explosionFields[i];
          fx.userData.life -= delta;
          const ratio = Math.max(0, fx.userData.life / fx.userData.startLife);
          fx.material.opacity = 0.9 * ratio;
          fx.scale.setScalar(1 + (1 - ratio) * 2.5);
          const radius = fx.userData.radius || 2;
          const dps = fx.userData.dps || 0;
          if (dps > 0) {
            const packetPerTick = scaleDamagePacket(
              fx.userData.damagePacket || buildDamagePacket(dps, DAMAGE_SUBTYPE.CLUSTER),
              delta
            );
            for (const enemy of enemies) {
              if (enemy.mesh.position.distanceTo(fx.position) <= radius) {
                applyEnemyDamage(enemy, packetPerTick, { position: fx.position.clone(), direct: false });
              }
            }
            for (const boss of bosses) {
              if (boss.mesh.position.distanceTo(fx.position) <= radius) {
                applyBossDamage(boss, packetPerTick, { position: fx.position.clone(), direct: false });
              }
            }
            for (const block of destructibleBlocks) {
              if (block.mesh.position.distanceTo(fx.position) <= radius) {
                applyDestructibleDamage(block, packetPerTick, { position: fx.position.clone(), direct: false });
              }
            }
          }
          if (fx.userData.life <= 0) {
            scene.remove(fx);
            explosionFields.splice(i, 1);
          }
        }

        for (let i = projectileParticles.length - 1; i >= 0; i -= 1) {
          const p = projectileParticles[i];
          p.userData.life -= delta;
          const ratio = Math.max(0, p.userData.life / p.userData.startLife);
          p.material.opacity = 0.9 * ratio;
          p.scale.setScalar(1 + (1 - ratio) * 1.25);
          if (p.userData.life <= 0) {
            scene.remove(p);
            projectileParticles.splice(i, 1);
          }
        }

        for (let i = statusLinks.length - 1; i >= 0; i -= 1) {
          const link = statusLinks[i];
          link.userData.life -= delta;
          const ratio = Math.max(0, link.userData.life / link.userData.startLife);
          link.material.opacity = 0.95 * ratio;
          if (link.userData.life <= 0) {
            scene.remove(link);
            statusLinks.splice(i, 1);
          }
        }

        for (let i = statusParticles.length - 1; i >= 0; i -= 1) {
          const p = statusParticles[i];
          p.userData.life -= delta;
          const mode = p.userData.mode || "";
          if (p.userData.velocity) {
            p.position.addScaledVector(p.userData.velocity, delta);
            p.userData.velocity.multiplyScalar(0.985);
          }
          const ratio = Math.max(0, p.userData.life / p.userData.startLife);
          p.material.opacity = 0.95 * ratio;
          if (mode === "smoke") {
            p.userData.velocity.y += 0.2 * delta;
            if (p.position.distanceTo(player.position) <= playerHalf + 0.32) {
              minimapBlindUntil = Math.max(minimapBlindUntil, now + 3);
              p.userData.life = 0;
            }
          } else {
            p.userData.velocity.y -= 0.25 * delta;
          }
          if (mode === "shock" && !playerHasActivePaShield() && p.position.distanceTo(player.position) <= playerHalf + 0.22) {
            stamina = Math.max(0, stamina - 1);
            if (stamina <= 0) {
              stamina = 0;
              staminaCooldown = true;
              staminaCooldownEnd = now + 10;
            }
            p.userData.life = 0;
          }
          if (mode === "freeze" && !playerHasActivePaShield() && p.position.distanceTo(player.position) <= playerHalf + 0.22) {
            en = Math.max(0, en - 1);
            if (en <= 0) {
              en = 0;
              enCooldown = true;
            }
            p.userData.life = 0;
          }
          if (p.userData.life <= 0) {
            scene.remove(p);
            statusParticles.splice(i, 1);
          }
        }

        for (let i = acidMarks.length - 1; i >= 0; i -= 1) {
          const mark = acidMarks[i];
          const ttl = mark.endAt - now;
          mark.mesh.material.opacity = Math.max(0, Math.min(1, ttl / 5));
          if (now >= mark.nextTickAt) {
            mark.nextTickAt += 1;
            const tick = Math.max(0, mark.tickDamage || 0);
            if (mark.targetKind === "player") {
              if (now < mark.endAt) playerPaRegenBlockedUntil = Math.max(playerPaRegenBlockedUntil, mark.endAt);
              if (!paCooldown && pa > 0) {
                pa = Math.max(0, pa - tick);
              } else {
                ap = Math.max(1, ap - tick * 1.25);
              }
            } else if (mark.targetKind === "enemy" && mark.targetRef && enemies.includes(mark.targetRef)) {
              if (mark.targetRef.pa > 0) {
                mark.targetRef.pa = Math.max(0, mark.targetRef.pa - tick);
              } else {
                mark.targetRef.ap = Math.max(0, mark.targetRef.ap - tick * 1.25);
              }
            }
          }
          if (now >= mark.endAt || (mark.targetKind === "enemy" && (!mark.targetRef || !enemies.includes(mark.targetRef)))) {
            if (mark.mesh.parent) mark.mesh.parent.remove(mark.mesh);
            acidMarks.splice(i, 1);
          }
        }

        for (let i = floatingTexts.length - 1; i >= 0; i -= 1) {
          const f = floatingTexts[i];
          f.life -= delta;
          f.pos.addScaledVector(f.velocity, delta);
          const screen = f.pos.clone().project(camera);
          const x = (screen.x * 0.5 + 0.5) * window.innerWidth;
          const y = (-screen.y * 0.5 + 0.5) * window.innerHeight;
          f.el.style.left = `${x}px`;
          f.el.style.top = `${y}px`;
          f.el.style.opacity = `${Math.max(0, f.life / f.startLife)}`;
          if (f.life <= 0) {
            f.el.remove();
            floatingTexts.splice(i, 1);
          }
        }


        if (reloadingLeft && now >= reloadEndLeft) {
          reloadingLeft = false;
          magLeft = magMax;
        }
        if (reloadingRight && now >= reloadEndRight) {
          reloadingRight = false;
          magRight = magMax;
        }
      const reserveLeftText = reserveLeft === Infinity ? "∞" : reserveLeft;
      const reserveRightText = reserveRight === Infinity ? "∞" : reserveRight;
      if (ammoLeft) {
        ammoLeft.textContent = reloadingLeft
          ? "0 장전중"
          : `장전 ${magLeft} / 잔탄 ${reserveLeftText}`;
        ammoLeft.style.color = reloadingLeft ? "#ff4b4b" : "#ffffff";
      }
      if (ammoRight) {
        ammoRight.textContent = reloadingRight
          ? "0 장전중"
          : `장전 ${magRight} / 잔탄 ${reserveRightText}`;
        ammoRight.style.color = reloadingRight ? "#ff4b4b" : "#ffffff";
      }

        if (apPanel && apFill) {
          apPanel.querySelector(".label").textContent = `AP ${ap} / ${apMax}`;
          apFill.style.width = `${(ap / apMax) * 100}%`;
          apFill.style.background = now < repairHealEnd ? "#6bff6b" : "#ffffff";
        }
        if (paPanel && paFill) {
          paPanel.querySelector(".label").textContent = `PA ${pa} / ${paMax}`;
          paFill.style.width = `${(pa / paMax) * 100}%`;
          paFill.style.background = paCooldown ? "#ff4b4b" : "#59ff7a";
        }

        if (expansionHolding && expansionHoldStart && performance.now() - expansionHoldStart >= 1000) {
          expansionHoldStart = performance.now();
          if (now >= expansionCooldownEnd) {
            expansionCooldownEnd = now + 50;
            expansionActiveUntil = now + 50;
            expansionNextHeal = now + 0.2;
            expansionShockDone = false;
          }
        }
        if (now < expansionActiveUntil && now >= expansionNextHeal) {
          const roll = 50 + Math.floor(Math.random() * 951);
          ap = Math.min(apMax, ap + roll);
          expansionNextHeal = now + 0.2;
        }
        if (now < expansionActiveUntil) {
          if (!expansionShockDone) {
            for (const enemy of enemies) {
              if (enemy.mesh.position.distanceTo(player.position) <= 10) {
                enemy.pa = Math.max(0, enemy.pa - 10000);
                if (enemy.pa === 0) {
                  enemy.ap = Math.max(0, enemy.ap - 10000);
                }
              }
            }
            for (const boss of bosses) {
              if (boss.mesh.position.distanceTo(player.position) <= 10) {
                boss.pa = Math.max(0, boss.pa - 10000);
                if (boss.pa === 0) {
                  boss.ap = Math.max(0, boss.ap - 10000);
                }
              }
            }
            expansionShockDone = true;
          }
          const dps = (dist) => {
            if (dist < 2) return 1000;
            if (dist < 4) return 500;
            if (dist < 6) return 250;
            if (dist < 8) return 125;
            return 0;
          };
          for (const enemy of enemies) {
            const dist = enemy.mesh.position.distanceTo(player.position);
            const damagePerSecond = dps(dist);
            if (damagePerSecond > 0) {
              let dmg = damagePerSecond * delta;
              const usePa = Math.min(enemy.pa, dmg);
              enemy.pa -= usePa;
              dmg -= usePa;
              if (dmg > 0) {
                enemy.ap = Math.max(0, enemy.ap - dmg);
              }
            }
          }
          for (const boss of bosses) {
            const dist = boss.mesh.position.distanceTo(player.position);
            const damagePerSecond = dps(dist);
            if (damagePerSecond > 0) {
              applyBossDamage(boss, damagePerSecond * delta, { position: boss.mesh.position.clone(), direct: false }, { skipStatus: true });
            }
          }
        }

        if (kitHolding && kitHoldStart && performance.now() - kitHoldStart >= 1000) {
          kitHoldStart = performance.now();
          if (now >= repairCooldownEnd && (kitCount === Infinity || kitCount > 0)) {
            if (kitCount !== Infinity) kitCount -= 1;
            repairCooldownEnd = now + 10;
            repairHealStart = now;
            repairHealEnd = now + 1;
            repairHealAmount = Math.floor(apMax / 4 + ap / 3);
            repairHealApplied = 0;
            repairOverlayUntil = now + 0.2;
            repairActiveStart = now;
            repairActiveUntil = now + 6;
            pa = paMax;
            paCooldown = false;
            paCooldownEnd = 0;
            paInvulnUntil = now + 1.5;
          }
        }

        if (repairHealEnd > now) {
          const t = (now - repairHealStart) / (repairHealEnd - repairHealStart);
          const ratio = Math.max(0, Math.min(1, t));
          const target = Math.floor(repairHealAmount * ratio);
          const heal = Math.max(0, target - repairHealApplied);
          if (heal > 0) {
            ap = Math.min(apMax, ap + heal);
            repairHealApplied += heal;
          }
        }

        if (kitCooldownEl) {
          const cooldownLeft = Math.max(0, repairCooldownEnd - now);
          const ratio = Math.min(1, cooldownLeft / 10);
          kitCooldownEl.style.transform = `scaleY(${ratio})`;
        }

        if (repairOverlay) {
          const overlayActive = now < repairOverlayUntil;
          repairOverlay.style.opacity = overlayActive ? "1" : "0";
        }

        if (damageShield) {
          const remaining = Math.max(0, repairActiveUntil - now);
          const elapsed = Math.max(0, now - repairActiveStart);
          const stage = Math.floor(elapsed / 1.5);
          const alpha = remaining > 0 ? Math.max(0, 0.8 - stage * 0.2) : 0;
          damageShield.style.borderColor = `rgba(140, 255, 140, ${alpha})`;
        }
        if (expansionOverlay) {
          expansionOverlay.style.opacity = now < expansionActiveUntil ? "1" : "0";
        }
        if (statusBlackOverlay) {
          let blackOpacity = 0;
          if (now < blackOutFullUntil) {
            blackOpacity = 1;
          } else if (now < blackOutRecoverUntil) {
            const t = (now - blackOutFullUntil) / Math.max(0.001, blackOutRecoverUntil - blackOutFullUntil);
            blackOpacity = 1 - Math.min(1, Math.max(0, t));
          }
          statusBlackOverlay.style.opacity = `${blackOpacity}`;
        }
        if (statusWhiteOverlay) {
          let whiteOpacity = 0;
          if (now < whiteOutFullUntil) {
            whiteOpacity = 1;
          } else if (now < whiteOutRecoverUntil) {
            const t = (now - whiteOutFullUntil) / Math.max(0.001, whiteOutRecoverUntil - whiteOutFullUntil);
            whiteOpacity = 1 - Math.min(1, Math.max(0, t));
          }
          statusWhiteOverlay.style.opacity = `${whiteOpacity}`;
        }
        if (expansionCooldownEl) {
          const cooldownLeft = Math.max(0, expansionCooldownEnd - now);
          const ratio = Math.min(1, cooldownLeft / 50);
          expansionCooldownEl.style.transform = `scaleY(${ratio})`;
        }
        if (now < repairActiveUntil) {
          const elapsed = now - repairActiveStart;
          if (elapsed < 1.5) damageScale = 0;
          else if (elapsed < 3) damageScale = 0.25;
          else if (elapsed < 4.5) damageScale = 0.5;
          else damageScale = 0.75;
        } else {
          damageScale = 1;
        }

        if (!paCooldown && pa <= 0) {
          pa = 0;
          paCooldown = true;
          paCooldownEnd = now + 50;
        }
        const paRegenBlocked = now < playerPaRegenBlockedUntil;
        if (!paRegenBlocked) {
          if (paCooldown) {
            pa = Math.min(paMax, pa + 528 * delta);
            if (pa >= paMax) {
              pa = paMax;
              paCooldown = false;
            }
          } else {
            pa = Math.min(paMax, pa + 132 * delta);
          }
        }

        if (now < expansionActiveUntil) {
          const base = new THREE.Vector3(player.position.x, player.position.y + playerHalf, player.position.z);
          expansionSphere.visible = true;
          expansionSphere.position.copy(base);
        } else {
          expansionSphere.visible = false;
        }

        if (now < expansionCooldownEnd) {
          expansionParticleTimer += delta;
          const spawnInterval = 0.05;
          const right = new THREE.Vector3(Math.sin(yaw + Math.PI / 2), 0, Math.cos(yaw + Math.PI / 2));
          const back = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
          while (expansionParticleTimer >= spawnInterval) {
            expansionParticleTimer -= spawnInterval;
            for (const side of [-1, 1]) {
              const p = new THREE.Mesh(expansionParticleGeo, expansionParticleMat.clone());
              const base = new THREE.Vector3(player.position.x, player.position.y + playerHalf, player.position.z);
              const lateral = right.clone().multiplyScalar(0.35 * side);
              const origin = base.add(lateral).addScaledVector(back, 0.1);
              p.position.copy(origin);
              p.userData.velocity = right.clone().multiplyScalar(0.6 * side)
                .add(new THREE.Vector3((Math.random() - 0.5) * 0.2, 0.4 + Math.random() * 0.4, (Math.random() - 0.5) * 0.2));
              p.userData.life = 0.9 + Math.random() * 0.6;
              p.userData.startLife = p.userData.life;
              scene.add(p);
              expansionParticles.push(p);
            }
          }
        }

        for (let i = expansionParticles.length - 1; i >= 0; i -= 1) {
          const p = expansionParticles[i];
          p.position.addScaledVector(p.userData.velocity, delta);
          p.userData.life -= delta;
          p.material.opacity = Math.max(0, 0.8 * (p.userData.life / p.userData.startLife));
          if (p.userData.life <= 0) {
            scene.remove(p);
            expansionParticles.splice(i, 1);
          }
        }

      renderer.render(scene, camera);
      previewPivot.rotation.y = previewRotY;
      previewPivot.rotation.x = previewRotX;
      previewCamera.lookAt(0, 0, 0);
      previewRenderer.render(previewScene, previewCamera);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>




